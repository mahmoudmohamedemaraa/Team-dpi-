===== C:\Users\target\Depi\graduation_project\Team-dpi-\.vscode\settings.json =====
{
    "java.configuration.updateBuildConfiguration": "interactive"
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\android\app\src\debug\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\android\app\src\main\res\drawable\launch_background.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\android\app\src\main\res\drawable-v21\launch_background.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\android\app\src\main\res\values\styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\android\app\src\main\res\values-night\styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\android\app\src\main\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="depi_project"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
    <uses-permission android:name="android.permission.CALL_PHONE" />

</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\android\app\src\profile\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\ios\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json =====
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\ios\Runner\Assets.xcassets\LaunchImage.imageset\Contents.json =====
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\cubits\get_notifications_cubit\get_notifications_cubit.dart =====
import 'dart:async';

import 'package:bloc/bloc.dart';
import 'package:depi_project/core/entities/report_entity.dart';
import 'package:equatable/equatable.dart';
import 'package:meta/meta.dart';

import '../../../features/notifications/domain/entities/report_notification_entity.dart';
import '../../../features/notifications/domain/repos/notifications_repo.dart';

part 'get_notifications_state.dart';

class GetNotificationsCubit extends Cubit<GetNotificationsState> {
  GetNotificationsCubit(this.notificationsRepo)
    : super(GetNotificationsInitial());
  final NotificationsRepo notificationsRepo;
  StreamSubscription? streamSubscription;
  void getUserNotifications(String userId) {
    emit(GetNotificationsLoading());
    streamSubscription?.cancel();
    streamSubscription = notificationsRepo.getUserNotifications(userId).listen((
      either,
    ) {
      either.fold(
        (failure) {
          emit(GetNotificationsFailure(message: failure.message));
        },
        (notifications) {
          emit(GetNotificationsSuccess(notifications: notifications));
        },
      );
    });
  }

  Future<NotificationTapResult> handleNotificationTap(
    ReportNotificationEntity notification,
  ) async {
    if (!notification.isRead) {
      if (notification.id.isNotEmpty) {
        final markResult = await notificationsRepo.markNotificationAsRead(
          notification.id,
        );

        return markResult.fold(
          (failure) => NotificationTapResult.error(failure.message),
          (_) {
            final currentState = state;
            if (currentState is GetNotificationsSuccess) {
              final updatedNotifications = currentState.notifications
                  .map(
                    (item) => item.id == notification.id
                        ? item.copyWith(isRead: true)
                        : item,
                  )
                  .toList();
              emit(
                GetNotificationsSuccess(notifications: updatedNotifications),
              );
            }
            return const NotificationTapResult.markedAsRead();
          },
        );
      }
      return const NotificationTapResult.markedAsRead();
    }

    final reportResult = await notificationsRepo.getReportById(
      notification.reportId,
    );

    return reportResult.fold(
      (failure) => NotificationTapResult.error(failure.message),
      (report) => NotificationTapResult.openReport(report),
    );
  }

  Future<void> markAsRead(ReportNotificationEntity notification) async {
    if (!notification.isRead && notification.id.isNotEmpty) {
      final markResult = await notificationsRepo.markNotificationAsRead(
        notification.id,
      );

      markResult.fold(
        (failure) {
          throw Exception(failure.message);
        },
        (_) {
          final currentState = state;
          if (currentState is GetNotificationsSuccess) {
            final updatedNotifications = currentState.notifications
                .map(
                  (item) => item.id == notification.id
                      ? item.copyWith(isRead: true)
                      : item,
                )
                .toList();
            emit(GetNotificationsSuccess(notifications: updatedNotifications));
          }
        },
      );
    }
  }

  Future<NotificationOpenResult> openNotification(
    ReportNotificationEntity notification,
  ) async {
    String? warningMessage;

    if (!notification.isRead && notification.id.isNotEmpty) {
      final markResult = await notificationsRepo.markNotificationAsRead(
        notification.id,
      );

      markResult.fold(
        (failure) {
          warningMessage = failure.message;
        },
        (_) {
          final currentState = state;
          if (currentState is GetNotificationsSuccess) {
            final updatedNotifications = currentState.notifications
                .map(
                  (item) => item.id == notification.id
                      ? item.copyWith(isRead: true)
                      : item,
                )
                .toList();
            emit(GetNotificationsSuccess(notifications: updatedNotifications));
          }
        },
      );
    }

    final reportResult = await notificationsRepo.getReportById(
      notification.reportId,
    );

    return reportResult.fold(
      (failure) => throw Exception(failure.message),
      (report) =>
          NotificationOpenResult(report: report, warning: warningMessage),
    );
  }

  @override
  Future<void> close() {
    streamSubscription?.cancel();
    return super.close();
  }
}

class NotificationOpenResult {
  const NotificationOpenResult({required this.report, this.warning});

  final ReportEntity report;
  final String? warning;
}

class NotificationTapResult {
  const NotificationTapResult._({
    this.report,
    this.errorMessage,
    required this.action,
  });

  final ReportEntity? report;
  final String? errorMessage;
  final NotificationTapAction action;

  const NotificationTapResult.markedAsRead()
    : report = null,
      errorMessage = null,
      action = NotificationTapAction.markedAsRead;

  const NotificationTapResult.openReport(ReportEntity report)
    : report = report,
      errorMessage = null,
      action = NotificationTapAction.openReport;

  const NotificationTapResult.error(String message)
    : report = null,
      errorMessage = message,
      action = NotificationTapAction.error;
}

enum NotificationTapAction { markedAsRead, openReport, error }
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\cubits\get_notifications_cubit\get_notifications_state.dart =====
part of 'get_notifications_cubit.dart';

@immutable
sealed class GetNotificationsState extends Equatable {
  const GetNotificationsState();

  @override
  List<Object?> get props => [];
}

final class GetNotificationsInitial extends GetNotificationsState {
  const GetNotificationsInitial();
}

final class GetNotificationsLoading extends GetNotificationsState {
  const GetNotificationsLoading();
}

final class GetNotificationsSuccess extends GetNotificationsState {
  final List<ReportNotificationEntity> notifications;

  const GetNotificationsSuccess({required this.notifications});

  @override
  List<Object?> get props => [notifications];
}

final class GetNotificationsFailure extends GetNotificationsState {
  final String message;

  const GetNotificationsFailure({required this.message});

  @override
  List<Object?> get props => [message];
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\entities\report_entity.dart =====
import '../enums/report_status_enums.dart';
import '../helpers/format_date_time.dart';

class ReportEntity {
  final String reportId;
  final String title;
  final String description;
  final String userId;
  final List<String> mediaUrls;
  final DateTime createdAt;
  final String? address;
  final DateTime updatedAt;
  final ReportStatusEnum status;

  final String? adminComment;
  ReportEntity({
    required this.reportId,

    required this.title,
    required this.userId,
    required this.description,
    required this.mediaUrls,
    required this.createdAt,
    this.address,
    required this.updatedAt,
    this.status = ReportStatusEnum.pending,
    this.adminComment,
  });

  factory ReportEntity.fromJson(Map<String, dynamic> json) {
    return ReportEntity(
      reportId: json['reportId'],
      title: json['title'],
      userId: json['userId'],
      description: json['description'],
      mediaUrls: List<String>.from(json['mediaUrls']),
      createdAt: parseDateTime(json['createdAt']),
      address: json['address'],
      updatedAt: parseDateTime(json['updatedAt']),
      status: ReportStatusEnum.values.firstWhere(
        (e) => e.name == json['status'],
        orElse: () => ReportStatusEnum.pending,
      ),
      adminComment: json['adminComment'],
    );
  }

  /// Copy with method for updating fields
  ReportEntity copyWith({
    String? reportId,
    String? title,
    String? description,
    String? userId,
    List<String>? mediaUrls,
    DateTime? createdAt,
    String? address,
    DateTime? updatedAt,
    ReportStatusEnum? status,
    String? adminComment,
  }) {
    return ReportEntity(
      reportId: reportId ?? this.reportId,
      title: title ?? this.title,
      description: description ?? this.description,
      userId: userId ?? this.userId,
      mediaUrls: mediaUrls ?? this.mediaUrls,
      createdAt: createdAt ?? this.createdAt,
      address: address ?? this.address,
      updatedAt: updatedAt ?? this.updatedAt,
      status: status ?? this.status,
      adminComment: adminComment ?? this.adminComment,
    );
  }

  /// Get status display name in Arabic
  String get statusDisplayName {
    switch (status) {
      case ReportStatusEnum.pending:
        return 'ظ‚ظٹط¯ ط§ظ„ظ…ط±ط§ط¬ط¹ط©';
      case ReportStatusEnum.inReview:
        return 'طھط­طھ ط§ظ„ظ…ط±ط§ط¬ط¹ط©';
      case ReportStatusEnum.investigating:
        return 'ط¬ط§ط±ظٹ ط§ظ„طھط­ظ‚ظٹظ‚';
      case ReportStatusEnum.resolved:
        return 'طھظ… ط§ظ„ط­ظ„';
      case ReportStatusEnum.rejected:
        return 'ظ…ط±ظپظˆط¶';
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\enums\report_status_enums.dart =====
enum ReportStatusEnum {
  pending, // ط§ظ„ط¨ظ„ط§ط؛ ظ„ط³ظ‡ ظ…طھط³ط¬ظ„ ظˆط¬ط§ط±ظٹ ظ…ط±ط§ط¬ط¹طھظ‡
  inReview, // ط§ظ„ظ…ط³ط¤ظˆظ„ ط¨ط¯ط£ ظٹط±ط§ط¬ط¹ ط§ظ„ط¨ظ„ط§ط؛
  investigating, // ط¬ط§ط±ظٹ ط§ظ„طھط­ظ‚ظٹظ‚ ظپط¹ظ„ط§ظ‹ (ط§ظ„ط¨ظ„ط§ط؛ ط§طھط­ظˆظ„ ظ„ط¬ظ‡ط© طھظ†ظپظٹط°ظٹط©)
  resolved, // طھظ… ط§ظ„طھط¹ط§ظ…ظ„ ظ…ط¹ ط§ظ„ط¨ظ„ط§ط؛ (طھظ… ط§ظ„ط­ظ„)
  rejected, // طھظ… ط±ظپط¶ ط§ظ„ط¨ظ„ط§ط؛ (ط¨ظ„ط§ط؛ ظƒط§ط°ط¨ ط£ظˆ ط؛ظٹط± ظƒط§ظپظٹ)
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\errors\exceptions.dart =====
class CustomException implements Exception {
  final String message;

  CustomException({required this.message});
  @override
  String toString() {
    return message;
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\errors\failures.dart =====
abstract class Failure {
  final String message;

  Failure(this.message);
}

class ServerFailure extends Failure {
  ServerFailure(super.message);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\helpers\build_app_bar.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:flutter/material.dart';

AppBar buildAppBar({required String title, Gradient? gradient}) {
  return AppBar(
    backgroundColor: gradient != null ? Colors.transparent : AppTheme.white,
    flexibleSpace: gradient != null
        ? Container(decoration: BoxDecoration(gradient: gradient))
        : null,
    title: Text(
      title,
      style: TextStyle(
        color: gradient != null ? Colors.white : AppTheme.primaryColor,
        fontWeight: FontWeight.bold,
        fontSize: 24,
      ),
    ),
    centerTitle: true,
    iconTheme: IconThemeData(
      color: gradient != null ? Colors.white : AppTheme.primaryColor,
    ),
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\helpers\build_snack_bar.dart =====
import 'package:flutter/material.dart';
import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';

void buildSnackBar({
  required BuildContext context,
  required String title,
  required String message,
  required ContentType contentType,
}) {
  final snackBar = SnackBar(
    elevation: 0,
    behavior: SnackBarBehavior.floating,
    backgroundColor: Colors.transparent,
    content: AwesomeSnackbarContent(
      title: title,
      message: message,
      contentType: contentType,
    ),
  );

  ScaffoldMessenger.of(context)
    ..hideCurrentSnackBar()
    ..showSnackBar(snackBar);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\helpers\format_date_time.dart =====
import 'package:intl/intl.dart';
import 'package:cloud_firestore/cloud_firestore.dart';


DateTime parseDateTime(dynamic dateValue) {
  if (dateValue is Timestamp) {
    return dateValue.toDate();
  } else if (dateValue is String) {
    return DateTime.parse(dateValue);
  } else if (dateValue is DateTime) {
    return dateValue;
  } else {
    return DateTime.now(); 
  }
}

String formatDateTime(DateTime dateTime) {
  final now = DateTime.now();
  final difference = now.difference(dateTime);
  final timeFormatter = DateFormat('hh:mm a');
  final dateFormatter = DateFormat('dd/MM/yyyy');

  final timeStr = timeFormatter.format(dateTime);
  final dateStr = dateFormatter.format(dateTime);

  if (difference.inMinutes < 1) {
    return '$timeStr â€¢ ط§ظ„ط¢ظ†';
  } else if (difference.inMinutes < 60) {
    return '$timeStr â€¢ ظ…ظ†ط° ${difference.inMinutes} ط¯ظ‚ظٹظ‚ط©';
  } else if (difference.inHours < 24) {
    return '$timeStr â€¢ ظ…ظ†ط° ${difference.inHours} ط³ط§ط¹ط©';
  } else if (difference.inDays < 7) {
    return '$timeStr $dateStr â€¢ ظ…ظ†ط° ${difference.inDays} ظٹظˆظ…';
  } else {
    return '$timeStr â€¢ $dateStr';
  }
}

String formatDateForDetails(DateTime date) {
  return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\helpers\get_user.dart =====
import 'dart:convert';
import 'package:depi_project/contants.dart';
import '../../features/auth/data/models/user_model.dart';
import '../../features/auth/domain/entities/user_entity.dart';
import '../utils/shared_preferences_singleton.dart';

/// Gets the current logged-in user data from SharedPreferences.
///
/// Usage examples in Text widgets:
/// // Get the full user object
/// final user = getUser();
///
/// // Access individual fields:
/// Text('${user.firstName} ${user.lastName}')  // Display full name
/// Text('${user.email}')                       // Display email
/// Text('${user.phoneNumber}')                 // Display phone number
/// Text('${user.nationalId}')                  // Display national ID
/// Text('${user.uId}')                        // Display user ID
///
/// // Example with conditional rendering:
/// Text(
///   'ظ…ط±ط­ط¨ط§ظ‹ ${getUser().firstName}',
///   style: TextStyle(fontSize: 18),
/// )
///
/// // Example in a profile screen:
/// ListTile(
///   title: Text('ط§ظ„ط§ط³ظ…'),
///   subtitle: Text('${getUser().firstName} ${getUser().lastName}'),
/// )
/// ```
///
/// Note: Wrap usage in try-catch as this throws if no user is logged in:
/// try {
///   final user = getUser();
///   return Text(user.firstName);
/// } catch (e) {
///   return Text('ط¨ط±ط¬ط§ط، طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„');
/// }
/// ```
UserEntity getUser() {
  var jsonString = SharedPreferencesSingleton.getString(kUserData);

  if (jsonString == null || jsonString.isEmpty) {
    throw Exception('No user data found in SharedPreferences');
  }

  var userEntity = UserModel.fromJson(jsonDecode(jsonString));
  return userEntity;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\helpers\media_helpers.dart =====
bool isVideoUrl(String url) {
  return url.contains('/video/');
}

String getVideoThumbnailUrl(String videoUrl) {
  String thumbnailUrl = videoUrl.replaceFirst(
    '/video/upload/',
    '/video/upload/so_0/',
  );

  thumbnailUrl = thumbnailUrl.replaceAll(
    RegExp(r'\.(mp4|mov|avi|mkv|flv|wmv)$'),
    '.jpg',
  );

  return thumbnailUrl;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\helpers\media_manager.dart =====
import 'dart:io';

import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';

import 'build_snack_bar.dart';

class MediaManager {
  final ImagePicker picker = ImagePicker();
  final List<File> _selectedMedia = [];

  List<File> get selectedMedia => _selectedMedia;

  /// Pick multiple images from gallery
  Future<void> pickImages(BuildContext context) async {
    try {
      final List<XFile> images = await picker.pickMultiImage();
      if (images.isNotEmpty) {
        _selectedMedia.addAll(images.map((xFile) => File(xFile.path)));
      }
    } catch (e) {
      buildSnackBar(
        title: 'ط®ط·ط£',
        message: 'ظپط´ظ„ ظپظٹ ط§ط®طھظٹط§ط± ط§ظ„طµظˆط±',
        contentType: ContentType.failure,
        context: context,
      );
    }
  }

  /// Pick single video from gallery
  Future<void> pickVideo(BuildContext context) async {
    try {
      final XFile? video = await picker.pickVideo(source: ImageSource.gallery);
      if (video != null) {
        _selectedMedia.add(File(video.path));
      }
    } catch (e) {
      buildSnackBar(
        context: context,
        title: 'ط®ط·ط£',
        message: 'ظپط´ظ„ ظپظٹ ط§ط®طھظٹط§ط± ط§ظ„ظپظٹط¯ظٹظˆ',
        contentType: ContentType.failure,
      );
    }
  }

  /// Remove media at specific index
  void removeMedia(int index) {
    if (index >= 0 && index < _selectedMedia.length) {
      _selectedMedia.removeAt(index);
    }
  }

  /// Clear all selected media
  void clearAll() {
    _selectedMedia.clear();
  }

  bool isVideoFile(File file) {
    final extension = file.path.toLowerCase().split('.').last;
    return [
      'mp4',
      'mov',
      'avi',
      'mkv',
      'webm',
      'flv',
      'm4v',
    ].contains(extension);
  }

  /// Check if media list is empty
  bool get isEmpty => _selectedMedia.isEmpty;

  /// Check if media list is not empty
  bool get isNotEmpty => _selectedMedia.isNotEmpty;

  /// Get media count
  int get length => _selectedMedia.length;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\helpers\on_generate_routes.dart =====
import 'package:depi_project/features/add_report/presentation/views/add_report_view.dart';
import 'package:depi_project/features/emergency_numbers/presentation/views/emergency_numbers_body.dart';
import 'package:depi_project/features/splash/presentation/views/splash_view.dart';
import 'package:flutter/material.dart';

import '../../features/auth/presentation/views/reset_password_view.dart';
import '../../features/auth/presentation/views/signin_view.dart';
import '../../features/auth/presentation/views/signup_view.dart';

Route<dynamic> onGenerateRoute(RouteSettings settings) {
  switch (settings.name) {
    case SigninView.routeName:
      return MaterialPageRoute(builder: (context) => const SigninView());

    case SplashScreen.routeName:
      return MaterialPageRoute(builder: (context) => const SplashScreen());

    case SignupView.routeName:
      return MaterialPageRoute(builder: (context) => const SignupView());

    case ResetPasswordView.routeName:
      return MaterialPageRoute(builder: (context) => const ResetPasswordView());

    case AddReportView.routeName:
      return MaterialPageRoute(builder: (context) => const AddReportView());

    case EmergencyNumbersBody.routeName:
      return MaterialPageRoute(
        builder: (context) => const EmergencyNumbersBody(),
      );

    default:
      return MaterialPageRoute(builder: (context) => const Scaffold());
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\helpers\report_status_helper.dart =====
import 'package:flutter/material.dart';

import '../enums/report_status_enums.dart';

Color getStatusColor(ReportStatusEnum status) {
  switch (status) {
    case ReportStatusEnum.pending:
      return Colors.orange;
    case ReportStatusEnum.inReview:
      return Colors.blue;
    case ReportStatusEnum.investigating:
      return Colors.purple;
    case ReportStatusEnum.resolved:
      return Colors.green;
    case ReportStatusEnum.rejected:
      return Colors.red;
  }
}

String getStatusText(ReportStatusEnum status) {
  switch (status) {
    case ReportStatusEnum.pending:
      return 'ظ‚ظٹط¯ ط§ظ„ط§ظ†طھط¸ط§ط±';
    case ReportStatusEnum.inReview:
      return 'ظ‚ظٹط¯ ط§ظ„ظ…ط±ط§ط¬ط¹ط©';
    case ReportStatusEnum.investigating:
      return 'ظ‚ظٹط¯ ط§ظ„طھط­ظ‚ظٹظ‚';
    case ReportStatusEnum.resolved:
      return 'طھظ… ط§ظ„ط­ظ„';
    case ReportStatusEnum.rejected:
      return 'ظ…ط±ظپظˆط¶';
  }
}

ReportStatusEnum statusFromString(String? statusString) {
  if (statusString == null) return ReportStatusEnum.pending;

  try {
    return ReportStatusEnum.values.firstWhere(
      (e) => e.name == statusString,
      orElse: () => ReportStatusEnum.pending,
    );
  } catch (e) {
    return ReportStatusEnum.pending;
  }
}

String statusToString(ReportStatusEnum status) {
  switch (status) {
    case ReportStatusEnum.pending:
      return 'pending';
    case ReportStatusEnum.inReview:
      return 'inReview';
    case ReportStatusEnum.investigating:
      return 'investigating';
    case ReportStatusEnum.resolved:
      return 'resolved';
    case ReportStatusEnum.rejected:
      return 'rejected';
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\models\report_model.dart =====
import 'dart:io';

import '../enums/report_status_enums.dart';
import '../entities/report_entity.dart';
import '../helpers/report_status_helper.dart';

class ReportModel extends ReportEntity {
  final List<File> mediaFiles;

  ReportModel({
    required super.reportId,

    required super.title,
    required super.userId,
    required super.description,
    required super.mediaUrls,
    required super.createdAt,
    super.address,
    required super.updatedAt,
    super.status = ReportStatusEnum.pending,
    super.adminComment,
    required this.mediaFiles,
  });

  /// Convert ReportModel to Map for Firestore
  Map<String, dynamic> toJson() {
    return {
      'reportId': reportId,
      'title': title,
      'description': description,
      'userId': userId,
      'mediaUrls': mediaUrls,
      'createdAt': createdAt.toIso8601String(),
      'address': address,
      'updatedAt': updatedAt.toIso8601String(),
      'status': status.name,
      'adminComment': adminComment,
    };
  }

  /// Create ReportModel from Firestore Map
  factory ReportModel.fromJson(Map<String, dynamic> map) {
    return ReportModel(
      reportId: map['reportId'] ?? '',
      title: map['title'] ?? '',
      description: map['description'] ?? '',
      userId: map['userId'] ?? '',
      mediaUrls: List<String>.from(map['mediaUrls'] ?? []),
      createdAt: DateTime.parse(map['createdAt']),
      address: map['address'],
      updatedAt: DateTime.parse(map['updatedAt']),
      status: statusFromString(map['status']),
      adminComment: map['adminComment'],
      mediaFiles: [],
    );
  }

  /// Create ReportModel from ReportEntity
  factory ReportModel.fromEntity(
    ReportEntity entity, {
    List<File>? mediaFiles,
  }) {
    return ReportModel(
      reportId: entity.reportId,
      title: entity.title,
      description: entity.description,
      userId: entity.userId,
      mediaUrls: entity.mediaUrls,
      createdAt: entity.createdAt,
      address: entity.address,
      updatedAt: entity.updatedAt,
      status: entity.status,
      adminComment: entity.adminComment,
      mediaFiles: mediaFiles ?? [],
    );
  }

  ReportEntity toEntity() {
    return ReportEntity(
      reportId: reportId,
      title: title,
      description: description,
      userId: userId,
      mediaUrls: mediaUrls,
      createdAt: createdAt,
      address: address,
      updatedAt: updatedAt,
      status: status,
      adminComment: adminComment,
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\repos\media_repo\media_repo.dart =====
import 'dart:io';

import 'package:dartz/dartz.dart';

import '../../errors/failures.dart';

abstract class MediaRepo {
  Future<Either<Failure, String>> uploadMedia(
    File file, {
    bool isVideo = false,
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\repos\media_repo\media_repo_impl.dart =====
import 'dart:developer';
import 'dart:io';

import 'package:dartz/dartz.dart';

import 'package:depi_project/core/errors/failures.dart';
import 'package:depi_project/core/services/storage_service.dart';
import 'package:depi_project/core/utils/backend_endpoint.dart';

import 'media_repo.dart';

class MediaRepoImpl implements MediaRepo {
  final StorageService storageService;

  MediaRepoImpl(this.storageService);

  @override
  Future<Either<Failure, String>> uploadMedia(
    File file, {
    bool isVideo = false,
  }) async {
    try {
      String url = await storageService.uploadFile(
        file,
        BackendEndpoint.uploadMedia,
        isVideo: isVideo,
      );
      return Right(url);
    } catch (e) {
      log('Error uploading media: $e');
      return Left(ServerFailure('Failed to upload media: $e'));
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\services\cloudinary_service.dart =====
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:uuid/uuid.dart';

import 'storage_service.dart';

class CloudinaryService implements StorageService {
  final String _cloudName;
  final String _uploadPreset;
  final String _apiKey;
  final Uuid _uuid;
  final Dio _dio;

  CloudinaryService({
    required String cloudName,
    required String uploadPreset,
    required String apiKey,
  }) : _cloudName = cloudName,
       _uploadPreset = uploadPreset,
       _apiKey = apiKey,
       _uuid = const Uuid(),
       _dio = Dio();

  @override
  Future<String> uploadFile(
    File file,
    String folderPath, {
    bool isVideo = false,
  }) async {
    try {
      final String uniqueId = _uuid.v4();
      final String publicId = '$folderPath/$uniqueId';

      final String resourceType = isVideo ? 'video' : 'image';
      final String url =
          'https://api.cloudinary.com/v1_1/$_cloudName/$resourceType/upload';

      FormData formData = FormData.fromMap({
        'file': await MultipartFile.fromFile(
          file.path,
          filename: file.path.split('/').last,
        ),
        'upload_preset': _uploadPreset,
        'public_id': publicId,
        'api_key': _apiKey,
      });

      final response = await _dio.post(url, data: formData);

      if (response.statusCode != 200) {
        throw Exception(
          'Cloudinary upload failed with status: ${response.statusCode}. Response: ${response.data}',
        );
      }

      final Map<String, dynamic> responseData = response.data;

      if (responseData.containsKey('error')) {
        throw Exception(
          'Cloudinary API Error: ${responseData['error']['message']}',
        );
      }

      final String? secureUrl = responseData['secure_url'];

      if (secureUrl != null && secureUrl.isNotEmpty) {
        return secureUrl;
      } else {
        throw Exception(
          'Upload successful but no valid secure_url found in response.',
        );
      }
    } on DioException catch (e) {
      String errorMessage = 'Network or API error during Cloudinary upload.';
      if (e.response != null) {
        errorMessage +=
            ' Status: ${e.response?.statusCode}. Data: ${e.response?.data}';
      } else {
        errorMessage += ' Message: ${e.message}';
      }
      throw Exception(errorMessage);
    } catch (e) {
      throw Exception(
        'An unexpected error occurred during Cloudinary upload: $e',
      );
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\services\custom_bloc_observer.dart =====
import 'dart:developer';

import 'package:flutter/foundation.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class CustomBlocObserver extends BlocObserver {
  @override
  void onChange(BlocBase bloc, Change change) {
    super.onChange(bloc, change);
    if (kDebugMode) {
      log('${bloc.runtimeType} $change');
    }
  }

  @override
  void onTransition(Bloc bloc, Transition transition) {
    // TODO: implement onTransition
    super.onTransition(bloc, transition);
    if (kDebugMode) {
      log('${bloc.runtimeType} $transition');
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\services\database_service.dart =====
abstract class DatabaseService {
  Future<void> addData({
    required String path,
    required Map<String, dynamic> data,
    String? documentId,
  });
  Future<dynamic> getData({
    required String path,
    String? documentId,
    Map<String, dynamic>? query,
  });
  Future<bool> checksIfDataExists({
    required String path,
    required String documentId,
  });
  Future<void> updateData({
    required String path,
    required Map<String, dynamic> data,
    required String documentId,
  });
  Future<void> deleteData({required String path, required String documentId});
  Stream<List<Map<String, dynamic>>> streamCollection({required String path});
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\services\firebase_auth_service.dart =====
import 'dart:developer';
import 'package:firebase_auth/firebase_auth.dart';

import '../errors/exceptions.dart';

class FirebaseAuthService {
  Future deleteUser() async {
    try {
      await FirebaseAuth.instance.currentUser!.delete();
    } catch (e) {
      log('Exception in FirebaseAuthService.deleteUser: ${e.toString()}');
      throw CustomException(
        message: 'ط­ط¯ط« ط®ط·ط£ ط£ط«ظ†ط§ط، ط­ط°ظپ ط§ظ„ط­ط³ط§ط¨. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
      );
    }
  }

  Future<User> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      final credential = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      return credential.user!;
    } on FirebaseAuthException catch (e) {
      if (e.code == 'user-not-found') {
        throw CustomException(
          message: 'ط§ظ„ط±ظ‚ظ… ط§ظ„ط³ط±ظٹ ط§ظˆ ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ط؛ظٹط± طµط­ظٹط­.',
        );
      } else if (e.code == 'wrong-password') {
        throw CustomException(
          message: 'ط§ظ„ط±ظ‚ظ… ط§ظ„ط³ط±ظٹ ط§ظˆ ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ط؛ظٹط± طµط­ظٹط­.',
        );
      } else if (e.code == 'network-request-failed') {
        throw CustomException(
          message: 'ظپط´ظ„ ط§ظ„ط§طھطµط§ظ„ ط¨ط§ظ„ط´ط¨ظƒط©. ط§ظ„ط±ط¬ط§ط، ط§ظ„طھط­ظ‚ظ‚ ظ…ظ† ط§طھطµط§ظ„ظƒ ط¨ط§ظ„ط¥ظ†طھط±ظ†طھ.',
        );
      } else {
        throw CustomException(
          message:
              'ظپط´ظ„ طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„. ط§ظ„ط±ط¬ط§ط، ط§ظ„طھط­ظ‚ظ‚ ظ…ظ† ط§ظ„ط¨ظٹط§ظ†ط§طھ ظˆط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
        );
      }
    } catch (e) {
      log(
        'Exeption in FirebaseAuthService.signInWithEmailAndPassword: ${e.toString()}',
      );
      throw CustomException(
        message:
            'ط­ط¯ط« ط®ط·ط£ ط؛ظٹط± ظ…ط¹ط±ظˆظپ ط£ط«ظ†ط§ط، طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
      );
    }
  }

  Future<User> createUserWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      final credential = await FirebaseAuth.instance
          .createUserWithEmailAndPassword(email: email, password: password);
      return credential.user!;
    } on FirebaseAuthException catch (e) {
      log(
        'Exeption in FirebaseAuthService.createUserWithEmailAndPassword: ${e.toString()}and code: ${e.code}',
      );
      if (e.code == 'weak-password') {
        throw CustomException(message: 'ط§ظ„ط±ظ‚ظ… ط§ظ„ط³ط±ظٹ ط¶ط¹ظٹظپ ط¬ط¯ط§ظ‹.');
      } else if (e.code == 'email-already-in-use') {
        throw CustomException(
          message: 'ظ„ظ‚ط¯ طھظ… ط§ط³طھط®ط¯ط§ظ… ظ‡ط°ط§ ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ط¨ط§ظ„ظپط¹ظ„.',
        );
      } else if (e.code == 'network-request-failed') {
        throw CustomException(
          message: 'ظپط´ظ„ ط§ظ„ط§طھطµط§ظ„ ط¨ط§ظ„ط´ط¨ظƒط©. ط§ظ„ط±ط¬ط§ط، ط§ظ„طھط­ظ‚ظ‚ ظ…ظ† ط§طھطµط§ظ„ظƒ ط¨ط§ظ„ط¥ظ†طھط±ظ†طھ.',
        );
      } else {
        throw CustomException(
          message: 'ظ„ظ… ظٹطھظ… ط¥ظ†ط´ط§ط، ط§ظ„ط­ط³ط§ط¨ ط¨ظ†ط¬ط§ط­. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
        );
      }
    } catch (e) {
      log(
        'Exeption in FirebaseAuthService.createUserWithEmailAndPassword: ${e.toString()}',
      );

      throw CustomException(
        message:
            'ط­ط¯ط« ط®ط·ط£ ط؛ظٹط± ظ…ط¹ط±ظˆظپ ط£ط«ظ†ط§ط، ط¥ظ†ط´ط§ط، ط§ظ„ط­ط³ط§ط¨. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
      );
    }
  }

  bool isUserLoggedIn() {
    return FirebaseAuth.instance.currentUser != null;
  }

  Future<void> signOut() async {
    try {
      await FirebaseAuth.instance.signOut();
    } catch (e) {
      log('Exception in FirebaseAuthService.signOut: ${e.toString()}');
      throw CustomException(
        message: 'ط­ط¯ط« ط®ط·ط£ ط£ط«ظ†ط§ط، طھط³ط¬ظٹظ„ ط§ظ„ط®ط±ظˆط¬. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
      );
    }
  }

  Future<void> sendPasswordResetEmail({required String email}) async {
    try {
      await FirebaseAuth.instance.sendPasswordResetEmail(email: email);
    } on FirebaseAuthException catch (e) {
      log('FirebaseAuthException in sendPasswordResetEmail: ${e.code}');
      if (e.code == 'user-not-found') {
        throw CustomException(
          message: 'ظ„ط§ ظٹظˆط¬ط¯ ط­ط³ط§ط¨ ظ…ط³ط¬ظ„ ط¨ظ‡ط°ط§ ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ.',
        );
      } else if (e.code == 'invalid-email') {
        throw CustomException(message: 'ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ط؛ظٹط± طµط§ظ„ط­.');
      } else if (e.code == 'network-request-failed') {
        throw CustomException(
          message: 'ظپط´ظ„ ط§ظ„ط§طھطµط§ظ„ ط¨ط§ظ„ط´ط¨ظƒط©. ط§ظ„ط±ط¬ط§ط، ط§ظ„طھط­ظ‚ظ‚ ظ…ظ† ط§طھطµط§ظ„ظƒ ط¨ط§ظ„ط¥ظ†طھط±ظ†طھ.',
        );
      } else {
        throw CustomException(
          message: 'ظپط´ظ„ ط¥ط±ط³ط§ظ„ ط±ط§ط¨ط· ط¥ط¹ط§ط¯ط© طھط¹ظٹظٹظ† ظƒظ„ظ…ط© ط§ظ„ظ…ط±ظˆط±.',
        );
      }
    } catch (e) {
      log('Exception in sendPasswordResetEmail: ${e.toString()}');
      throw CustomException(
        message: 'ط­ط¯ط« ط®ط·ط£ ط؛ظٹط± ظ…ط¹ط±ظˆظپ. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
      );
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\services\firestore_sevice.dart =====
// import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';

import 'database_service.dart';

class FireStoreService implements DatabaseService {
  FirebaseFirestore firestore = FirebaseFirestore.instance;
  @override
  Future<void> addData({
    required String path,
    required Map<String, dynamic> data,
    String? documentId,
  }) async {
    if (documentId != null) {
      firestore.collection(path).doc(documentId).set(data);
    } else {
      await firestore.collection(path).add(data);
    }
  }

  @override
  Future<dynamic> getData({
    required String path,
    String? documentId,
    Map<String, dynamic>? query,
  }) async {
    if (documentId != null) {
      var data = await firestore.collection(path).doc(documentId).get();
      return data.data();
    } else {
      Query<Map<String, dynamic>> data = firestore.collection(path);

      var result = await data.get();
      return result.docs.map((e) => e.data()).toList();
    }
  }

  @override
  Future<bool> checksIfDataExists({
    required String path,
    required String documentId,
  }) async {
    var data = await firestore.collection(path).doc(documentId).get();
    return data.exists;
  }

  @override
  Future<void> deleteData({
    required String path,
    required String documentId,
  }) async {
    await firestore.collection(path).doc(documentId).delete();
  }

  @override
  Stream<List<Map<String, dynamic>>> streamCollection({required String path}) {
    return firestore
        .collection(path)
        .snapshots()
        .map(
          (snapshot) => snapshot.docs
              .map((doc) => {...doc.data(), 'id': doc.id})
              .toList(),
        );
  }

  @override
  Future<void> updateData({
    required String path,
    required Map<String, dynamic> data,
    required String documentId,
  }) {
    return firestore.collection(path).doc(documentId).update(data);
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\services\get_it_service.dart =====
import 'package:depi_project/core/repos/media_repo/media_repo.dart';
import 'package:depi_project/core/repos/media_repo/media_repo_impl.dart';
import 'package:depi_project/features/add_report/data/repos/add_report_repo_impl.dart';
import 'package:depi_project/features/notifications/data/repos/notifications_repo_impl.dart';
import 'package:depi_project/features/notifications/domain/repos/notifications_repo.dart';

import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:get_it/get_it.dart';

import '../../features/add_report/domain/repos/add_report_repo.dart';
import '../../features/auth/data/repos/auth_repo_impl.dart';
import '../../features/auth/domain/repos/auth_repo.dart';
import 'cloudinary_service.dart';
import 'database_service.dart';
import 'firebase_auth_service.dart';
import 'firestore_sevice.dart';
import 'storage_service.dart';

final getIt = GetIt.instance;

void setupGetit() {
  getIt.registerSingleton<DatabaseService>(FireStoreService());

  getIt.registerSingleton<FirebaseAuthService>(FirebaseAuthService());

  getIt.registerSingleton<AuthRepo>(
    AuthRepoImplementation(
      firebaseAuthService: getIt<FirebaseAuthService>(),
      databaseService: getIt<DatabaseService>(),
    ),
  );
  getIt.registerSingleton<StorageService>(
    CloudinaryService(
      cloudName: dotenv.env['CLOUDINARY_CLOUD_NAME']!,
      uploadPreset: dotenv.env['CLOUDINARY_UPLOAD_PRESET']!,
      apiKey: dotenv.env['CLOUDINARY_API_KEY']!,
    ),
  );
  getIt.registerSingleton<MediaRepo>(
    MediaRepoImpl(getIt.get<StorageService>()),
  );
  getIt.registerSingleton<AddReportRepo>(
    AddReportRepoImpl(getIt.get<DatabaseService>()),
  );
  getIt.registerSingleton<NotificationsRepo>(
    NotificationsRepoImpl(getIt.get<DatabaseService>()),
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\services\storage_service.dart =====
import 'dart:io';

abstract class StorageService {
  Future<String> uploadFile(File file, String path, {bool isVideo = false});
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\utils\backend_endpoint.dart =====
class BackendEndpoint {
  static const addUserData = 'users';
  static const getUserData = 'users';
  static const isUserExists = 'users';
  static const uploadMedia = 'reports';
  static const addReports = 'reports';
  static const getNotifications = 'notifications';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\utils\shared_preferences_singleton.dart =====
import 'package:shared_preferences/shared_preferences.dart';

class SharedPreferencesSingleton {
  static late SharedPreferences _instance;
  static Future<void> init() async {
    _instance = await SharedPreferences.getInstance();
  }

  static setBool(String key, bool value) {
    _instance.setBool(key, value);
  }

  static getBool(String key) {
    return _instance.getBool(key) ?? false;
  }

  static setString(String key, String value) async {
    await _instance.setString(key, value);
  }

  static getString(String key) {
    return _instance.getString(key) ?? "";
  }

  static Future<void> setStringList(String key, List<String> value) async {
    await _instance.setStringList(key, value);
  }

  static List<String> getStringList(String key) {
    return _instance.getStringList(key) ?? <String>[];
  }

  static Future<bool> remove(String key) async {
    return await _instance.remove(key);
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\widgets\custom_button.dart =====
import 'package:flutter/material.dart';

class CustomButton extends StatelessWidget {
  const CustomButton({
    super.key,
    this.onPressed,
    required this.text,
    this.backgroundColor,
    this.gradientColors,
    this.textColor = Colors.white,
    this.fontSize = 18,
    this.fontWeight = FontWeight.w600,
    this.height = 54,
    this.borderRadius = 999,
    this.hasShadow = true,
    this.shadowColor,
    this.borderColor,
    this.borderWidth,
  });

  final VoidCallback? onPressed;
  final String text;
  final Color? backgroundColor;
  final List<Color>? gradientColors;
  final Color textColor;
  final double fontSize;
  final FontWeight fontWeight;
  final double height;
  final double borderRadius;
  final bool hasShadow;
  final Color? shadowColor;
  final Color? borderColor;
  final double? borderWidth;

  @override
  Widget build(BuildContext context) {
    return Container(
      height: height,
      width: double.infinity,
      decoration: BoxDecoration(
        gradient: gradientColors != null
            ? LinearGradient(
                colors: gradientColors!,
                begin: Alignment.centerLeft,
                end: Alignment.centerRight,
              )
            : null,
        color: backgroundColor,
        borderRadius: BorderRadius.circular(borderRadius),
        border: borderColor != null && borderWidth != null
            ? Border.all(color: borderColor!, width: borderWidth!)
            : null,
        boxShadow: hasShadow
            ? [
                BoxShadow(
                  color: (shadowColor ?? backgroundColor ?? Colors.grey)
                      .withOpacity(0.3),
                  blurRadius: 25,
                  offset: const Offset(0, 20),
                  spreadRadius: 10,
                ),
                BoxShadow(
                  color: (shadowColor ?? backgroundColor ?? Colors.grey)
                      .withOpacity(0.2),
                  blurRadius: 30,
                  offset: const Offset(0, 50),
                  spreadRadius: -60,
                ),
              ]
            : null,
      ),
      child: TextButton(
        style: TextButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(borderRadius),
          ),
          backgroundColor: Colors.transparent,
          padding: EdgeInsets.zero,
        ),
        onPressed: onPressed,
        child: Text(
          text,
          style: TextStyle(
            color: textColor,
            fontSize: fontSize,
            fontWeight: fontWeight,
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\widgets\custom_password_field.dart =====
import 'package:flutter/material.dart';

import 'custom_text_field.dart';

class CustomPasswordField extends StatefulWidget {
  const CustomPasswordField({super.key, this.onSaved});
  final void Function(String?)? onSaved;

  @override
  State<CustomPasswordField> createState() => _CustomPasswordFieldState();
}

class _CustomPasswordFieldState extends State<CustomPasswordField> {
  bool isObscured = true;
  @override
  Widget build(BuildContext context) {
    return CustomTextField(
      validator: (value) {
        if (value == null || value.isEmpty) {
          return 'ط¨ط±ط¬ط§ط، ط¥ط¯ط®ط§ظ„ ظƒظ„ظ…ط© ط§ظ„ظ…ط±ظˆط±';
        }
        return null;
      },
      labelText: 'ظƒظ„ظ…ط© ط§ظ„ظ…ط±ظˆط± ',
      hintText: '********',
      keyboardType: TextInputType.visiblePassword,
      obscureText: isObscured,
      onSaved: (value) {
        widget.onSaved!(value);
      },
      suffixIcon: GestureDetector(
        onTap: () {
          setState(() {
            isObscured = !isObscured;
          });
        },
        child: isObscured
            ? const Icon(Icons.remove_red_eye, color: Color(0xffc9cecf))
            : const Icon(Icons.visibility_off, color: Color(0xffc9cecf)),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\widgets\custom_text_field.dart =====
import 'dart:ui';

import 'package:flutter/material.dart';

class CustomTextField extends StatelessWidget {
  const CustomTextField({
    super.key,
    required this.labelText,
    required this.hintText,
    this.keyboardType,
    required this.obscureText,
    this.suffixIcon,
    this.onSaved,
    this.validator,
    this.maxLines = 1,
  });
  final String labelText;
  final String hintText;
  final TextInputType? keyboardType;
  final bool obscureText;
  final Widget? suffixIcon;
  final void Function(String?)? onSaved;
  final String? Function(String?)? validator;
  final int maxLines;
  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Text(labelText),
        const SizedBox(height: 8),
        ClipRRect(
          borderRadius: BorderRadius.circular(12),
          child: Stack(
            children: [
              BackdropFilter(
                filter: ImageFilter.blur(sigmaX: 6.0, sigmaY: 6.0),
                child: Container(
                  constraints: BoxConstraints(
                    minHeight: maxLines == 1 ? 55 : 55.0 * maxLines,
                  ),
                  decoration: BoxDecoration(
                    // color: const Color.fromARGB(
                    //   255,
                    //   172,
                    //   170,
                    //   170,
                    // ).withOpacity(0.15),
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: const Color.fromARGB(
                        255,
                        13,
                        13,
                        13,
                      ).withOpacity(0.12),
                    ),
                  ),
                ),
              ),
              TextFormField(
                validator:
                    validator ??
                    (value) {
                      if (value == null || value.isEmpty) {
                        return 'ظ‡ط°ط§ ط§ظ„ط­ظ‚ظ„ ظ…ط·ظ„ظˆط¨';
                      }
                      return null;
                    },
                onSaved: onSaved,
                keyboardType: keyboardType,
                obscureText: obscureText,
                maxLines: maxLines,
                style: const TextStyle(color: Color.fromARGB(255, 3, 3, 3)),
                decoration: InputDecoration(
                  suffixIcon: suffixIcon,
                  hintText: hintText,
                  hintStyle: TextStyle(
                    color: const Color.fromARGB(
                      255,
                      13,
                      13,
                      13,
                    ).withOpacity(0.7),
                  ),
                  border: InputBorder.none,
                  contentPadding: const EdgeInsets.symmetric(
                    vertical: 16,
                    horizontal: 12,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\core\widgets\notification_badge_icon.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:flutter/material.dart';

class NotificationBadgeIcon extends StatelessWidget {
  const NotificationBadgeIcon({super.key, required this.count});

  final int count;

  @override
  Widget build(BuildContext context) {
    final displayCount = count > 99 ? '99+' : '$count';

    return Stack(
      clipBehavior: Clip.none,
      children: [
        const Icon(Icons.notifications),
        if (count > 0)
          Positioned(
            right: -6,
            top: -6,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: AppTheme.primaryColor,
                borderRadius: BorderRadius.circular(24),
              ),
              constraints: const BoxConstraints(minWidth: 16, minHeight: 16),
              child: Text(
                displayCount,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\data\repos\add_report_repo_impl.dart =====
import 'package:dartz/dartz.dart';

import 'package:depi_project/core/entities/report_entity.dart';

import 'package:depi_project/core/errors/failures.dart';
import 'package:depi_project/core/models/report_model.dart';

import '../../../../core/services/database_service.dart';
import '../../../../core/utils/backend_endpoint.dart';
import '../../domain/repos/add_report_repo.dart';

class AddReportRepoImpl implements AddReportRepo {
  final DatabaseService databaseService;

  AddReportRepoImpl(this.databaseService);

  @override
  Future<Either<Failure, void>> addReport(ReportEntity report) async {
    try {
      await databaseService.addData(
        documentId: report.reportId,
        path: BackendEndpoint.addReports,
        data: ReportModel.fromEntity(report).toJson(),
      );
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure('Failed to add report: $e'));
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\domain\repos\add_report_repo.dart =====
import 'package:dartz/dartz.dart';
import 'package:depi_project/core/entities/report_entity.dart';

import '../../../../core/errors/failures.dart';

abstract class AddReportRepo {
  Future<Either<Failure, void>> addReport(ReportEntity report);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\manager\cubits\add_report_cubit\add_report_cubit.dart =====
import 'dart:developer';
import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:depi_project/core/entities/report_entity.dart';
import 'package:depi_project/core/helpers/media_manager.dart';
import 'package:depi_project/core/repos/media_repo/media_repo.dart';
import 'package:depi_project/features/add_report/domain/repos/add_report_repo.dart';
import 'package:meta/meta.dart';

part 'add_report_state.dart';

class AddReportCubit extends Cubit<AddReportState> {
  AddReportCubit(this.mediaRepo, this.addReportRepo)
    : super(AddReportInitial());
  final MediaRepo mediaRepo;
  final AddReportRepo addReportRepo;
  final MediaManager mediaManager = MediaManager();

  Future<void> addReport(ReportEntity report, List<File> mediaFiles) async {
    emit(AddReportLoading());
    try {
      List<String> uploadedUrls = [];
      for (var file in mediaFiles) {
        final isVideo = mediaManager.isVideoFile(file);
        var result = await mediaRepo.uploadMedia(file, isVideo: isVideo);
        await result.fold(
          (failure) async {
            emit(AddReportFailure(failure.message));
            throw Exception(failure.message);
          },
          (url) async {
            uploadedUrls.add(url);
          },
        );
      }
      final reportWithUrls = report.copyWith(mediaUrls: uploadedUrls);
      var addResult = await addReportRepo.addReport(reportWithUrls);
      addResult.fold(
        (failure) => emit(AddReportFailure(failure.message)),
        (_) => emit(AddReportSuccess()),
      );
    } catch (e) {
      log('message: Error adding report: $e');
      emit(AddReportFailure('ط­ط¯ط« ط®ط·ط£ ط£ط«ظ†ط§ط، ط¥ط¶ط§ظپط© ط§ظ„ط¨ظ„ط§ط؛: $e'));
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\manager\cubits\add_report_cubit\add_report_state.dart =====
part of 'add_report_cubit.dart';

@immutable
sealed class AddReportState {}

final class AddReportInitial extends AddReportState {}

final class AddReportLoading extends AddReportState {}

final class AddReportSuccess extends AddReportState {}

final class AddReportFailure extends AddReportState {
  final String error;

  AddReportFailure(this.error);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\views\widgets\add_report_view_body.dart =====
import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:uuid/uuid.dart';

import '../../../../../core/entities/report_entity.dart';
import '../../../../../core/helpers/build_snack_bar.dart';
import '../../../../../core/helpers/get_user.dart';
import '../../../../../core/helpers/media_manager.dart';
import '../../../../../core/widgets/custom_button.dart';
import '../../../../../core/widgets/custom_text_field.dart';
import '../../manager/cubits/add_report_cubit/add_report_cubit.dart';
import 'media_picker_section.dart';

class AddReportViewBody extends StatefulWidget {
  const AddReportViewBody({super.key});

  @override
  State<AddReportViewBody> createState() => _AddReportViewBodyState();
}

class _AddReportViewBodyState extends State<AddReportViewBody> {
  final GlobalKey<FormState> formKey = GlobalKey<FormState>();
  AutovalidateMode autovalidateMode = AutovalidateMode.disabled;
  final MediaManager mediaManager = MediaManager();

  late String title;
  late String description;
  String? address;

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24),
        child: Form(
          key: formKey,
          autovalidateMode: autovalidateMode,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: 16),
              // Title field
              CustomTextField(
                onSaved: (value) {
                  title = value!;
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return S.of(context).enterReportTitle;
                  } else if (value.length < 5) {
                    return S.of(context).reportTitleAtLeast5;
                  }
                  return null;
                },
                labelText: S.of(context).reporTitle,
                hintText: S.of(context).reportEx,
                obscureText: false,
                keyboardType: TextInputType.text,
              ),
              const SizedBox(height: 16),

              // Description field
              CustomTextField(
                onSaved: (value) {
                  description = value!;
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return S.of(context).enterReportDescribtion;
                  } else if (value.length < 10) {
                    return S.of(context).reportDescribtionAtLeast10;
                  }
                  return null;
                },
                labelText: S.of(context).reportDescribtion,
                hintText: S.of(context).writeReportDescribtion,
                obscureText: false,
                keyboardType: TextInputType.multiline,
                maxLines: 5,
              ),
              const SizedBox(height: 16),

              // Location field (optional)
              CustomTextField(
                onSaved: (value) {
                  address = value?.isEmpty == true ? null : value;
                },
                validator: (value) => null,
                labelText: S.of(context).location,
                hintText: S.of(context).locationEx,
                obscureText: false,
                keyboardType: TextInputType.text,
              ),
              const SizedBox(height: 24),

              // Media Section
              MediaPickerSection(
                mediaManager: mediaManager,
                onMediaChanged: () => setState(() {}),
              ),
              const SizedBox(height: 16),

              CustomButton(
                onPressed: () {
                  if (mediaManager.isNotEmpty) {
                    if (formKey.currentState!.validate()) {
                      formKey.currentState!.save();
                      final user = getUser();
                      ReportEntity reportEntity = ReportEntity(
                        reportId: const Uuid().v4(),
                        title: title,
                        description: description,
                        userId: user.uId,
                        mediaUrls: [],
                        createdAt: DateTime.now(),
                        updatedAt: DateTime.now(),
                        address: address,
                        adminComment: null,
                      );
                      context.read<AddReportCubit>().addReport(
                        reportEntity,
                        mediaManager.selectedMedia,
                      );
                    } else {
                      autovalidateMode = AutovalidateMode.always;
                      setState(() {});
                    }
                  } else {
                    buildSnackBar(
                      context: context,
                      title: S.of(context).alert,
                      message: S.of(context).mustAddMedia,
                      contentType: ContentType.warning,
                    );
                  }
                },
                text: S.of(context).sendingReport,
                // gradientColors: AppTheme.primaryGradientColors,
                // shadowColor: AppTheme.primaryShadowColor,
                backgroundColor: AppTheme.primaryColor,
                hasShadow: false,
              ),
              const SizedBox(height: 40),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\views\widgets\add_report_view_body_bloc_consumer.dart =====
import 'dart:developer';

import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';
import 'package:depi_project/core/helpers/build_snack_bar.dart';
import 'package:depi_project/features/add_report/presentation/manager/cubits/add_report_cubit/add_report_cubit.dart';
import 'package:depi_project/features/add_report/presentation/views/widgets/add_report_view_body.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:skeletonizer/skeletonizer.dart';

class AddReportViewBodyBlocBuilder extends StatelessWidget {
  const AddReportViewBodyBlocBuilder({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<AddReportCubit, AddReportState>(
      listener: (context, state) {
        if (state is AddReportFailure) {
          log(state.error);
          buildSnackBar(
            context: context,
            title: 'ط®ط·ط§',
            message: 'ظپط´ظ„ ظپظٹ ط§ط¶ط§ظپط© ط§ظ„ط¨ظ„ط§ط؛',
            contentType: ContentType.failure,
          );
        }
        if (state is AddReportSuccess) {
          Navigator.pop(context);
          buildSnackBar(
            context: context,

            title: 'ظ†ط¬ط§ط­',
            message: 'طھظ… ط§ط¶ط§ظپط© ط§ظ„ط¨ظ„ط§ط؛ ط¨ظ†ط¬ط§ط­',
            contentType: ContentType.success,
          );
        }
      },
      builder: (context, state) {
        return Skeletonizer(
          enabled: state is AddReportLoading,
          enableSwitchAnimation: true,
          child: const AddReportViewBody(),
        );
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\views\widgets\image_widget.dart =====
import 'dart:io';

import 'package:flutter/material.dart';

class ImageWidget extends StatelessWidget {
  const ImageWidget({super.key, required this.file});

  final File file;

  @override
  Widget build(BuildContext context) {
    return Image.file(
      file,
      fit: BoxFit.cover,
      width: double.infinity,
      height: double.infinity,
      errorBuilder: (context, error, stackTrace) {
        return Container(
          color: Colors.grey[300],
          child: const Center(child: Icon(Icons.error, color: Colors.red)),
        );
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\views\widgets\media_picker_section.dart =====
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';

import '../../../../../core/helpers/media_manager.dart';
import 'image_widget.dart';
import 'media_section_header.dart';
import 'video_thumbnail_widget.dart';

class MediaPickerSection extends StatelessWidget {
  const MediaPickerSection({
    super.key,
    required this.mediaManager,
    required this.onMediaChanged,
  });

  final MediaManager mediaManager;
  final VoidCallback onMediaChanged;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        MediaSectionHeader(
          mediaManager: mediaManager,
          onMediaChanged: onMediaChanged,
        ),
        const SizedBox(height: 12),

        if (mediaManager.isNotEmpty)
          GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: mediaManager.length,
            itemBuilder: (context, index) {
              final file = mediaManager.selectedMedia[index];
              final isVideo = mediaManager.isVideoFile(file);

              return Stack(
                children: [
                  ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: isVideo
                        ? VideoThumbnailWidget(file: file)
                        : ImageWidget(file: file),
                  ),
                  Positioned(
                    top: 4,
                    right: 4,
                    child: GestureDetector(
                      onTap: () {
                        mediaManager.removeMedia(index);
                        onMediaChanged();
                      },
                      child: Container(
                        padding: const EdgeInsets.all(4),
                        decoration: BoxDecoration(
                          color: Colors.red.withOpacity(0.8),
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.close,
                          color: Colors.white,
                          size: 16,
                        ),
                      ),
                    ),
                  ),
                ],
              );
            },
          )
        else
          Container(
            height: 150,
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey[300]!),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.add_photo_alternate_outlined,
                    size: 48,
                    color: Colors.grey[400],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    S.of(context).addPhotosAndVideos,
                    style: TextStyle(color: Colors.grey[600]),
                  ),
                ],
              ),
            ),
          ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\views\widgets\media_section_header.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/helpers/media_manager.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';

class MediaSectionHeader extends StatelessWidget {
  const MediaSectionHeader({
    super.key,
    required this.mediaManager,
    required this.onMediaChanged,
  });

  final MediaManager mediaManager;
  final VoidCallback onMediaChanged;

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          S.of(context).photosAndVideos,
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w600,
            color: Colors.black87,
          ),
          textAlign: TextAlign.start,
        ),
        Row(
          children: [
            IconButton(
              onPressed: () async {
                await mediaManager.pickImages(context);
                onMediaChanged();
              },
              icon: Icon(Icons.photo_library, color: AppTheme.primaryColor),
              tooltip: S.of(context).addingPhoto,
            ),
            IconButton(
              onPressed: () async {
                await mediaManager.pickVideo(context);
                onMediaChanged();
              },
              icon: Icon(Icons.videocam, color: AppTheme.primaryColor),
              tooltip:  S.of(context).addingVideo,
            ),
          ],
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\views\widgets\video_thumbnail_widget.dart =====
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:video_thumbnail/video_thumbnail.dart';

class VideoThumbnailWidget extends StatelessWidget {
  const VideoThumbnailWidget({super.key, required this.file});

  final File file;

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<String?>(
      future: VideoThumbnail.thumbnailFile(
        video: file.path,
        imageFormat: ImageFormat.PNG,
        maxWidth: 200,
        quality: 75,
      ),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.done &&
            snapshot.hasData &&
            snapshot.data != null) {
          return Stack(
            fit: StackFit.expand,
            children: [
              Image.file(File(snapshot.data!), fit: BoxFit.cover),
              Container(
                color: Colors.black26,
                child: const Center(
                  child: Icon(
                    Icons.play_circle_outline,
                    size: 48,
                    color: Colors.white,
                  ),
                ),
              ),
            ],
          );
        }
        return Container(
          color: Colors.black87,
          child: const Center(
            child: CircularProgressIndicator(color: Colors.white),
          ),
        );
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\add_report\presentation\views\add_report_view.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/helpers/build_app_bar.dart';
import 'package:depi_project/core/repos/media_repo/media_repo.dart';
import 'package:depi_project/features/add_report/domain/repos/add_report_repo.dart';
import 'package:depi_project/features/add_report/presentation/manager/cubits/add_report_cubit/add_report_cubit.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/services/get_it_service.dart';
import 'widgets/add_report_view_body_bloc_consumer.dart';

class AddReportView extends StatelessWidget {
  const AddReportView({super.key});
  static const routeName = 'add_report';
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: BlocProvider(
        create: (context) =>
            AddReportCubit(getIt.get<MediaRepo>(), getIt.get<AddReportRepo>()),
        child: const AddReportViewBodyBlocBuilder(),
      ),
      backgroundColor: AppTheme.white,
      appBar: buildAppBar(title: S.of(context).submitReport),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\data\models\user_model.dart =====
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/entities/user_entity.dart';

class UserModel extends UserEntity {
  UserModel({
    required super.firstName,
    required super.lastName,
    required super.email,
    required super.uId,
    required super.phoneNumber,
    required super.nationalId,
  });

  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      firstName: json['firstName'] ?? 'No First Name',
      lastName: json['lastName'] ?? 'No Last Name',
      email: json['email'] ?? 'No Email',
      uId: json['uId'] ?? 'No Uid',
      phoneNumber: json['phoneNumber'] ?? 'No Phone Number',
      nationalId: json['nationalId'] ?? 'No National ID',
    );
  }

  factory UserModel.fromEntity(UserEntity userEntity) {
    return UserModel(
      firstName: userEntity.firstName,
      lastName: userEntity.lastName,
      email: userEntity.email,
      uId: userEntity.uId,
      phoneNumber: userEntity.phoneNumber,
      nationalId: userEntity.nationalId,
    );
  }

  factory UserModel.fromFirebaseUser(User user) {
    return UserModel(
      firstName: user.displayName?.split(' ').first ?? 'No Name',
      lastName: (user.displayName?.split(' ').length ?? 0) > 1
          ? user.displayName!.split(' ').sublist(1).join(' ')
          : '',
      email: user.email ?? 'No Email',
      uId: user.uid,
      phoneNumber: 'No Phone Number',
      nationalId: 'No National ID',
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'firstName': firstName,
      'lastName': lastName,
      'email': email,
      'uId': uId,
      'phoneNumber': phoneNumber,
      'nationalId': nationalId,
    };
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\data\repos\auth_repo_impl.dart =====
import 'dart:convert';
import 'dart:developer';
import 'package:dartz/dartz.dart';
import 'package:firebase_auth/firebase_auth.dart';

import '../../../../contants.dart';
import '../../../../core/errors/exceptions.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/services/database_service.dart';
import '../../../../core/services/firebase_auth_service.dart';
import '../../../../core/utils/backend_endpoint.dart';
import '../../../../core/utils/shared_preferences_singleton.dart';
import '../../domain/entities/user_entity.dart';
import '../../domain/repos/auth_repo.dart';
import '../models/user_model.dart';

class AuthRepoImplementation extends AuthRepo {
  final FirebaseAuthService firebaseAuthService;
  final DatabaseService databaseService;

  AuthRepoImplementation({
    required this.databaseService,
    required this.firebaseAuthService,
  });

  @override
  Future<Either<Failure, UserEntity>> createUserWithEmailAndPassword(
    String email,
    String password,
    String firstName,
    String lastName,
    String phoneNumber,
    String nationalId,
  ) async {
    User? user;
    try {
      final exists = await databaseService.checksIfDataExists(
        path: BackendEndpoint.addUserData,
        documentId: nationalId,
      );

      if (exists) {
        return left(ServerFailure('ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ ظ…ط³ط¬ظ„ ط¨ط§ظ„ظپط¹ظ„.'));
      }

      user = await firebaseAuthService.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );

      final userEntity = UserEntity(
        firstName: firstName,
        lastName: lastName,
        email: email,
        uId: user.uid,
        phoneNumber: phoneNumber,
        nationalId: nationalId,
      );

      await saveUserData(user: userEntity);
      await addUserData(user: userEntity);

      final storedUser = await getUserData(nationalId: nationalId);
      return right(storedUser);
    } on CustomException catch (e) {
      await deleteUser(user);
      return left(ServerFailure(e.message));
    } catch (e) {
      await deleteUser(user);
      log('Exception in createUserWithEmailAndPassword: $e');
      return left(
        ServerFailure(
          'ط­ط¯ط« ط®ط·ط£ ط؛ظٹط± ظ…ط¹ط±ظˆظپ ط£ط«ظ†ط§ط، ط¥ظ†ط´ط§ط، ط§ظ„ط­ط³ط§ط¨. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
        ),
      );
    }
  }

  Future<void> deleteUser(User? user) async {
    if (user != null) {
      await firebaseAuthService.deleteUser();
    }
  }

  @override
  Future addUserData({required UserEntity user}) async {
    await databaseService.addData(
      path: BackendEndpoint.addUserData,
      data: UserModel.fromEntity(user).toMap(),
      documentId: user.nationalId,
    );
  }

  @override
  Future<UserEntity> getUserData({required String nationalId}) async {
    final userData = await databaseService.getData(
      path: BackendEndpoint.getUserData,
      documentId: nationalId,
    );
    return UserModel.fromJson(userData);
  }

  @override
  Future<bool> isNationalIdRegistered(String nationalId) async {
    try {
      return await databaseService.checksIfDataExists(
        path: BackendEndpoint.getUserData,
        documentId: nationalId,
      );
    } catch (e) {
      log('Error checking National ID: $e');
      return false;
    }
  }

  @override
  Future saveUserData({required UserEntity user}) async {
    final jsonData = jsonEncode(UserModel.fromEntity(user).toMap());
    await SharedPreferencesSingleton.setString(kUserData, jsonData);
    SharedPreferencesSingleton.setBool(isLoggedIn, true);
  }

  Future<String> getEmailByNationalId(String nationalId) async {
    try {
      final users = await databaseService.getData(
        path: BackendEndpoint.getUserData,
      );

      if (users is List) {
        for (final userData in users) {
          if (userData is Map<String, dynamic>) {
            final nid = userData['nationalId'];
            if (nid != null && nid.toString() == nationalId) {
              final email = userData['email'];
              if (email != null && email is String) {
                return email;
              }
            }
          }
        }
      }

      throw CustomException(
        message: 'ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ ط؛ظٹط± ظ…ط³ط¬ظ„. ط§ظ„ط±ط¬ط§ط، ط§ظ„طھط­ظ‚ظ‚ ظ…ظ† ط§ظ„ط¨ظٹط§ظ†ط§طھ.',
      );
    } catch (e) {
      if (e is CustomException) rethrow;
      throw CustomException(
        message: 'ط­ط¯ط« ط®ط·ط£ ط£ط«ظ†ط§ط، ط§ظ„ط¨ط­ط« ط¹ظ† ط§ظ„ط¨ظٹط§ظ†ط§طھ. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
      );
    }
  }

  Future<String> getNationalIdByEmail(String email) async {
    try {
      final users = await databaseService.getData(
        path: BackendEndpoint.getUserData,
      );

      if (users is List) {
        for (final userData in users) {
          if (userData is Map<String, dynamic>) {
            final mail = userData['email'];
            if (mail != null && mail == email) {
              return userData['nationalId'];
            }
          }
        }
      }

      throw CustomException(
        message: 'ظ„ظ… ظٹطھظ… ط§ظ„ط¹ط«ظˆط± ط¹ظ„ظ‰ ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ ظ„ظ‡ط°ط§ ط§ظ„ط¥ظٹظ…ظٹظ„.',
      );
    } catch (e) {
      if (e is CustomException) rethrow;
      throw CustomException(message: 'ط­ط¯ط« ط®ط·ط£ ط£ط«ظ†ط§ط، ط§ط³طھط±ط¬ط§ط¹ ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ.');
    }
  }

  @override
  Future<Either<Failure, UserEntity>> signInWithEmailOrNationalId(
    String emailOrNationalId,
    String password,
  ) async {
    try {
      String email;

      if (RegExp(r'^\d+$').hasMatch(emailOrNationalId)) {
        email = await getEmailByNationalId(emailOrNationalId);
      } else {
        email = emailOrNationalId;
      }

      final user = await firebaseAuthService.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      final nationalId = await getNationalIdByEmail(email);
      final userEntity = await getUserData(nationalId: nationalId);

      await saveUserData(user: userEntity);

      return right(userEntity);
    } on CustomException catch (e) {
      return left(ServerFailure(e.message));
    } catch (e) {
      log('Exception in signInWithEmailOrNationalId: ${e.toString()}');
      return left(
        ServerFailure(
          'ط­ط¯ط« ط®ط·ط£ ط؛ظٹط± ظ…ط¹ط±ظˆظپ ط£ط«ظ†ط§ط، طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.',
        ),
      );
    }
  }

  @override
  Future<Either<Failure, void>> resetPassword(String emailOrNationalId) async {
    try {
      String email;

      // Check if input is national ID or email
      if (RegExp(r'^\d+$').hasMatch(emailOrNationalId)) {
        // It's a national ID, get the email
        email = await getEmailByNationalId(emailOrNationalId);
      } else {
        // It's already an email
        email = emailOrNationalId;
      }

      await firebaseAuthService.sendPasswordResetEmail(email: email);
      return right(null);
    } on CustomException catch (e) {
      return left(ServerFailure(e.message));
    } catch (e) {
      log('Exception in resetPassword: ${e.toString()}');
      return left(
        ServerFailure('ط­ط¯ط« ط®ط·ط£ ط؛ظٹط± ظ…ط¹ط±ظˆظپ. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.'),
      );
    }
  }

  @override
  Future<Either<Failure, void>> signOut() async {
    try {
      await firebaseAuthService.signOut();
      await SharedPreferencesSingleton.remove(kUserData);
      await SharedPreferencesSingleton.remove(isLoggedIn);
      return right(null);
    } on CustomException catch (e) {
      return left(ServerFailure(e.message));
    } catch (e) {
      log('Exception in signOut: ${e.toString()}');
      return left(
        ServerFailure('ط­ط¯ط« ط®ط·ط£ ط£ط«ظ†ط§ط، طھط³ط¬ظٹظ„ ط§ظ„ط®ط±ظˆط¬. ط§ظ„ط±ط¬ط§ط، ط§ظ„ظ…ط­ط§ظˆظ„ط© ظ…ط±ط© ط£ط®ط±ظ‰.'),
      );
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\domain\entities\user_entity.dart =====
class UserEntity {
  final String firstName;
  final String lastName;
  final String email;
  final String uId;
  final String phoneNumber;
  final String nationalId;

  UserEntity({
    required this.firstName,
    required this.lastName,
    required this.email,
    required this.uId,
    required this.phoneNumber,
    required this.nationalId,
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\domain\repos\auth_repo.dart =====
import 'package:dartz/dartz.dart';

import '../../../../core/errors/failures.dart';
import '../entities/user_entity.dart';

abstract class AuthRepo {
  Future<Either<Failure, UserEntity>> createUserWithEmailAndPassword(
    String email,
    String password,
    String firstName,
    String lastName,
    String phoneNumber,
    String nationalId,
  );
  Future<Either<Failure, UserEntity>> signInWithEmailOrNationalId(
    String emailOrNationalId,
    String password,
  );

  Future<Either<Failure, void>> resetPassword(String emailOrNationalId);

  Future<Either<Failure, void>> signOut();

  Future addUserData({required UserEntity user});
  Future saveUserData({required UserEntity user});

  Future<UserEntity> getUserData({required String nationalId});

  Future<bool> isNationalIdRegistered(String nationalId);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\manager\cubits\reset_password_cubit\reset_password_cubit.dart =====
import 'package:bloc/bloc.dart';
import 'package:meta/meta.dart';

import '../../../../domain/repos/auth_repo.dart';

part 'reset_password_state.dart';

class ResetPasswordCubit extends Cubit<ResetPasswordState> {
  ResetPasswordCubit(this.authRepo) : super(ResetPasswordInitial());

  final AuthRepo authRepo;

  Future<void> resetPassword(String emailOrNationalId) async {
    emit(ResetPasswordLoading());

    final result = await authRepo.resetPassword(emailOrNationalId);

    result.fold(
      (failure) => emit(ResetPasswordFailure(message: failure.message)),
      (_) => emit(ResetPasswordSuccess()),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\manager\cubits\reset_password_cubit\reset_password_state.dart =====
part of 'reset_password_cubit.dart';

@immutable
sealed class ResetPasswordState {}

final class ResetPasswordInitial extends ResetPasswordState {}

final class ResetPasswordLoading extends ResetPasswordState {}

final class ResetPasswordSuccess extends ResetPasswordState {}

final class ResetPasswordFailure extends ResetPasswordState {
  final String message;

  ResetPasswordFailure({required this.message});
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\manager\cubits\signin_cubit\signin_cubit.dart =====
import 'package:bloc/bloc.dart';
import 'package:meta/meta.dart';

import '../../../../domain/entities/user_entity.dart';
import '../../../../domain/repos/auth_repo.dart';

part 'signin_state.dart';

class SigninCubit extends Cubit<SigninState> {
  SigninCubit(this.authRepo) : super(SigninInitial());
  final AuthRepo authRepo;

  Future<void> signIn(String emailOrNationalId, String password) async {
    emit(SigninLoading());
    final result = await authRepo.signInWithEmailOrNationalId(
      emailOrNationalId,
      password,
    );

    result.fold(
      (failure) => emit(SigninFailure(errorMessage: failure.message)),
      (userEntity) => emit(SigninSuccess(userEntity: userEntity)),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\manager\cubits\signin_cubit\signin_state.dart =====
part of 'signin_cubit.dart';

@immutable
sealed class SigninState {}

final class SigninInitial extends SigninState {}

final class SigninLoading extends SigninState {}

final class SigninSuccess extends SigninState {
  final UserEntity userEntity;

  SigninSuccess({required this.userEntity});
}

final class SigninFailure extends SigninState {
  final String errorMessage;

  SigninFailure({required this.errorMessage});
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\manager\cubits\signup_cubit\signup_cubit.dart =====
import 'package:bloc/bloc.dart';
import 'package:depi_project/features/auth/domain/entities/user_entity.dart';
import 'package:meta/meta.dart';

import '../../../../domain/repos/auth_repo.dart';

part 'signup_state.dart';

class SignupCubit extends Cubit<SignupState> {
  SignupCubit(this.authRepo) : super(SignupInitial());
  final AuthRepo authRepo;
  Future<void> createUserWithEmailAndPassword(
    UserEntity user,
    String password,
  ) async {
    emit(SignupLoading());
    try {
      final exists = await authRepo.isNationalIdRegistered(user.nationalId);
      if (exists) {
        emit(SignupFailure(errorMessage: 'ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ ظ…ط³ط¬ظ„ ط¨ط§ظ„ظپط¹ظ„'));
        return;
      }
    } catch (e) {
      emit(SignupFailure(errorMessage: 'ط­ط¯ط« ط®ط·ط£ ط£ط«ظ†ط§ط، ط§ظ„طھط­ظ‚ظ‚ ظ…ظ† ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ'));
      return;
    }

    final result = await authRepo.createUserWithEmailAndPassword(
      user.email,
      password,
      user.firstName,
      user.lastName,
      user.phoneNumber,
      user.nationalId,
    );
    result.fold(
      (failure) => emit(SignupFailure(errorMessage: failure.message)),
      (userEntity) => emit(SignupSuccess(userEntity: userEntity)),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\manager\cubits\signup_cubit\signup_state.dart =====
part of 'signup_cubit.dart';

@immutable
sealed class SignupState {}

final class SignupInitial extends SignupState {}

final class SignupLoading extends SignupState {}

final class SignupSuccess extends SignupState {
  final UserEntity userEntity;

  SignupSuccess({required this.userEntity});
}

final class SignupFailure extends SignupState {
  final String errorMessage;

  SignupFailure({required this.errorMessage});
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\widgets\reset_password_view_body.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/widgets/custom_button.dart';
import 'package:depi_project/core/widgets/custom_text_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../manager/cubits/reset_password_cubit/reset_password_cubit.dart';

class ResetPasswordViewBody extends StatefulWidget {
  const ResetPasswordViewBody({super.key});

  @override
  State<ResetPasswordViewBody> createState() => _ResetPasswordViewBodyState();
}

class _ResetPasswordViewBodyState extends State<ResetPasswordViewBody> {
  final GlobalKey<FormState> formKey = GlobalKey<FormState>();
  AutovalidateMode autovalidateMode = AutovalidateMode.disabled;
  late String emailOrNationalId;

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24),
        child: Form(
          key: formKey,
          autovalidateMode: autovalidateMode,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 120),
              const Text(
                'ط¥ط¹ط§ط¯ط© طھط¹ظٹظٹظ† ظƒظ„ظ…ط© ط§ظ„ظ…ط±ظˆط±',
                style: TextStyle(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  color: AppTheme.black,
                ),
              ),
              const SizedBox(height: 12),
              Text(
                'ط£ط¯ط®ظ„ ط¨ط±ظٹط¯ظƒ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ط£ظˆ ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ ظˆط³ظ†ط±ط³ظ„ ظ„ظƒ ط±ط§ط¨ط· ظ„ط¥ط¹ط§ط¯ط© طھط¹ظٹظٹظ† ظƒظ„ظ…ط© ط§ظ„ظ…ط±ظˆط±',
                style: TextStyle(
                  fontSize: 16,
                  color: Colors.grey.shade600,
                  height: 1.4,
                ),
              ),
              const SizedBox(height: 40),
              CustomTextField(
                onSaved: (value) {
                  emailOrNationalId = value!;
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'ط¨ط±ط¬ط§ط، ط¥ط¯ط®ط§ظ„ ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ط£ظˆ ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ';
                  } else if (!value.contains('@') &&
                      !RegExp(r'^\d+$').hasMatch(value)) {
                    return 'ط¨ط±ط¬ط§ط، ط¥ط¯ط®ط§ظ„ ط¨ط±ظٹط¯ ط¥ظ„ظƒطھط±ظˆظ†ظٹ طµط§ظ„ط­ ط£ظˆ ط±ظ‚ظ… ظ‚ظˆظ…ظٹ طµط­ظٹط­';
                  }
                  return null;
                },
                labelText: 'ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ط£ظˆ ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ',
                hintText: 'example@mail.com ',
                obscureText: false,
                keyboardType: TextInputType.text,
              ),
              const SizedBox(height: 30),
              CustomButton(
                onPressed: () {
                  if (formKey.currentState!.validate()) {
                    formKey.currentState!.save();
                    context.read<ResetPasswordCubit>().resetPassword(
                      emailOrNationalId,
                    );
                  } else {
                    autovalidateMode = AutovalidateMode.always;
                  }
                },
                text: 'ط¥ط±ط³ط§ظ„ ط±ط§ط¨ط· ط¥ط¹ط§ط¯ط© ط§ظ„طھط¹ظٹظٹظ†',
                gradientColors: AppTheme.primaryGradientColors,
                shadowColor: AppTheme.primaryShadowColor,
              ),
              const SizedBox(height: 20),
              Center(
                child: TextButton(
                  onPressed: () {
                    Navigator.pop(context);
                  },
                  child: const Text(
                    'ط§ظ„ط¹ظˆط¯ط© ظ„طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„',
                    style: TextStyle(
                      color: AppTheme.primaryColor,
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\widgets\reset_password_view_body_bloc_consumer.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../manager/cubits/reset_password_cubit/reset_password_cubit.dart';
import 'reset_password_view_body.dart';

class ResetPasswordViewBodyBlocConsumer extends StatelessWidget {
  const ResetPasswordViewBodyBlocConsumer({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<ResetPasswordCubit, ResetPasswordState>(
      listener: (context, state) {
        if (state is ResetPasswordSuccess) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text(
                'طھظ… ط¥ط±ط³ط§ظ„ ط±ط§ط¨ط· ط¥ط¹ط§ط¯ط© طھط¹ظٹظٹظ† ظƒظ„ظ…ط© ط§ظ„ظ…ط±ظˆط± ط¥ظ„ظ‰ ط¨ط±ظٹط¯ظƒ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ',
              ),
              backgroundColor: Colors.green,
              duration: Duration(seconds: 3),
            ),
          );
          Navigator.pop(context);
        }

        if (state is ResetPasswordFailure) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(state.message),
              backgroundColor: AppTheme.primaryColor,
              duration: const Duration(seconds: 3),
            ),
          );
        }
      },
      builder: (context, state) {
        return ModalProgressHUD(
          inAsyncCall: state is ResetPasswordLoading,
          color: Colors.white,
          child: const ResetPasswordViewBody(),
        );
      },
    );
  }
}

class ModalProgressHUD extends StatelessWidget {
  final bool inAsyncCall;
  final double opacity;
  final Color color;
  final Widget child;

  const ModalProgressHUD({
    super.key,
    required this.inAsyncCall,
    this.opacity = 0.5,
    this.color = Colors.grey,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        child,
        if (inAsyncCall)
          Opacity(
            opacity: opacity,
            child: ModalBarrier(dismissible: false, color: color),
          ),
        if (inAsyncCall)
          const Center(
            child: CircularProgressIndicator(color: AppTheme.primaryColor),
          ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\widgets\signin_view_body.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/widgets/custom_button.dart';
import 'package:depi_project/core/widgets/custom_password_field.dart';
import 'package:depi_project/features/auth/presentation/views/signup_view.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../../core/widgets/custom_text_field.dart';
import '../../manager/cubits/signin_cubit/signin_cubit.dart';
import '../reset_password_view.dart';

class SigninViewBody extends StatelessWidget {
  SigninViewBody({super.key});
  final GlobalKey<FormState> formKey = GlobalKey<FormState>();
  AutovalidateMode autovalidateMode = AutovalidateMode.disabled;

  late String emailOrNationalId;
  late String password;
  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24),
        child: Form(
          key: formKey,
          autovalidateMode: autovalidateMode,
          child: Column(
            children: [
              SizedBox(height: 290),
              CustomTextField(
                onSaved: (value) {
                  emailOrNationalId = value!;
                },
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'ط¨ط±ط¬ط§ط، ط¥ط¯ط®ط§ظ„ ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ط£ظˆ ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ';
                  } else if (!value.contains('@') &&
                      !RegExp(r'^\d+$').hasMatch(value)) {
                    return 'ط¨ط±ط¬ط§ط، ط¥ط¯ط®ط§ظ„ ط¨ط±ظٹط¯ ط¥ظ„ظƒطھط±ظˆظ†ظٹ طµط§ظ„ط­ ط£ظˆ ط±ظ‚ظ… ظ‚ظˆظ…ظٹ طµط­ظٹط­';
                  }
                  return null;
                },
                labelText: ' ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط§ظ„ظƒطھط±ظˆظ†ظٹ ط§ظˆ ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ',
                hintText: 'example@mail.com',
                obscureText: false,
                keyboardType: TextInputType.text,
              ),
              SizedBox(height: 16),
              CustomPasswordField(
                onSaved: (value) {
                  password = value!;
                },
              ),
              SizedBox(height: 30),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  GestureDetector(
                    onTap: () {
                      Navigator.pushNamed(context, ResetPasswordView.routeName);
                    },
                    child: const Text(
                      'ظ†ط³ظٹطھ ظƒظ„ظ…ط© ط§ظ„ظ…ط±ظˆط±طں',
                      style: TextStyle(
                        color: AppTheme.primaryColor,
                        fontWeight: FontWeight.w600,
                        decoration: TextDecoration.underline,
                      ),
                    ),
                  ),
                ],
              ),
              SizedBox(height: 20),
              CustomButton(
                onPressed: () {
                  if (formKey.currentState!.validate()) {
                    formKey.currentState!.save();
                    context.read<SigninCubit>().signIn(
                      emailOrNationalId,
                      password,
                    );
                  } else {
                    autovalidateMode = AutovalidateMode.always;
                  }
                },
                text: 'طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„',
                gradientColors: AppTheme.primaryGradientColors,
                shadowColor: AppTheme.primaryShadowColor,
              ),
              SizedBox(height: 180),
              GestureDetector(
                onTap: () {
                  Navigator.pushNamed(context, SignupView.routeName);
                },
                child: Column(
                  children: [
                    Text('ظ„ظٹط³ ظ„ط¯ظٹظƒ ط­ط³ط§ط¨طں'),
                    SizedBox(height: 15),
                    CustomButton(
                      text: 'ط§ظ†ط´ط§ط، ط­ط³ط§ط¨',
                      gradientColors: [
                        const Color.fromARGB(130, 228, 222, 222),
                        const Color.fromARGB(130, 239, 191, 191),
                        const Color.fromARGB(130, 228, 222, 222),
                      ],
                      shadowColor: const Color.fromARGB(
                        255,
                        231,
                        124,
                        124,
                      ).withOpacity(0.5),

                      borderWidth: 1.5,
                      hasShadow: false,
                      textColor: const Color.fromARGB(255, 0, 0, 0),
                    ),
                  ],
                ),
              ),
              SizedBox(height: 30),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\widgets\signin_view_body_bloc_consumer.dart =====
import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';
import 'package:depi_project/features/home/presentation/views/main_screen.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:modal_progress_hud_nsn/modal_progress_hud_nsn.dart';

import '../../../../../core/helpers/build_snack_bar.dart';
import '../../manager/cubits/signin_cubit/signin_cubit.dart';
import 'signin_view_body.dart';

class SigninViewBodyBlocConsumer extends StatelessWidget {
  const SigninViewBodyBlocConsumer({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<SigninCubit, SigninState>(
      listener: (context, state) {
        if (state is SigninSuccess) {
          buildSnackBar(
            context: context,
            title: S.of(context).signIn,
            message: S.of(context).signInSuccess,
            contentType: ContentType.success,
          );
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(builder: (context) => const MainScreen()),
            (route) => false,
          );
        }
        if (state is SigninFailure) {
          buildSnackBar(
            context: context,
            title: S.of(context).notSignedIn,
            message: state.errorMessage,
            contentType: ContentType.failure,
          );
        }
      },
      builder: (context, state) {
        return ModalProgressHUD(
          inAsyncCall: state is SigninLoading ? true : false,
          child: SigninViewBody(),
        );
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\widgets\signup_view_body.dart =====
import 'dart:developer';

import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/widgets/custom_password_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../../core/widgets/custom_button.dart';
import '../../../../../core/widgets/custom_text_field.dart';
import '../../../domain/entities/user_entity.dart';
import '../../manager/cubits/signup_cubit/signup_cubit.dart';

class SignupViewBody extends StatefulWidget {
  const SignupViewBody({super.key});

  @override
  State<SignupViewBody> createState() => _SignupViewBodyState();
}

class _SignupViewBodyState extends State<SignupViewBody> {
  final GlobalKey<FormState> formKey = GlobalKey<FormState>();

  AutovalidateMode autovalidateMode = AutovalidateMode.disabled;

  late String email, firstName, lastName, password, nationalId, phoneNumber;

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: Padding(
        padding: EdgeInsets.symmetric(horizontal: 24),
        child: Form(
          key: formKey,
          autovalidateMode: autovalidateMode,
          child: Column(
            children: [
              SizedBox(height: 50),
              CustomTextField(
                onSaved: (value) {
                  firstName = value!;
                },
                labelText: 'ط§ظ„ط§ط³ظ… ط§ظ„ط§ظˆظ„',
                hintText: 'ظ…ط­ظ…ط¯',
                obscureText: false,
                keyboardType: TextInputType.name,
              ),
              SizedBox(height: 16),
              CustomTextField(
                onSaved: (value) {
                  lastName = value!;
                },
                labelText: 'ط§ظ„ط§ط³ظ… ط§ظ„ط§ط®ظٹط±',
                hintText: 'ط§ط­ظ…ط¯',
                obscureText: false,
                keyboardType: TextInputType.name,
              ),
              SizedBox(height: 16),
              CustomTextField(
                onSaved: (value) {
                  nationalId = value!;
                },
                labelText: 'ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ',
                hintText: '29XXXXXXXXXXXX',
                obscureText: false,
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'ط¨ط±ط¬ط§ط، ط¥ط¯ط®ط§ظ„ ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ';
                  } else if (!RegExp(r'^\d+$').hasMatch(value)) {
                    return 'ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ ظٹط¬ط¨ ط£ظ† ظٹط­طھظˆظٹ ط¹ظ„ظ‰ ط£ط±ظ‚ط§ظ… ظپظ‚ط·';
                  } else if (value.length != 14) {
                    return 'ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ ظٹط¬ط¨ ط£ظ† ظٹطھظƒظˆظ† ظ…ظ† 14 ط±ظ‚ظ…ظ‹ط§';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              CustomTextField(
                onSaved: (value) {
                  phoneNumber = value!;
                },
                labelText: 'ط±ظ‚ظ… ط§ظ„ظ‡ط§طھظپ',
                hintText: '01XXXXXXXXX',
                obscureText: false,
                keyboardType: TextInputType.phone,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'ط¨ط±ط¬ط§ط، ط¥ط¯ط®ط§ظ„ ط±ظ‚ظ… ط§ظ„ظ‡ط§طھظپ';
                  } else if (!RegExp(r'^\d+$').hasMatch(value)) {
                    return 'ط±ظ‚ظ… ط§ظ„ظ‡ط§طھظپ ظٹط¬ط¨ ط£ظ† ظٹط­طھظˆظٹ ط¹ظ„ظ‰ ط£ط±ظ‚ط§ظ… ظپظ‚ط·';
                  } else if (value.length != 11) {
                    return 'ط±ظ‚ظ… ط§ظ„ظ‡ط§طھظپ ظٹط¬ط¨ ط£ظ† ظٹطھظƒظˆظ† ظ…ظ† 11 ط±ظ‚ظ…ظ‹ط§';
                  }
                  return null;
                },
              ),

              SizedBox(height: 16),
              CustomTextField(
                onSaved: (value) {
                  email = value!;
                },
                labelText: 'ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط§ظ„ظƒطھط±ظˆظ†ظٹ',
                hintText: 'example@mail.com',
                obscureText: false,
                keyboardType: TextInputType.emailAddress,
              ),
              SizedBox(height: 16),
              CustomPasswordField(
                onSaved: (value) {
                  password = value!;
                },
              ),
              SizedBox(height: 40),
              CustomButton(
                onPressed: () {
                  if (formKey.currentState!.validate()) {
                    formKey.currentState!.save();
                    log(
                      'email: $email password: $password  firstName: $firstName  lastName: $lastName phoneNumber: $phoneNumber nationalId: $nationalId',
                    );
                    context.read<SignupCubit>().createUserWithEmailAndPassword(
                      UserEntity(
                        email: email,
                        firstName: firstName,
                        lastName: lastName,
                        phoneNumber: phoneNumber,
                        nationalId: nationalId,
                        uId: '',
                      ),
                      password,
                    );
                  } else {
                    setState(() {
                      autovalidateMode = AutovalidateMode.always;
                    });
                  }
                },
                text: ' ط§ظ†ط´ط§ط، ط­ط³ط§ط¨',
                textColor: const Color.fromARGB(255, 11, 11, 11),
                gradientColors: AppTheme.primaryGradientColors,
                shadowColor: const Color.fromARGB(
                  255,
                  190,
                  122,
                  122,
                ).withOpacity(0.2),
              ),
              SizedBox(height: 20),
              GestureDetector(
                onTap: () {
                  Navigator.pop(context);
                },
                child: Column(
                  children: [
                    Text(' ظ„ط¯ظٹظƒ ط­ط³ط§ط¨طں'),
                    SizedBox(height: 20),
                    CustomButton(
                      text: 'طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„',
                      gradientColors: [
                        const Color.fromARGB(130, 228, 222, 222),
                        const Color.fromARGB(130, 239, 191, 191),
                        const Color.fromARGB(130, 228, 222, 222),
                      ],
                      shadowColor: const Color.fromARGB(
                        255,
                        231,
                        124,
                        124,
                      ).withOpacity(0.5),

                      borderWidth: 1.5,
                      hasShadow: false,
                      textColor: const Color.fromARGB(255, 11, 11, 11),
                    ),
                  ],
                ),
              ),
              SizedBox(height: 40),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\widgets\signup_view_body_bloc_consumer.dart =====
import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';
import 'package:depi_project/features/home/presentation/views/main_screen.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:modal_progress_hud_nsn/modal_progress_hud_nsn.dart';

import '../../../../../core/helpers/build_snack_bar.dart';
import '../../manager/cubits/signup_cubit/signup_cubit.dart';
import 'signup_view_body.dart';

class SignupViewBodyBlocConsumer extends StatelessWidget {
  const SignupViewBodyBlocConsumer({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<SignupCubit, SignupState>(
      listener: (context, state) {
        if (state is SignupSuccess) {
          buildSnackBar(
            context: context,
            title: 'طھظ… ط§ظ„طھط³ط¬ظٹظ„',
            message: 'طھظ… ط§ظ„طھط³ط¬ظٹظ„ ط¨ظ†ط¬ط§ط­',
            contentType: ContentType.success,
          );
          Navigator.of(context).pushAndRemoveUntil(
            MaterialPageRoute(builder: (context) => const MainScreen()),
            (route) => false,
          );
        }
        if (state is SignupFailure) {
          buildSnackBar(
            context: context,
            title: 'ظپط´ظ„ ط§ظ„طھط³ط¬ظٹظ„',
            message: state.errorMessage,
            contentType: ContentType.failure,
          );
        }
      },
      builder: (context, state) {
        return ModalProgressHUD(
          inAsyncCall: state is SignupLoading ? true : false,
          child: const SignupViewBody(),
        );
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\reset_password_view.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/services/get_it_service.dart';
import '../../domain/repos/auth_repo.dart';
import '../manager/cubits/reset_password_cubit/reset_password_cubit.dart';
import 'widgets/reset_password_view_body_bloc_consumer.dart';

class ResetPasswordView extends StatelessWidget {
  const ResetPasswordView({super.key});
  static const routeName = 'reset_password';

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => ResetPasswordCubit(getIt<AuthRepo>()),
      child: const Scaffold(body: ResetPasswordViewBodyBlocConsumer()),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\signin_view.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/services/get_it_service.dart';
import '../../domain/repos/auth_repo.dart';
import '../manager/cubits/signin_cubit/signin_cubit.dart';
import 'widgets/signin_view_body_bloc_consumer.dart';

class SigninView extends StatelessWidget {
  const SigninView({super.key});
  static const routeName = 'sign_in';
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => SigninCubit(getIt<AuthRepo>()),
      child: Scaffold(body: SigninViewBodyBlocConsumer()),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\auth\presentation\views\signup_view.dart =====
import 'package:depi_project/core/services/get_it_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../domain/repos/auth_repo.dart';
import '../manager/cubits/signup_cubit/signup_cubit.dart';
import 'widgets/signup_view_body_bloc_consumer.dart';

class SignupView extends StatelessWidget {
  const SignupView({super.key});
  static const routeName = 'sign_up';
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => SignupCubit(getIt<AuthRepo>()),
      child: Scaffold(body: SignupViewBodyBlocConsumer()),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\emergency_numbers\presentation\views\widgets\widget_emergency_numbers.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:flutter/material.dart';
import 'package:flutter_phone_direct_caller/flutter_phone_direct_caller.dart';

class WidgetEmergencyNumbers extends StatefulWidget {
  const WidgetEmergencyNumbers({
    super.key,
    required this.icon,
    required this.text1,
    required this.number,
  });
  final IconData icon;
  final String text1;
  final String number;

  @override
  State<WidgetEmergencyNumbers> createState() => _WidgetEmergencyNumbersState();
}

class _WidgetEmergencyNumbersState extends State<WidgetEmergencyNumbers> {
  bool _showCallConfirm = false;

  _callNumber() async{
    await FlutterPhoneDirectCaller.callNumber(widget.number);       
    setState(() {
      _showCallConfirm = false;
    });
  }

  @override
  Widget build(BuildContext context) {           
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch, 
      children: [
        InkWell(
          onTap: (){      
            setState(() {
              _showCallConfirm = !_showCallConfirm;
            });
          },
          borderRadius: BorderRadius.circular(10),       
          child: Container(
            decoration: BoxDecoration(
              color: AppTheme.lightRed,
              borderRadius: BorderRadius.circular(10),
            ),
            child: Padding(
              padding: const EdgeInsets.only(right: 16, left: 16, top: 16, bottom: 16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        widget.text1,
                        style: Theme.of(context).textTheme.titleMedium!.copyWith(
                              color: AppTheme.black,
                              fontWeight: FontWeight.bold
                            ), 
                      ),
                      const SizedBox(height: 8),
                      Text(
                        widget.number,
                        style: Theme.of(context).textTheme.titleMedium!.copyWith(
                              color: AppTheme.primaryColor,
                              fontWeight: FontWeight.bold
                            ), 
                      ),
                    ],
                  ),
                  Icon(widget.icon, color: AppTheme.primaryColor, size: 40),
                ],
              ),
            ),
          ),
        ),
        
        if (_showCallConfirm)
          Padding(
            padding: const EdgeInsets.only(top: 8),      
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              decoration: BoxDecoration(
                color: AppTheme.primaryColor.withOpacity(0.15), 
                borderRadius: BorderRadius.circular(10),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Text(
                      'ظ‡ظ„ طھط±ظٹط¯ ط§ظ„ط§طھطµط§ظ„ ط§ظ„ط¢ظ† ط¨ظ€ ${widget.number}طں',
                      style: Theme.of(context).textTheme.titleSmall!.copyWith(
                            color: AppTheme.black,
                            fontWeight: FontWeight.bold,
                          ),
                      textAlign: TextAlign.right,
                    ),
                  ),
                  
                  InkWell(
                    onTap: _callNumber, 
                    borderRadius: BorderRadius.circular(8),
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: AppTheme.primaryColor, 
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Row(
                        children: [
                          Icon(Icons.phone, color: AppTheme.white, size: 18),
                          SizedBox(width: 4),
                          Text(
                            'ط§طھطµظ„ ط§ظ„ط¢ظ†',
                            style: TextStyle(color: AppTheme.white, fontWeight: FontWeight.bold, fontSize: 14),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\emergency_numbers\presentation\views\emergency_numbers_body.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/helpers/build_app_bar.dart';
import 'package:depi_project/features/emergency_numbers/presentation/views/widgets/widget_emergency_numbers.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';

class EmergencyNumbersBody extends StatelessWidget {
  const EmergencyNumbersBody({super.key});
  static const String routeName = 'emergency_numbers';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppTheme.white,
      appBar: buildAppBar(title: S.of(context).emergencyNumbers),
      body: Padding(
        padding: const EdgeInsets.only(right: 16, left: 16),
        child: ListView(
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Container(
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Row(
                  children: [
                    Expanded(
                      child: Text(
                        S.of(context).usingEmergencyNumbers,
                        style: Theme.of(
                          context,
                        ).textTheme.titleSmall!.copyWith(color: AppTheme.black),
                      ),
                    ),
                    SizedBox(width: 8),
                    Icon(Icons.info, color: AppTheme.primaryColor),
                  ],
                ),
              ),
            ),

            SizedBox(height: 24),
            WidgetEmergencyNumbers(
              icon: Icons.local_hospital,
              text1: S.of(context).ambulance,
              number: "123",
            ),
            SizedBox(height: 16),
            WidgetEmergencyNumbers(
              icon: Icons.local_police,
              text1: S.of(context).police,
              number: "122",
            ),
            SizedBox(height: 16),
            WidgetEmergencyNumbers(
              icon: Icons.fire_extinguisher,
              text1: S.of(context).fireFighters,
              number: "180",
            ),
            SizedBox(height: 16),
            WidgetEmergencyNumbers(
              icon: Icons.support_agent,
              text1: S.of(context).HelpLine,
              number: "15044",
            ),
            SizedBox(height: 16),
            WidgetEmergencyNumbers(
              icon: Icons.electrical_services,
              text1: S.of(context).electricalEmergency,
              number: "121",
            ),
            SizedBox(height: 16),
            WidgetEmergencyNumbers(
              icon: Icons.local_fire_department,
              text1: S.of(context).fireEmergency,
              number: "180",
            ),
            SizedBox(height: 16),
            WidgetEmergencyNumbers(
              icon: Icons.water_drop,
              text1: S.of(context).water,
              number: "125",
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\from_home_to_page\security_tips_page\presentation\security_tips_page.dart =====
import 'package:animate_do/animate_do.dart';
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/helpers/build_app_bar.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';

class SecurityTipsPage extends StatelessWidget {
  SecurityTipsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final List<Map<String, dynamic>> tips = [
      {
        "icon": Icons.lock,
        "color": Colors.blueAccent,
        "text": S.of(context).tip1,
      },
      {
        "icon": Icons.link_off,
        "color": const Color.fromARGB(255, 212, 34, 34),
        "text": S.of(context).tip2,
      },
      {"icon": Icons.https, "color": Colors.green, "text": S.of(context).tip3},
      {
        "icon": Icons.security,
        "color": Colors.orangeAccent,
        "text": S.of(context).tip4,
      },
      {
        "icon": Icons.vpn_lock,
        "color": Colors.teal,
        "text": S.of(context).tip5,
      },
      {
        "icon": Icons.password,
        "color": Colors.purple,
        "text": S.of(context).tip6,
      },
      {
        "icon": Icons.backup,
        "color": Colors.indigo,
        "text": S.of(context).tip7,
      },
      {
        "icon": Icons.warning,
        "color": const Color.fromARGB(255, 226, 69, 22),
        "text": S.of(context).tip8,
      },
      {
        "icon": Icons.wifi_off,
        "color": const Color.fromARGB(255, 81, 56, 47),
        "text": S.of(context).tip9,
      },
      {"icon": Icons.update, "color": Colors.cyan, "text": S.of(context).tip10},
    ];

    return Scaffold(
      backgroundColor: AppTheme.white,
      appBar: buildAppBar(title: S.of(context).securityTips),
      body: ListView.builder(
        padding: const EdgeInsets.fromLTRB(16, 24, 16, 16),
        itemCount: tips.length,
        itemBuilder: (context, index) {
          final tip = tips[index];
          return FadeInUp(
            delay: Duration(milliseconds: 100 * index),
            child: Container(
              margin: const EdgeInsets.symmetric(vertical: 8),
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: Colors.grey.shade200),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.05),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: ListTile(
                leading: CircleAvatar(
                  backgroundColor: tip["color"].withOpacity(0.15),
                  child: Icon(tip["icon"], color: tip["color"]),
                ),
                title: Text(
                  tip["text"],
                  style: const TextStyle(
                    color: AppTheme.black,
                    fontSize: 15,
                    height: 1.4,
                    fontWeight: FontWeight.w500,
                  ),
                  textAlign: TextAlign.justify,
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\home\presentation\views\widgets\home_widget\widget_awareness_card.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:flutter/material.dart';

class WidgetAwarenessCard extends StatelessWidget {
  const WidgetAwarenessCard({
    super.key,
    required this.text1,
    required this.text2,
    required this.text3,
    required this.text4,

    required this.imageUrl,
  });
  final String text1;
  final String text2;
  final String text3;
  final String text4;

  final String imageUrl;
  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.only(
          left: 16,
          right: 16,
          top: 32,
          bottom: 32,
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  text1,
                  style: TextStyle(color: AppTheme.primaryColor, fontSize: 14),
                ),
                SizedBox(height: 8),
                Text(
                  text2,
                  style: TextStyle(
                    color: AppTheme.black,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                SizedBox(height: 16),
                Text(
                  text3,
                  style: TextStyle(color: AppTheme.darkGrey, fontSize: 14),
                ),
                Text(
                  text4,
                  style: TextStyle(color: AppTheme.darkGrey, fontSize: 14),
                ),
              ],
            ),
            Expanded(
              child: Container(
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(10),
                  child: Image.asset(imageUrl, fit: BoxFit.cover),
                ),
                height: 100,

                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(10),
                ),
              ),
            ),
          ],
        ),
      ),
      elevation: 0.5,
      shadowColor: AppTheme.black,
      color: AppTheme.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\home\presentation\views\widgets\home_widget\widget_quick_options.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/features/emergency_numbers/presentation/views/emergency_numbers_body.dart';
import 'package:depi_project/features/from_home_to_page/security_tips_page/presentation/security_tips_page.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';

import '../../../../../reports/presentation/views/repports_body.dart';

class WidgetQuickOptions extends StatelessWidget {
  const WidgetQuickOptions({
    super.key,
    required this.icon,
    required this.text,
    // this.onTap,
  });
  final IconData icon;
  final String text;
  //final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        if (text == S.of(context).emergencyNumbers) {
          Navigator.of(context).push(
            MaterialPageRoute(
              builder: (context) => const EmergencyNumbersBody(),
            ),
          );
        } else if (text == S.of(context).securityTips) {
          Navigator.of(
            context,
          ).push(MaterialPageRoute(builder: (context) => SecurityTipsPage()));
        } else if (text == S.of(context).myReports) {
          Navigator.of(
            context,
          ).push(MaterialPageRoute(builder: (context) => RepportsBody()));
        }
      },
      child: Container(
        height: MediaQuery.of(context).size.width * 0.22,
        decoration: BoxDecoration(
          color: AppTheme.primaryColor.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(10),
        ),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                text,
                style: TextStyle(
                  color: AppTheme.primaryColor,
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
              Icon(icon, size: 35, color: AppTheme.primaryColor),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\home\presentation\views\home_layout.dart =====
import 'dart:developer';

import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/helpers/get_user.dart';
import 'package:depi_project/features/add_report/presentation/views/add_report_view.dart';
import 'package:depi_project/features/from_home_to_page/security_tips_page/presentation/security_tips_page.dart';
import 'package:depi_project/features/profile/presentation/views/profile_view.dart';
import 'package:depi_project/features/home/presentation/views/widgets/home_widget/widget_awareness_card.dart';
import 'package:depi_project/features/home/presentation/views/widgets/home_widget/widget_quick_options.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';

import '../../../reports/presentation/views/repports_body.dart';

class HomeLayout extends StatelessWidget {
  const HomeLayout({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppTheme.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.only(right: 16, left: 16),
          child: ListView(
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      CircleAvatar(
                        backgroundColor: AppTheme.grey,
                        radius: 30,
                        child: Icon(
                          Icons.person,
                          size: 30,
                          color: AppTheme.lightGrey,
                        ),
                      ),
                      SizedBox(width: 16),
                      GestureDetector(
                        onTap: () {
                          log("Navigating to Profile Page");
                          Navigator.of(context).push(
                            MaterialPageRoute(
                              builder: (context) => ProfileView(),
                            ),
                          );
                        },
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              S.of(context).greeting,
                              style: TextStyle(
                                color: AppTheme.darkGrey,
                                fontSize: 14,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            Text(
                              "${getUser().firstName} ${getUser().lastName}",
                              style: TextStyle(
                                color: AppTheme.black,
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  Icon(Icons.settings, size: 30, color: AppTheme.darkGrey),
                ],
              ),
              SizedBox(height: 32),
              SizedBox(
                width: double.infinity,
                height: MediaQuery.of(context).size.height * 0.25,
                child: Stack(
                  children: [
                    ClipRRect(
                      borderRadius: BorderRadius.circular(10),
                      child: Image.asset(
                        "assets/images/police.jpg",
                        width: double.infinity,
                        fit: BoxFit.cover,
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.only(right: 32, top: 32),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        spacing: 16,
                        children: [
                          Container(
                            width: MediaQuery.of(context).size.width * 0.12,
                            height: MediaQuery.of(context).size.height * 0.06,
                            decoration: BoxDecoration(
                              color: AppTheme.darkGrey,
                              borderRadius: BorderRadius.circular(20),
                            ),
                            child: GestureDetector(
                              onTap: () {
                                Navigator.of(
                                  context,
                                ).pushNamed(AddReportView.routeName);
                              },
                              child: Icon(
                                Icons.add_box,
                                color: AppTheme.white,
                                size: 20,
                              ),
                            ),
                          ),
                          Text(
                            S.of(context).reportButtonTitle,
                            style: TextStyle(
                              color: AppTheme.black,
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          Column(
                            spacing: 8,
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                S.of(context).reportButtonDiscription,
                                style: TextStyle(
                                  color: AppTheme.black,
                                  fontSize: 12,
                                ),
                              ),
                              Text(
                                S.of(context).reportButtonDiscriptionContinue,
                                style: TextStyle(
                                  color: AppTheme.black,
                                  fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              SizedBox(height: 32),
              Text(
                S.of(context).quickOptions,
                style: TextStyle(
                  color: AppTheme.black,
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
              SizedBox(height: 16),
              Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  GestureDetector(
                    onTap: () {
                      log("Navigating to RepportsBody");
                      Navigator.of(context).push(
                        MaterialPageRoute(builder: (context) => RepportsBody()),
                      );
                    },
                    child: WidgetQuickOptions(
                      icon: Icons.receipt_long,
                      text: S.of(context).myReports,
                    ),
                  ),
                  const SizedBox(height: 16),
                  GestureDetector(
                    onTap: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => SecurityTipsPage(),
                        ),
                      );
                    },
                    child: WidgetQuickOptions(
                      icon: Icons.security,
                      text: S.of(context).securityTips,
                    ),
                  ),
                  const SizedBox(height: 16),
                  WidgetQuickOptions(
                    icon: Icons.phone,
                    text: S.of(context).emergencyNumbers,
                  ),
                ],
              ),
              SizedBox(height: 32),
              WidgetAwarenessCard(
                text1: S.of(context).ministryAwareness,
                text2: S.of(context).cyberFraudWarning,
                text3: S.of(context).cyberFraudWarningContinue,
                imageUrl: "assets/images/security.jpg",
                text4: S.of(context).cyberFraudWarningContinue2,
              ),
              SizedBox(height: 16),
              WidgetAwarenessCard(
                text1: S.of(context).ministryAwareness,
                text2: S.of(context).reportingCybercrimes,
                text3: S.of(context).cyberFraudWarningContinue3,
                imageUrl: "assets/images/computer2.jpg",
                text4: S.of(context).cyberFraudWarningContinue4,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\home\presentation\views\main_screen.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/helpers/get_user.dart';
import 'package:depi_project/core/services/get_it_service.dart';
import 'package:depi_project/features/add_report/presentation/views/add_report_view.dart';
import 'package:depi_project/features/home/presentation/views/home_layout.dart';
import 'package:depi_project/features/profile/presentation/views/profile_view.dart';
import 'package:depi_project/core/widgets/notification_badge_icon.dart';
import 'package:depi_project/features/notifications/domain/repos/notifications_repo.dart';
import 'package:depi_project/core/cubits/get_notifications_cubit/get_notifications_cubit.dart';
import 'package:depi_project/features/notifications/presentation/views/notifications_view.dart';
import 'package:depi_project/features/reports/presentation/views/repports_body.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class MainScreen extends StatefulWidget {
  const MainScreen({super.key});

  @override
  State<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> {
  int currentIndex = 0;

  late final GetNotificationsCubit notificationsCubit;
  late final List<Widget> screens;

  @override
  void initState() {
    super.initState();
    final repo = getIt.get<NotificationsRepo>();
    final userId = getUser().uId;
    notificationsCubit = GetNotificationsCubit(repo)
      ..getUserNotifications(userId);

    screens = [
      const HomeLayout(),
      const RepportsBody(),
      BlocProvider.value(
        value: notificationsCubit,
        child: const NotificationsView(provideCubit: false),
      ),
      const ProfileView(),
    ];
  }

  @override
  void dispose() {
    notificationsCubit.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      bottom: false,
      top: false,

      child: Scaffold(
        extendBody: true,
        backgroundColor: const Color.fromARGB(
          255,
          255,
          255,
          255,
        ), // ط®ظ„ظپظٹط© ط؛ط§ظ…ظ‚ط© ط£ظ†ظٹظ‚ط©
        body: IndexedStack(index: currentIndex, children: screens),

        // ًں”¸ ط§ظ„ط²ط± ط§ظ„ط¹ط§ط¦ظ… ظپظٹ ط§ظ„ظ…ظ†طھطµظپ (ط£ط­ظ…ط± ظ…طھظˆظ‡ط¬)
        floatingActionButton: Container(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                color: AppTheme.primaryColor.withValues(
                  alpha: 0.2,
                ), // طھظˆظ‡ط¬ ط£ط­ظ…ط±
                blurRadius: 10,
                spreadRadius: 5,
              ),
            ],
          ),
          child: FloatingActionButton(
            backgroundColor: const Color(0xFFFF6B5E),
            elevation: 6,
            shape: const CircleBorder(),
            onPressed: () {
              showModalBottomSheet(
                context: context,
                isScrollControlled: true,
                useSafeArea: true,
                backgroundColor: Colors.transparent,
                builder: (context) => const AddReportView(),
              );
            },
            child: const Icon(Icons.add, size: 32, color: Colors.white),
          ),
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,

        // ًں”¸ ط§ظ„ط´ط±ظٹط· ط§ظ„ط³ظپظ„ظٹ
        bottomNavigationBar: ClipRRect(
          
          borderRadius: BorderRadius.circular(30),
          child: BlocBuilder<GetNotificationsCubit, GetNotificationsState>(
            bloc: notificationsCubit,
            builder: (context, state) {
              final unreadCount = state is GetNotificationsSuccess
                  ? state.notifications.where((n) => !n.isRead).length
                  : 0;

              return BottomNavigationBar(
                
                elevation: 0,
                type: BottomNavigationBarType.fixed,
                currentIndex: currentIndex,
                selectedItemColor: const Color(0xFFFF6B5E),
                unselectedItemColor: const Color.fromARGB(153, 86, 83, 83),
                iconSize: 24,
                onTap: (index) => setState(() => currentIndex = index),
                items: [
                  BottomNavigationBarItem(
                    icon: Icon(Icons.home),
                    label: S.of(context).home,
                  ),
                  BottomNavigationBarItem(
                    icon: Icon(Icons.receipt_long),
                    label: S.of(context).myReports,
                  ),
                  BottomNavigationBarItem(
                    icon: NotificationBadgeIcon(count: unreadCount),
                    label: S.of(context).notifications,
                  ),
                  BottomNavigationBarItem(
                    icon: Icon(Icons.person),
                    label: S.of(context).profile,
                  ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\notifications\data\models\report_notification_model.dart =====
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:depi_project/core/enums/report_status_enums.dart';

import '../../../../core/entities/report_entity.dart';
import '../../../../core/helpers/report_status_helper.dart';
import '../../domain/entities/report_notification_entity.dart';

class ReportNotificationModel {
  final String id;
  final String reportId;
  final String userId;
  final String title;
  final String message;
  final ReportStatusEnum status;
  final DateTime timestamp;
  final bool isRead;

  const ReportNotificationModel({
    required this.id,
    required this.reportId,
    required this.title,
    required this.userId,
    required this.message,
    required this.status,
    required this.timestamp,
    this.isRead = false,
  });

  factory ReportNotificationModel.fromJson(Map<String, dynamic> json) {
    return ReportNotificationModel(
      id: json['id'] ?? '',
      reportId: json['reportId'] ?? '',
      title: json['title'] ?? '',
      userId: json['userId'] ?? '',
      message: json['message'] ?? '',
      status: statusFromString(json['status']),
      timestamp: json['timestamp'] is Timestamp
          ? (json['timestamp'] as Timestamp).toDate()
          : DateTime.parse(json['timestamp']),
      isRead: json['isRead'] ?? false,
    );
  }

  factory ReportNotificationModel.fromEntity(ReportEntity reportEntity) {
    return ReportNotificationModel(
      id: '',
      reportId: reportEntity.reportId,
      userId: reportEntity.userId,
      title: 'طھظ… طھط­ط¯ظٹط« ط­ط§ظ„ط© ط§ظ„ط¨ظ„ط§ط؛',
      message:
          'طھظ… طھط؛ظٹظٹط± ط­ط§ظ„ط© ط§ظ„ط¨ظ„ط§ط؛ ط§ظ„ط®ط§طµ ط¨ظƒ ط¥ظ„ظ‰ ${reportEntity.statusDisplayName}',
      status: reportEntity.status,
      timestamp: DateTime.now(),
      isRead: false,
    );
  }

  // Convert model to JSON (for Firestore)
  Map<String, dynamic> toJson() {
    return {
      'reportId': reportId,
      'title': title,
      'message': message,
      'userId': userId,
      'status': statusToString(status),
      'timestamp': Timestamp.fromDate(timestamp),
      'isRead': isRead,
    };
  }

  // Convert model to entity
  ReportNotificationEntity toEntity() {
    return ReportNotificationEntity(
      id: id,
      reportId: reportId,
      userId: userId,
      title: title,
      message: message,
      status: status,
      timestamp: timestamp,
      isRead: isRead,
    );
  }

  // Create a copy with updated fields
  ReportNotificationModel copyWith({
    String? id,
    String? reportId,
    String? userId,
    String? title,
    String? message,
    ReportStatusEnum? status,
    DateTime? timestamp,
    bool? isRead,
  }) {
    return ReportNotificationModel(
      id: id ?? this.id,
      reportId: reportId ?? this.reportId,
      title: title ?? this.title,
      message: message ?? this.message,
      status: status ?? this.status,
      userId: userId ?? this.userId,
      timestamp: timestamp ?? this.timestamp,
      isRead: isRead ?? this.isRead,
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\notifications\data\repos\notifications_repo_impl.dart =====
import 'package:dartz/dartz.dart';
import 'package:depi_project/core/entities/report_entity.dart';
import 'package:depi_project/core/errors/failures.dart';
import 'package:depi_project/core/helpers/get_user.dart';
import 'package:depi_project/core/services/database_service.dart';
import 'package:depi_project/core/utils/backend_endpoint.dart';
import 'package:depi_project/features/notifications/data/models/report_notification_model.dart';
import 'package:depi_project/features/notifications/domain/entities/report_notification_entity.dart';
import '../../domain/repos/notifications_repo.dart';

class NotificationsRepoImpl implements NotificationsRepo {
  final DatabaseService databaseService;

  NotificationsRepoImpl(this.databaseService);

  @override
  Stream<Either<Failure, List<ReportNotificationEntity>>> getUserNotifications(
    String userId,
  ) async* {
    try {
      // Get current user from helper
      final currentUser = getUser();

      await for (final data in databaseService.streamCollection(
        path: BackendEndpoint.getNotifications,
      )) {
        // Filter notifications for the current user and convert to entities
        final notifications = data
            .where((e) => e['userId'] == currentUser.uId)
            .map<ReportNotificationEntity>(
              (e) => ReportNotificationModel.fromJson(e).toEntity(),
            )
            .toList();

        // Sort by timestamp (newest first)
        notifications.sort((a, b) => b.timestamp.compareTo(a.timestamp));

        yield Right(notifications);
      }
    } catch (e) {
      yield Left(ServerFailure('ظ„ط§ ظٹظ…ظƒظ† ط¬ظ„ط¨ ط§ظ„ط¥ط´ط¹ط§ط±ط§طھ'));
    }
  }

  @override
  Future<Either<Failure, void>> markNotificationAsRead(
    String notificationId,
  ) async {
    if (notificationId.isEmpty) {
      return Left(ServerFailure('ظ…ط¹ط±ظپ ط§ظ„ط¥ط´ط¹ط§ط± ط؛ظٹط± طµط§ظ„ط­'));
    }

    try {
      await databaseService.updateData(
        path: BackendEndpoint.getNotifications,
        documentId: notificationId,
        data: {'isRead': true},
      );
      return const Right(null);
    } catch (_) {
      return Left(ServerFailure('طھط¹ط°ط± طھط­ط¯ظٹط« ط­ط§ظ„ط© ط§ظ„ط¥ط´ط¹ط§ط±'));
    }
  }

  @override
  Future<Either<Failure, ReportEntity>> getReportById(String reportId) async {
    try {
      final data = await databaseService.getData(
        path: BackendEndpoint.addReports,
        documentId: reportId,
      );

      if (data == null) {
        return Left(ServerFailure('ط§ظ„ط¨ظ„ط§ط؛ ط؛ظٹط± ظ…ظˆط¬ظˆط¯'));
      }

      final map = Map<String, dynamic>.from(data as Map<String, dynamic>);
      return Right(ReportEntity.fromJson(map));
    } catch (_) {
      return Left(ServerFailure('طھط¹ط°ط± طھط­ظ…ظٹظ„ ط¨ظٹط§ظ†ط§طھ ط§ظ„ط¨ظ„ط§ط؛'));
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\notifications\domain\entities\report_notification_entity.dart =====
import 'package:depi_project/core/enums/report_status_enums.dart';

class ReportNotificationEntity {
  final String id;
  final String reportId;
  final String userId;
  final String title;
  final String message;
  final ReportStatusEnum status;
  final DateTime timestamp;
  final bool isRead;

  const ReportNotificationEntity({
    required this.id,
    required this.reportId,
    required this.userId,
    required this.title,
    required this.message,
    required this.status,
    required this.timestamp,
    this.isRead = false,
  });

  // Copy with method to create a modified copy of the entity
  ReportNotificationEntity copyWith({
    String? id,
    String? reportId,
    String? userId,
    String? title,
    String? message,
    ReportStatusEnum? status,
    DateTime? timestamp,
    bool? isRead,
  }) {
    return ReportNotificationEntity(
      id: id ?? this.id,
      reportId: reportId ?? this.reportId,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      message: message ?? this.message,
      status: status ?? this.status,
      timestamp: timestamp ?? this.timestamp,
      isRead: isRead ?? this.isRead,
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\notifications\domain\repos\notifications_repo.dart =====
import 'package:dartz/dartz.dart';

import '../../../../core/entities/report_entity.dart';
import '../../../../core/errors/failures.dart';
import '../entities/report_notification_entity.dart';

abstract class NotificationsRepo {
  Stream<Either<Failure, List<ReportNotificationEntity>>> getUserNotifications(
    String userId,
  );
  Future<Either<Failure, void>> markNotificationAsRead(String notificationId);
  Future<Either<Failure, ReportEntity>> getReportById(String reportId);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\notifications\presentation\views\widgets\notification_card.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../../core/cubits/get_notifications_cubit/get_notifications_cubit.dart';
import '../../../../../core/helpers/format_date_time.dart';
import '../../../../../core/helpers/report_status_helper.dart';
import '../../../../reports/presentation/views/report_details_screen.dart';
import '../../../domain/entities/report_notification_entity.dart';

class NotificationCard extends StatelessWidget {
  const NotificationCard({super.key, required this.notification});

  final ReportNotificationEntity notification;

  @override
  Widget build(BuildContext context) {
    final formattedDate = formatDateTime(notification.timestamp.toLocal());
    final statusColor = getStatusColor(notification.status);
    final statusLabel = getStatusText(notification.status);

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: () => handleTap(context),
        child: Container(
          decoration: BoxDecoration(
            color: notification.isRead ? AppTheme.lightGrey : AppTheme.lightRed,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: AppTheme.primaryColor.withOpacity(0.1)),
          ),
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      notification.title,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                        color: AppTheme.black,
                      ),
                      textAlign: TextAlign.right,
                    ),
                  ),
                  if (!notification.isRead) const SizedBox(width: 8),
                  if (!notification.isRead)
                    const CircleAvatar(
                      radius: 5,
                      backgroundColor: AppTheme.primaryColor,
                    ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                notification.message,
                style: const TextStyle(fontSize: 14, color: AppTheme.black),
                textAlign: TextAlign.right,
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Chip(
                    label: Text(statusLabel),
                    backgroundColor: statusColor.withOpacity(0.15),
                    labelStyle: TextStyle(
                      color: statusColor,
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                    ),
                    padding: const EdgeInsets.symmetric(horizontal: 8),
                  ),
                  const Spacer(),
                  Text(
                    formattedDate,
                    style: TextStyle(fontSize: 12, color: Colors.grey.shade600),
                    textAlign: TextAlign.right,
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> handleTap(BuildContext context) async {
    final cubit = context.read<GetNotificationsCubit>();

    final result = await cubit.handleNotificationTap(notification);
    if (!context.mounted) return;

    switch (result.action) {
      case NotificationTapAction.markedAsRead:
        break;

      case NotificationTapAction.openReport:
        if (result.report != null) {
          await Navigator.of(context).push(
            MaterialPageRoute(
              builder: (_) => ReportDetailsScreen(report: result.report!),
            ),
          );
        }
        break;

      case NotificationTapAction.error:
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(result.errorMessage ?? 'ط­ط¯ط« ط®ط·ط£ ط؛ظٹط± ظ…طھظˆظ‚ط¹'),
            backgroundColor: Colors.red,
          ),
        );
        break;
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\notifications\presentation\views\widgets\notification_view_body.dart =====
import 'package:depi_project/core/cubits/get_notifications_cubit/get_notifications_cubit.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'notification_card.dart';

class NotificationsViewBody extends StatelessWidget {
  const NotificationsViewBody({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<GetNotificationsCubit, GetNotificationsState>(
      builder: (context, state) {
        if (state is GetNotificationsLoading ||
            state is GetNotificationsInitial) {
          return const Center(child: CircularProgressIndicator());
        }

        if (state is GetNotificationsFailure) {
          return Center(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 24),
              child: Text(
                state.message,
                textAlign: TextAlign.center,
                style: const TextStyle(color: Colors.red, fontSize: 16),
              ),
            ),
          );
        }

        if (state is GetNotificationsSuccess) {
          if (state.notifications.isEmpty) {
            return Center(
              child: Text(
                S.of(context).noNotfi,
                style: TextStyle(fontSize: 16, color: Colors.grey),
              ),
            );
          }

          return ListView.separated(
            padding: const EdgeInsets.only(
              left: 16,
              right: 16,
              top: 16,
              bottom: 70,
            ),
            physics: const BouncingScrollPhysics(),

            itemCount: state.notifications.length,
            separatorBuilder: (_, __) => const SizedBox(height: 12),
            itemBuilder: (context, index) {
              final notification = state.notifications[index];
              return NotificationCard(notification: notification);
            },
          );
        }

        return const SizedBox.shrink();
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\notifications\presentation\views\notifications_view.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/helpers/build_app_bar.dart';
import 'package:depi_project/core/helpers/get_user.dart';
import 'package:depi_project/core/services/get_it_service.dart';
import 'package:depi_project/features/notifications/domain/repos/notifications_repo.dart';
import 'package:depi_project/core/cubits/get_notifications_cubit/get_notifications_cubit.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'widgets/notification_view_body.dart';

class NotificationsView extends StatelessWidget {
  const NotificationsView({super.key, this.provideCubit = true});

  final bool provideCubit;

  @override
  Widget build(BuildContext context) {
    final view = Scaffold(
      backgroundColor: AppTheme.white,
      appBar: buildAppBar(title: S.of(context).notifications),
      body: const NotificationsViewBody(),
    );

    if (!provideCubit) {
      return view;
    }

    return BlocProvider<GetNotificationsCubit>(
      create: (_) =>
          GetNotificationsCubit(getIt.get<NotificationsRepo>())
            ..getUserNotifications(getUser().uId),
      child: view,
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\profile\presentation\views\profile_view.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/helpers/build_app_bar.dart';
import 'package:depi_project/core/helpers/get_user.dart';
import 'package:depi_project/core/services/get_it_service.dart';
import 'package:depi_project/core/widgets/custom_button.dart';
import 'package:depi_project/features/auth/domain/entities/user_entity.dart';
import 'package:depi_project/features/auth/domain/repos/auth_repo.dart';
import 'package:depi_project/features/auth/presentation/views/signin_view.dart';
import 'package:depi_project/features/profile/presentation/widgets/profile_info_tile.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';

class ProfileView extends StatelessWidget {
  const ProfileView({super.key});

  @override
  Widget build(BuildContext context) {
    final UserEntity user = getUser();

    return Scaffold(
      backgroundColor: Colors.white,
      appBar: buildAppBar(title: S.of(context).profile),
      body: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            CircleAvatar(
              radius: 45,
              backgroundColor: AppTheme.primaryColor.withOpacity(0.2),
              child: Icon(Icons.person, size: 50, color: AppTheme.primaryColor),
            ),

            const SizedBox(height: 15),

            Text(
              "${user.firstName} ${user.lastName}",
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),

            const SizedBox(height: 30),

            ProfileInfoTile(
              title: S.of(context).email,
              value: user.email,
              icon: Icons.email_outlined,
            ),
            ProfileInfoTile(
              title: S.of(context).phoneNumber,
              value: user.phoneNumber,
              icon: Icons.phone,
            ),
            ProfileInfoTile(
              title: S.of(context).nationalID,
              value: user.nationalId,
              icon: Icons.credit_card,
            ),

            const SizedBox(height: 80),
            CustomButton(
              onPressed: () async {
                final authRepo = getIt.get<AuthRepo>();
                final result = await authRepo.signOut();

                result.fold(
                  (failure) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(failure.message),
                        backgroundColor: Colors.red,
                      ),
                    );
                  },
                  (_) {
                    Navigator.of(context).pushAndRemoveUntil(
                      MaterialPageRoute(
                        builder: (context) => const SigninView(),
                      ),
                      (route) => false,
                    );
                  },
                );
              },
              text: S.of(context).logout,
              gradientColors: [
                Colors.red.shade400,
                Colors.red.shade600,
                Colors.red.shade400,
              ],
              //shadowColor: Colors.red.shade300,
              textColor: Colors.white,
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\profile\presentation\widgets\profile_info_tile.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:flutter/material.dart';

class ProfileInfoTile extends StatelessWidget {
  const ProfileInfoTile({
    super.key,
    required this.title,
    required this.value,
    required this.icon,
  });

  final String title;
  final String value;
  final IconData icon;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 12),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey.shade300),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        children: [
          Icon(icon, color: AppTheme.primaryColor),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: const TextStyle(
                    fontSize: 14,
                    color: Color.fromARGB(223, 175, 170, 170),
                  ),
                ),
                Text(
                  value,
                  style: const TextStyle(
                    fontSize: 15,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\reports\presentation\manager\cubit\reports_cubit.dart =====
import 'dart:async';
import 'dart:developer';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:depi_project/core/entities/report_entity.dart';
import 'package:depi_project/core/helpers/get_user.dart';
import 'package:depi_project/features/reports/presentation/manager/cubit/reports_state.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class GetUserReportsCubit extends Cubit<GetUserReportsState> {
  GetUserReportsCubit() : super(GetUserReportsInitial());
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _subscription;

  void listenToUserReports() async {
    try {
      emit(GetUserReportsLoading());
      final currentUser = getUser();
      final userId = currentUser.uId;

      if (userId.isEmpty) {
        emit(GetUserReportsError("User ID is missing"));
        return;
      }

      log("Listening to reports for user: $userId");

      await _subscription?.cancel();

      final query = _firestore
          .collection('reports')
          .where('userId', isEqualTo: userId)
          .orderBy('createdAt', descending: true);

      _subscription = query.snapshots().listen(
        (querySnapshot) {
          try {
            final reports = querySnapshot.docs.map((doc) {
              final data = Map<String, dynamic>.from(doc.data());

              if (data['createdAt'] is String) {
                try {
                  data['createdAt'] = Timestamp.fromDate(
                    DateTime.parse(data['createdAt']),
                  );
                } catch (e) {
                  log("Failed to parse createdAt: $e");
                }
              }
              if (data['updatedAt'] is String) {
                try {
                  data['updatedAt'] = Timestamp.fromDate(
                    DateTime.parse(data['updatedAt']),
                  );
                } catch (e) {
                  log("Failed to parse updatedAt: $e");
                }
              }

              return ReportEntity.fromJson(data);
            }).toList();

            emit(GetUserReportsSuccess(reports));
          } catch (e) {
            emit(GetUserReportsError(e.toString()));
          }
        },
        onError: (err) {
          emit(GetUserReportsError(err.toString()));
        },
      );
    } catch (e) {
      emit(GetUserReportsError(e.toString()));
    }
  }

  @override
  Future<void> close() async {
    await _subscription?.cancel();
    return super.close();
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\reports\presentation\manager\cubit\reports_state.dart =====
import 'package:depi_project/core/entities/report_entity.dart';

abstract class GetUserReportsState {
  const GetUserReportsState();
  List<Object?> get props => [];

}
class GetUserReportsInitial extends GetUserReportsState {}

class GetUserReportsLoading extends GetUserReportsState {}

class GetUserReportsSuccess extends GetUserReportsState {
  final List<ReportEntity> reports;
  const GetUserReportsSuccess(this.reports);
  @override
  List<Object?> get props => [reports];
}

class GetUserReportsError extends GetUserReportsState {
  final String message;
  const GetUserReportsError(this.message);
  @override
  List<Object?> get props => [message];
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\reports\presentation\views\report_details_screen.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/entities/report_entity.dart';
import 'package:depi_project/core/enums/report_status_enums.dart';
import 'package:depi_project/core/helpers/build_app_bar.dart';
import 'package:flutter/material.dart';

import 'package:depi_project/features/reports/presentation/widgets/media_thumbnail.dart';

class ReportDetailsScreen extends StatelessWidget {
  final ReportEntity report;

  const ReportDetailsScreen({super.key, required this.report});

  @override
  Widget build(BuildContext context) {
    Color getReportStatusColor(ReportStatusEnum status) {
      switch (status) {
        case ReportStatusEnum.pending:
          return Colors.blueGrey.shade500;
        case ReportStatusEnum.inReview:
          return Colors.amber.shade700;
        case ReportStatusEnum.investigating:
          return Colors.orange.shade700;
        case ReportStatusEnum.resolved:
          return Colors.green.shade600;
        case ReportStatusEnum.rejected:
          return Colors.red.shade600;
      }
    }

    return Scaffold(
      appBar: buildAppBar(title: 'طھظپط§طµظٹظ„ ط§ظ„ط¨ظ„ط§ط؛'),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              report.title,
              style: const TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: AppTheme.black,
              ),
            ),
            const SizedBox(height: 16),

            Row(
              children: [
                const Text(
                  'ط§ظ„ط­ط§ظ„ط©:',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                const SizedBox(width: 8),
                Chip(
                  label: Text(
                    report.statusDisplayName,
                    style: TextStyle(
                      color: AppTheme.white,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  backgroundColor: getReportStatusColor(report.status),
                ),
              ],
            ),
            const Divider(height: 32),

            const Text(
              'ط§ظ„ظˆطµظپ:',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text(report.description, style: const TextStyle(fontSize: 16)),
            const Divider(height: 32),

            if (report.address != null && report.address!.isNotEmpty)
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'ط§ظ„ظ…ظˆظ‚ط¹:',
                    style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      const Icon(Icons.location_on, color: AppTheme.darkGrey),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          report.address!,
                          style: const TextStyle(fontSize: 16),
                        ),
                      ),
                    ],
                  ),
                  const Divider(height: 32),
                ],
              ),

            // (Media)
            if (report.mediaUrls.isNotEmpty)
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'ط§ظ„طµظˆط±/ط§ظ„ظپظٹط¯ظٹظˆ:',
                    style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  SizedBox(
                    height: 100,
                    child: ListView.builder(
                      scrollDirection: Axis.horizontal,
                      itemCount: report.mediaUrls.length > 4
                          ? 4
                          : report.mediaUrls.length,
                      itemBuilder: (context, index) {
                        final url = report.mediaUrls[index];
                        final showMore =
                            index == 3 && report.mediaUrls.length > 4;
                        final remaining = showMore
                            ? report.mediaUrls.length - 4
                            : 0;
                        return Padding(
                          padding: const EdgeInsets.only(right: 8.0),
                          child: MediaThumbnail(
                            mediaUrl: url,
                            showMoreIndicator: showMore,
                            remainingCount: remaining,
                          ),
                        );
                      },
                    ),
                  ),
                  const Divider(height: 32),
                ],
              ),

            // (Admin Comment)
            if (report.adminComment != null && report.adminComment!.isNotEmpty)
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: AppTheme.darkGrey.withOpacity(0.5)),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.start,
                  children: [
                    const Text(
                      'طھط¹ظ„ظٹظ‚ ط§ظ„ظ…ط³ط¤ظˆظ„:',
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: AppTheme.primaryColor,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        report.adminComment!,
                        style: const TextStyle(fontSize: 16),
                      ),
                    ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\reports\presentation\views\repports_body.dart =====
import 'dart:developer';

import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/entities/report_entity.dart';
import 'package:depi_project/features/reports/presentation/manager/cubit/reports_cubit.dart';
import 'package:depi_project/features/reports/presentation/manager/cubit/reports_state.dart';
import 'package:depi_project/features/reports/presentation/widgets/report_detail_card.dart';
import 'package:depi_project/generated/l10n.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/helpers/build_app_bar.dart';

class RepportsBody extends StatefulWidget {
  const RepportsBody({super.key});

  @override
  State<RepportsBody> createState() => _RepportsBodyState();
}

class _RepportsBodyState extends State<RepportsBody> {
  final List<ReportEntity> reports = [];
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppTheme.white,
      appBar: buildAppBar(title: S.of(context).myReports),
      body: BlocProvider(
        create: (_) => GetUserReportsCubit()..listenToUserReports(),
        child: BlocBuilder<GetUserReportsCubit, GetUserReportsState>(
          builder: (context, state) {
            if (state is GetUserReportsLoading) {
              return const Center(child: CircularProgressIndicator());
            } else if (state is GetUserReportsError) {
              log(state.message);
              return Center(
                child: Text(
                  '${S.of(context).errorWhileLouding}\n${state.message}',
                  textAlign: TextAlign.center,
                  style: const TextStyle(fontSize: 16, color: Colors.red),
                ),
              );
            } else if (state is GetUserReportsSuccess) {
              if (state.reports.isEmpty) {
                return Center(
                  child: Text(
                    S.of(context).noReports,
                    style: TextStyle(fontSize: 16, color: Colors.grey),
                  ),
                );
              }

              return ListView.builder(
                physics: const BouncingScrollPhysics(),
                itemCount: state.reports.length,
                itemBuilder: (context, index) {
                  final report = state.reports[index];
                  return ReportDetailCard(data: report);
                },
              );
            }

            return const SizedBox.shrink();
          },
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\reports\presentation\widgets\media_thumbnail.dart =====
import 'package:flutter/material.dart';

import '../../../../core/helpers/media_helpers.dart';

class MediaThumbnail extends StatelessWidget {
  final String mediaUrl;
  final bool showMoreIndicator;
  final int remainingCount;

  const MediaThumbnail({
    super.key,
    required this.mediaUrl,
    this.showMoreIndicator = false,
    this.remainingCount = 0,
  });

  @override
  Widget build(BuildContext context) {
    final isVideo = isVideoUrl(mediaUrl);
    final displayUrl = isVideo ? getVideoThumbnailUrl(mediaUrl) : mediaUrl;

    return Container(
      width: 100,
      margin: const EdgeInsets.only(right: 8),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: Colors.grey[200],
      ),
      child: Stack(
        fit: StackFit.expand,
        children: [
          ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: Image.network(
              displayUrl,
              fit: BoxFit.cover,
              errorBuilder: (context, error, stackTrace) {
                return Center(
                  child: Icon(
                    isVideo ? Icons.videocam : Icons.image,
                    color: Colors.grey[400],
                  ),
                );
              },
              loadingBuilder: (context, child, loadingProgress) {
                if (loadingProgress == null) return child;
                return const Center(
                  child: CircularProgressIndicator(strokeWidth: 2),
                );
              },
            ),
          ),
          if (isVideo)
            Center(
              child: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.6),
                  shape: BoxShape.circle,
                ),
                child: const Icon(
                  Icons.play_arrow,
                  color: Colors.white,
                  size: 24,
                ),
              ),
            ),
          if (showMoreIndicator)
            Container(
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.6),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Center(
                child: Text(
                  '+$remainingCount',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\reports\presentation\widgets\report_detail_card.dart =====
import 'package:depi_project/app_theme.dart';
import 'package:depi_project/core/entities/report_entity.dart';
import 'package:depi_project/core/enums/report_status_enums.dart';
import 'package:depi_project/features/reports/presentation/views/report_details_screen.dart';
import 'package:flutter/material.dart';

class ReportDetailCard extends StatelessWidget {
  final ReportEntity data;
  const ReportDetailCard({super.key, required this.data});

  @override
  Widget build(BuildContext context) {
    Color getReportStatusColor(ReportStatusEnum status) {
      switch (status) {
        case ReportStatusEnum.pending:
          return Colors.blueGrey.shade500;
        case ReportStatusEnum.inReview:
          return Colors.amber.shade700;
        case ReportStatusEnum.investigating:
          return Colors.orange.shade700;
        case ReportStatusEnum.resolved:
          return Colors.green.shade600;
        case ReportStatusEnum.rejected:
          return Colors.red.shade600;
      }
    }

    return InkWell(
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => ReportDetailsScreen(report: data),
          ),
        );
      },
      child: Card(
        margin: const EdgeInsets.all(8),
        elevation: 2,
        shadowColor: AppTheme.black,
        color: AppTheme.lightGrey,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Text(
                      data.title,
                      style: TextStyle(
                        color: AppTheme.black,
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Chip(
                    label: Text(
                      data.statusDisplayName,
                      style: TextStyle(
                        color: AppTheme.white,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    backgroundColor: getReportStatusColor(data.status),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 4,
                      vertical: 0,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                data.description,
                style: TextStyle(color: AppTheme.black, fontSize: 12),
                maxLines: 3,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 8),
              if (data.address != null && data.address!.isNotEmpty)
                Row(
                  children: [
                    Icon(Icons.location_on, size: 16, color: AppTheme.darkGrey),
                    const SizedBox(width: 4),
                    Expanded(
                      child: Text(
                        data.address!,
                        style: TextStyle(
                          color: AppTheme.darkGrey,
                          fontSize: 12,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              const SizedBox(height: 8),
              Text(
                'طھط§ط±ظٹط® ط§ظ„ط¨ظ„ط§ط؛ : ${data.createdAt.day}/${data.createdAt.month}/${data.createdAt.year} ',
                style: TextStyle(color: AppTheme.darkGrey, fontSize: 10),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\splash\presentation\manager\cubits\splash_cubit\splash_cubit.dart =====
import 'package:bloc/bloc.dart';
import 'package:depi_project/features/auth/domain/repos/auth_repo.dart';
import 'package:meta/meta.dart';


part 'splash_state.dart';

class SplashCubit extends Cubit<SplashState> {
  final AuthRepo authRepo;

  SplashCubit(this.authRepo) : super(SplashInitial());
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\splash\presentation\manager\cubits\splash_cubit\splash_state.dart =====
part of 'splash_cubit.dart';

@immutable
abstract class SplashState {}

class SplashInitial extends SplashState {}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\splash\presentation\views\widgets\splash_view_body.dart =====
import 'package:depi_project/features/auth/presentation/views/signin_view.dart';
import 'package:depi_project/core/utils/shared_preferences_singleton.dart';
import 'package:depi_project/contants.dart';
import 'package:depi_project/features/home/presentation/views/main_screen.dart';
import 'package:flutter/material.dart';
import 'dart:math';

class SplashViewBody extends StatefulWidget {
  const SplashViewBody({super.key});

  @override
  State<SplashViewBody> createState() => _SplashViewBodyState();
}

class _SplashViewBodyState extends State<SplashViewBody>
    with TickerProviderStateMixin {
  late final AnimationController _mainController;
  late final AnimationController _pulseController;

  late final Animation<double> _scaleAnimation;
  late final Animation<double> _fadeAnimation;
  late final Animation<double> _rotationAnimation;
  late final Animation<double> _glowAnimation;

  @override
  void initState() {
    super.initState();

    //  ط§ظ„ط£ظ†ظٹظ…ظٹط´ظ† ط§ظ„ط£ط³ط§ط³ظٹ (ط§ظ„ط¸ظ‡ظˆط± + ط§ظ„طھظƒط¨ظٹط± + ط§ظ„طھظˆظ‡ط¬ + ط§ظ„ط¯ظˆط±ط§ظ†)
    _mainController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 3),
    )..forward();

    //  ط£ظ†ظٹظ…ظٹط´ظ† ط§ظ„ظ†ط¨ط¶ ط§ظ„ظ…ط³طھظ…ط± ط¨ط¹ط¯ ط§ظ†طھظ‡ط§ط، ط§ظ„ط£ظ†ظٹظ…ظٹط´ظ† ط§ظ„ط£ط³ط§ط³ظٹ
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 8),
      lowerBound: 0.95,
      upperBound: 1.07,
    );

    _pulseController.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _pulseController.reverse();
      } else if (status == AnimationStatus.dismissed) {
        _pulseController.forward();
      }
    });

    //  ط¯ظˆط±ط§ظ† ط¨ط³ظٹط· ظپظٹ ط§ظ„ط¨ط¯ط§ظٹط©
    _rotationAnimation = Tween<double>(begin: 0, end: 2 * pi).animate(
      CurvedAnimation(
        parent: _mainController,
        curve: const Interval(0.0, 0.7, curve: Curves.easeInOutCubic),
      ),
    );

    //  طھظƒط¨ظٹط± طھط¯ط±ظٹط¬ظٹ ظ…ظ† ط§ظ„ط­ط¬ظ… ط§ظ„طµط؛ظٹط± ظ„ظ„ط­ط¬ظ… ط§ظ„ط·ط¨ظٹط¹ظٹ
    _scaleAnimation = Tween<double>(begin: 0.3, end: 1.0).animate(
      CurvedAnimation(
        parent: _mainController,
        curve: const Interval(0.0, 0.8, curve: Curves.easeOutBack),
      ),
    );

    //  طھظˆظ‡ظ‘ط¬ ظ†ط§ط¹ظ… ط¨ظٹط²ظٹط¯ طھط¯ط±ظٹط¬ظٹظ‹ط§
    _glowAnimation = Tween<double>(begin: 0, end: 25).animate(
      CurvedAnimation(parent: _mainController, curve: Curves.easeInOutSine),
    );

    //  ط£ظ†ظٹظ…ظٹط´ظ† ط§ظ„ط¸ظ‡ظˆط± (fade in)
    _fadeAnimation = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(
        parent: _mainController,
        curve: const Interval(0.0, 0.6, curve: Curves.easeIn),
      ),
    );

    // ظ„ظ…ط§ ط§ظ„ط£ظ†ظٹظ…ظٹط´ظ† ط§ظ„ط£ط³ط§ط³ظٹ ظٹط®ظ„طµ â†’ ظ†ط¨ط¯ط£ ط§ظ„ظ†ط¨ط¶
    _mainController.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _pulseController.forward();
      }
    });

    // âڈ± ط§ظ„ط§ظ†طھظ‚ط§ظ„ ط¨ط¹ط¯ ط§ظ„ط§ظ†ظٹظ…ظٹط´ظ†: طھط­ظ‚ظ‚ ظ…ظ† ط­ط§ظ„ط© طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„
    Future.delayed(const Duration(seconds: 4), () async {
      final loggedIn = SharedPreferencesSingleton.getBool(isLoggedIn);
      if (loggedIn) {
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (_) => const MainScreen()),
        );
      } else {
        Navigator.pushReplacementNamed(context, SigninView.routeName);
      }
    });
  }

  @override
  void dispose() {
    _mainController.dispose();
    _pulseController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: Listenable.merge([_mainController, _pulseController]),
      builder: (context, child) {
        final effectiveScale = _scaleAnimation.value * _pulseController.value;

        return Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                const Color(0xFFFCEEE4),
                const Color(0xFFFFF9F6),
                Colors.orangeAccent.withOpacity(0.1),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
          child: Center(
            child: Opacity(
              opacity: _fadeAnimation.value,
              child: Transform.scale(
                scale: effectiveScale,
                child: Transform.rotate(
                  angle: _rotationAnimation.value,
                  child: Container(
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      boxShadow: [
                        BoxShadow(
                          color: const Color.fromARGB(
                            255,
                            253,
                            253,
                            253,
                          ).withOpacity(0.4),
                          blurRadius: _glowAnimation.value,
                          spreadRadius: _glowAnimation.value * 0.3,
                        ),
                      ],
                    ),
                    child: Image.asset(
                      'assets/images/logo.png',
                      width: 400,
                      height: 400,
                      fit: BoxFit.contain,
                    ),
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\features\splash\presentation\views\splash_view.dart =====
import 'package:depi_project/core/services/get_it_service.dart';
import 'package:depi_project/features/auth/domain/repos/auth_repo.dart';
import 'package:depi_project/features/splash/presentation/manager/cubits/splash_cubit/splash_cubit.dart';
import 'package:depi_project/features/splash/presentation/views/widgets/splash_view_body.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class SplashScreen extends StatelessWidget {
  const SplashScreen({super.key});
  static const String routeName = 'splash_screen';
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => SplashCubit(getIt<AuthRepo>()),
      child: const Scaffold(body: SplashViewBody()),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\generated\intl\messages_all.dart =====
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_ar.dart' as messages_ar;
import 'messages_en.dart' as messages_en;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'ar': () => new SynchronousFuture(null),
  'en': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'ar':
      return messages_ar.messages;
    case 'en':
      return messages_en.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale = Intl.verifiedLocale(
    locale,
    _messagesExistFor,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\generated\intl\messages_ar.dart =====
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a ar locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'ar';

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "HelpLine": MessageLookupByLibrary.simpleMessage("ط®ط· ط§ظ„ظ…ط³ط§ط¹ط¯ط©"),
    "addPhotosAndVideos": MessageLookupByLibrary.simpleMessage(
      "ط§ط¶ط؛ط· ط¹ظ„ظ‰ ط§ظ„ط£ظٹظ‚ظˆظ†ط§طھ ظ„ط¥ط¶ط§ظپط© ط§ظ„ظˆط³ط§ط¦ط·",
    ),
    "addingPhoto": MessageLookupByLibrary.simpleMessage("ط§ط¶ط§ظپط© طµظˆط±ط©"),
    "addingVideo": MessageLookupByLibrary.simpleMessage("ط§ط¶ط§ظپط© ظپظٹط¯ظٹظˆ"),
    "alert": MessageLookupByLibrary.simpleMessage("طھظ†ط¨ظٹظ‡"),
    "ambulance": MessageLookupByLibrary.simpleMessage("ط§ظ„ط¥ط³ط¹ط§ظپ"),
    "cyberFraudWarning": MessageLookupByLibrary.simpleMessage(
      "طھط­ط°ظٹط± ظ…ظ† ط§ظ„ط§ط­طھظٹط§ظ„ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ",
    ),
    "cyberFraudWarningContinue": MessageLookupByLibrary.simpleMessage(
      "ط§ط­ظ…ظگ ظ†ظپط³ظƒ ظ…ظ† ط§ظ„ط¬ط±ط§ط¦ظ… ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹط© ",
    ),
    "cyberFraudWarningContinue2": MessageLookupByLibrary.simpleMessage(
      "ظˆط§ظ„ط§ط­طھظٹط§ظ„ ظˆط§ظ„طھظ‡ط¯ظٹط¯ط§طھ",
    ),
    "cyberFraudWarningContinue3": MessageLookupByLibrary.simpleMessage(
      "ط¨ظ„ظ‘ط؛ ط¹ظ† ط§ظ„ط¬ط±ط§ط¦ظ… ظˆط§ظ„ط§ط­طھظٹط§ظ„ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ",
    ),
    "cyberFraudWarningContinue4": MessageLookupByLibrary.simpleMessage(
      " ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ ظ„ط­ظ…ط§ظٹط© ظ†ظپط³ظƒ",
    ),
    "electricalEmergency": MessageLookupByLibrary.simpleMessage(
      "ط·ظˆط§ط±ط¦ ط§ظ„ظƒظ‡ط±ط¨ط§ط،",
    ),
    "email": MessageLookupByLibrary.simpleMessage("ط§ظ„ط¨ط±ظٹط¯ ط§ظ„ط¥ظ„ظƒطھط±ظˆظ†ظٹ"),
    "emergencyNumbers": MessageLookupByLibrary.simpleMessage("ط£ط±ظ‚ط§ظ… ط§ظ„ط·ظˆط§ط±ط¦"),
    "enterReportDescribtion": MessageLookupByLibrary.simpleMessage(
      "ط§ط¯ط®ظ„ ظˆطµظپ ظ„ظ„ط¨ظ„ط§ط؛",
    ),
    "enterReportTitle": MessageLookupByLibrary.simpleMessage(
      "ط§ط¯ط®ظ„ ط¹ظ†ظˆط§ظ† ط§ظ„ط¨ظ„ط§ط؛",
    ),
    "fireEmergency": MessageLookupByLibrary.simpleMessage("ط·ظˆط§ط±ط¦ ط§ظ„ط­ط±ظٹظ‚"),
    "fireFighters": MessageLookupByLibrary.simpleMessage("ط§ظ„ط¥ط·ظپط§ط،"),
    "greeting": MessageLookupByLibrary.simpleMessage("ظ…ط±ط­ط¨ط§ظ‹"),
    "home": MessageLookupByLibrary.simpleMessage("ط§ظ„ط±ط¦ظٹط³ظٹط©"),
    "location": MessageLookupByLibrary.simpleMessage("ط§ظ„ظ…ظˆظ‚ط¹ (ط§ط®طھظٹط§ط±ظٹ)"),
    "locationEx": MessageLookupByLibrary.simpleMessage("ظ…ط«ط§ظ„: ط´ط§ط±ط¹ ط§ظ„ط¬ظ…ظ‡ظˆط±ظٹط©"),
    "logout": MessageLookupByLibrary.simpleMessage("طھط³ط¬ظٹظ„ ط§ظ„ط®ط±ظˆط¬"),
    "ministryAwareness": MessageLookupByLibrary.simpleMessage("طھظˆط¹ظٹط© ط§ظ„ظˆط²ط§ط±ط©"),
    "mustAddMedia": MessageLookupByLibrary.simpleMessage(
      "ظٹط¬ط¨ ط§ط¶ط§ظپط© طµظˆط±ط© ظˆط§ط­ط¯ظ‡ ط§ظˆ ظپظٹط¯ظٹظˆ ط¹ظ„ظٹ ط§ظ„ط§ظ‚ظ„",
    ),
    "myReports": MessageLookupByLibrary.simpleMessage("ط¨ظ„ط§ط؛ط§طھظٹ"),
    "nationalID": MessageLookupByLibrary.simpleMessage("ط§ظ„ط±ظ‚ظ… ط§ظ„ظ‚ظˆظ…ظٹ"),
    "noNotfi": MessageLookupByLibrary.simpleMessage(
      "ظ„ط§ طھظˆط¬ط¯ ط¥ط´ط¹ط§ط±ط§طھ ظپظٹ ط§ظ„ظˆظ‚طھ ط§ظ„ط­ط§ظ„ظٹ.",
    ),
    "noReports": MessageLookupByLibrary.simpleMessage(
      "ظ„ط§ طھظˆط¬ط¯ ط¨ظ„ط§ط؛ط§طھ ظ„ظ‡ط°ط§ ط§ظ„ظ…ط³طھط®ط¯ظ….",
    ),
    "notSignedIn": MessageLookupByLibrary.simpleMessage("Didn\'t sing in"),
    "notifications": MessageLookupByLibrary.simpleMessage("ط§ظ„ط¥ط´ط¹ط§ط±ط§طھ"),
    "phoneNumber": MessageLookupByLibrary.simpleMessage("ط±ظ‚ظ… ط§ظ„ظ‡ط§طھظپ"),
    "photosAndVideos": MessageLookupByLibrary.simpleMessage(
      "ط§ظ„طµظˆط± ظˆط§ظ„ظپظٹط¯ظٹظˆظ‡ط§طھ",
    ),
    "police": MessageLookupByLibrary.simpleMessage("ط§ظ„ط´ط±ط·ط©"),
    "profile": MessageLookupByLibrary.simpleMessage("ط§ظ„ظ…ظ„ظپ ط§ظ„ط´ط®طµظٹ"),
    "quickOptions": MessageLookupByLibrary.simpleMessage("ط®ظٹط§ط±ط§طھ ط³ط±ظٹط¹ط©"),
    "reporTitle": MessageLookupByLibrary.simpleMessage("ط¹ظ†ظˆط§ظ† ط§ظ„ط¨ظ„ط§ط؛"),
    "reportButtonDiscription": MessageLookupByLibrary.simpleMessage(
      "ظٹظ…ظƒظ†ظƒ طھظ‚ط¯ظٹظ… ط¨ظ„ط§ط؛ ط¬ط¯ظٹط¯",
    ),
    "reportButtonDiscriptionContinue": MessageLookupByLibrary.simpleMessage(
      "ط¨ط³ظ‡ظˆظ„ط© ظˆط³ط±ط¹ط©",
    ),
    "reportButtonTitle": MessageLookupByLibrary.simpleMessage(
      "طھظ‚ط¯ظٹظ… ط¨ظ„ط§ط؛ ط¬ط¯ظٹط¯",
    ),
    "reportDescribtion": MessageLookupByLibrary.simpleMessage(
      "Report describtion",
    ),
    "reportDescribtionAtLeast10": MessageLookupByLibrary.simpleMessage(
      "ظˆطµظپ ط§ظ„ط¨ظ„ط§ط؛ ظٹط¬ط¨ ط§ظ† ظٹظƒظˆظ† ط¹ظ„ظٹ ط§ظ„ط§ظ‚ظ„ 10ط§ط­ط±ظپ",
    ),
    "reportEx": MessageLookupByLibrary.simpleMessage("ظ…ط«ط§ظ„: ط³ط±ظ‚ط© ظ…ط­ظ„ طھط¬ط§ط±ظٹ"),
    "reportTitle": MessageLookupByLibrary.simpleMessage("ط¹ظ†ظˆط§ظ† ط§ظ„ط¨ظ„ط§ط؛"),
    "reportTitleAtLeast5": MessageLookupByLibrary.simpleMessage(
      "ط¹ظ†ظˆط§ظ† ط§ظ„ط¨ظ„ط§ط؛ ظٹط¬ط¨ ط§ظ† ظٹظƒظˆظ† ط¹ظ„ظٹ ط§ظ„ط§ظ‚ظ„ 5 ط§ط­ط±ظپ",
    ),
    "reportingCybercrimes": MessageLookupByLibrary.simpleMessage(
      "ط§ظ„طھط¨ظ„ظٹط؛ ط¹ظ† ط§ظ„ط¬ط±ط§ط¦ظ… ط§ظ„ط§ظ„ظƒطھط±ظˆظ†ظٹظ‡",
    ),
    "securityTips": MessageLookupByLibrary.simpleMessage("ظ†طµط§ط¦ط­ ط£ظ…ظ†ظٹط©"),
    "sendingReport": MessageLookupByLibrary.simpleMessage(" ط§ط±ط³ط§ظ„ ط¨ظ„ط§ط؛"),
    "signIn": MessageLookupByLibrary.simpleMessage("طھظ… طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„ "),
    "signInSuccess": MessageLookupByLibrary.simpleMessage(
      "طھظ… طھط³ط¬ظٹظ„ ط§ظ„ط¯ط®ظˆظ„ ط¨ظ†ط¬ط§ط­",
    ),
    "submitReport": MessageLookupByLibrary.simpleMessage("طھظ‚ط¯ظٹظ… ط¨ظ„ط§ط؛"),
    "tip1": MessageLookupByLibrary.simpleMessage(
      "ظ‚ظ… ط¨طھظپط¹ظٹظ„ ط§ظ„ظ…طµط§ط¯ظ‚ط© ط§ظ„ط«ظ†ط§ط¦ظٹط© (2FA) ظ„ط­ظ…ط§ظٹط© ط­ط³ط§ط¨ط§طھظƒ ظ…ظ† ط§ظ„ط§ط®طھط±ط§ظ‚.",
    ),
    "tip10": MessageLookupByLibrary.simpleMessage(
      "ظ‚ظ… ط¨طھط­ط¯ظٹط« ظ†ط¸ط§ظ… ط§ظ„طھط´ط؛ظٹظ„ ظˆط§ظ„طھط·ط¨ظٹظ‚ط§طھ ظ„طھط¬ظ†ط¨ ط§ظ„ط«ط؛ط±ط§طھ ط§ظ„ط£ظ…ظ†ظٹط©.",
    ),
    "tip2": MessageLookupByLibrary.simpleMessage(
      "طھط¬ظ†ظ‘ط¨ ط§ظ„ط¶ط؛ط· ط¹ظ„ظ‰ ط§ظ„ط±ظˆط§ط¨ط· ط§ظ„ظ…ط´ط¨ظˆظ‡ط© ط£ظˆ ط§ظ„ظ…ط±ط³ظ„ط© ظ…ظ† ظ…طµط§ط¯ط± ط؛ظٹط± ظ…ظˆط«ظˆظ‚ط©.",
    ),
    "tip3": MessageLookupByLibrary.simpleMessage(
      "طھط£ظƒط¯ ظ…ظ† ط£ظ† ط§ظ„ظ…ظˆط§ظ‚ط¹ ط§ظ„طھظٹ طھط²ظˆط±ظ‡ط§ طھط¨ط¯ط£ ط¨ظ€ HTTPS ظ‚ط¨ظ„ ط¥ط¯ط®ط§ظ„ ط£ظٹ ط¨ظٹط§ظ†ط§طھ ط­ط³ط§ط³ط©.",
    ),
    "tip4": MessageLookupByLibrary.simpleMessage(
      "ط§ط³طھط®ط¯ظ… ط¨ط±ط§ظ…ط¬ ط§ظ„ط­ظ…ط§ظٹط© ظˆظ‚ظ… ط¨طھط­ط¯ظٹط«ظ‡ط§ ط¨ط§ظ†طھط¸ط§ظ… ظ„ظ„ط­ظ…ط§ظٹط© ظ…ظ† ط§ظ„ظپظٹط±ظˆط³ط§طھ ظˆط§ظ„ط§ط®طھط±ط§ظ‚.",
    ),
    "tip5": MessageLookupByLibrary.simpleMessage(
      "ط§ط³طھط®ط¯ظ… ط´ط¨ظƒط© VPN ظ…ظˆط«ظˆظ‚ط© ط¹ظ†ط¯ ط§ظ„ط§طھطµط§ظ„ ط¨ط´ط¨ظƒط§طھ ط¹ط§ظ…ط© ط£ظˆ ظ…ظپطھظˆط­ط©.",
    ),
    "tip6": MessageLookupByLibrary.simpleMessage(
      "ط§ط®طھط± ظƒظ„ظ…ط§طھ ظ…ط±ظˆط± ظ‚ظˆظٹط© ظˆط·ظˆظٹظ„ط© ظˆظ„ط§ طھط³طھط®ط¯ظ… ظ†ظپط³ ظƒظ„ظ…ط© ط§ظ„ظ…ط±ظˆط± ظ„ط£ظƒط«ط± ظ…ظ† ط­ط³ط§ط¨.",
    ),
    "tip7": MessageLookupByLibrary.simpleMessage(
      "ط§ط­طھظپط¸ ط¨ظ†ط³ط® ط§ط­طھظٹط§ط·ظٹط© ظ…ظ† ط¨ظٹط§ظ†ط§طھظƒ ط§ظ„ظ…ظ‡ظ…ط© ظپظٹ ظ…ظƒط§ظ† ط¢ظ…ظ†.",
    ),
    "tip8": MessageLookupByLibrary.simpleMessage(
      "ط¨ظ„ظ‘ط؛ ظپظˆط±ط§ظ‹ ط¹ظ† ط£ظٹ ظ…ط­ط§ظˆظ„ط© ط§ط­طھظٹط§ظ„ ط£ظˆ طھظ‡ط¯ظٹط¯ ط¥ظ„ظƒطھط±ظˆظ†ظٹ.",
    ),
    "tip9": MessageLookupByLibrary.simpleMessage(
      "طھط¬ظ†ظ‘ط¨ ط¥ط¬ط±ط§ط، ط§ظ„ظ…ط¹ط§ظ…ظ„ط§طھ ط§ظ„ظ…ط§ظ„ظٹط© ط¹ط¨ط± ط´ط¨ظƒط§طھ ط§ظ„ظˆط§ظٹ ظپط§ظٹ ط§ظ„ط¹ط§ظ…ط©.",
    ),
    "usingEmergencyNumbers": MessageLookupByLibrary.simpleMessage(
      "ظٹط±ط¬ظ‰ ط§ط³طھط®ط¯ط§ظ… ظ‡ط°ظ‡ ط§ظ„ط£ط±ظ‚ط§ظ… ظپظ‚ط· ظپظٹ ط­ط§ظ„ط§طھ ط§ظ„ط·ظˆط§ط±ط¦ ط§ظ„ط­ظ‚ظٹظ‚ظٹط©.",
    ),
    "water": MessageLookupByLibrary.simpleMessage("ط§ظ„ظ…ظٹط§ظ‡"),
    "writeReportDescribtion": MessageLookupByLibrary.simpleMessage(
      "ط§ظƒطھط¨ طھظپط§طµظٹظ„ ط§ظ„ط¨ظ„ط§ط؛",
    ),
  };
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\generated\intl\messages_en.dart =====
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a en locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'en';

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "HelpLine": MessageLookupByLibrary.simpleMessage("HelpLine"),
    "addPhotosAndVideos": MessageLookupByLibrary.simpleMessage(
      "Tap the icons to add media",
    ),
    "addingPhoto": MessageLookupByLibrary.simpleMessage("Adding photo"),
    "addingVideo": MessageLookupByLibrary.simpleMessage("Adding video"),
    "alert": MessageLookupByLibrary.simpleMessage("Alert!"),
    "ambulance": MessageLookupByLibrary.simpleMessage("Ambulance"),
    "cyberFraudWarning": MessageLookupByLibrary.simpleMessage(
      "Cyber â€‹â€‹fraud warning",
    ),
    "cyberFraudWarningContinue": MessageLookupByLibrary.simpleMessage(
      "Protect yourself from cybercrime,",
    ),
    "cyberFraudWarningContinue2": MessageLookupByLibrary.simpleMessage(
      " fraud, and threats",
    ),
    "cyberFraudWarningContinue3": MessageLookupByLibrary.simpleMessage(
      "Report cybercrimes and cyber fraud ",
    ),
    "cyberFraudWarningContinue4": MessageLookupByLibrary.simpleMessage(
      "to protect yourself",
    ),
    "electricalEmergency": MessageLookupByLibrary.simpleMessage(
      "Electrical emergency",
    ),
    "email": MessageLookupByLibrary.simpleMessage("Email"),
    "emergencyNumbers": MessageLookupByLibrary.simpleMessage(
      "Emergency Numbers",
    ),
    "enterReportDescribtion": MessageLookupByLibrary.simpleMessage(
      "enter report describtion",
    ),
    "enterReportTitle": MessageLookupByLibrary.simpleMessage(
      "Enter Report Title",
    ),
    "errorWhileLouding": MessageLookupByLibrary.simpleMessage(
      "Error While Louding",
    ),
    "fireEmergency": MessageLookupByLibrary.simpleMessage("Fire emergency"),
    "fireFighters": MessageLookupByLibrary.simpleMessage("Fire Fighters"),
    "greeting": MessageLookupByLibrary.simpleMessage("Hello"),
    "home": MessageLookupByLibrary.simpleMessage("Home"),
    "location": MessageLookupByLibrary.simpleMessage("Location (Optional)"),
    "locationEx": MessageLookupByLibrary.simpleMessage(
      "Example: wsatt albald ,Cairo",
    ),
    "logout": MessageLookupByLibrary.simpleMessage("Logout"),
    "ministryAwareness": MessageLookupByLibrary.simpleMessage(
      "Ministry awareness",
    ),
    "mustAddMedia": MessageLookupByLibrary.simpleMessage(
      "you should add atleast one photo or a video",
    ),
    "myReports": MessageLookupByLibrary.simpleMessage("My Reports"),
    "nationalID": MessageLookupByLibrary.simpleMessage("National ID"),
    "noNotfi": MessageLookupByLibrary.simpleMessage(
      "There are no notifications at the moment.",
    ),
    "noReports": MessageLookupByLibrary.simpleMessage(
      "There are no Report from that user",
    ),
    "notSignedIn": MessageLookupByLibrary.simpleMessage("Didn\'t sing in"),
    "notifications": MessageLookupByLibrary.simpleMessage("Notifications"),
    "phoneNumber": MessageLookupByLibrary.simpleMessage("Phone Number"),
    "photosAndVideos": MessageLookupByLibrary.simpleMessage("Photos & Videos"),
    "police": MessageLookupByLibrary.simpleMessage("Police"),
    "profile": MessageLookupByLibrary.simpleMessage("Profile"),
    "quickOptions": MessageLookupByLibrary.simpleMessage("Quick options"),
    "reporTitle": MessageLookupByLibrary.simpleMessage("Report title"),
    "reportButtonDiscription": MessageLookupByLibrary.simpleMessage(
      "You can submit a new report",
    ),
    "reportButtonDiscriptionContinue": MessageLookupByLibrary.simpleMessage(
      "Easily and quickly",
    ),
    "reportButtonTitle": MessageLookupByLibrary.simpleMessage(
      "Submit new report",
    ),
    "reportDescribtion": MessageLookupByLibrary.simpleMessage(
      "Report describtion",
    ),
    "reportDescribtionAtLeast10": MessageLookupByLibrary.simpleMessage(
      "report describtion should be at least 10",
    ),
    "reportEx": MessageLookupByLibrary.simpleMessage(
      "Example: Robbing a store",
    ),
    "reportTitle": MessageLookupByLibrary.simpleMessage("Report title"),
    "reportTitleAtLeast5": MessageLookupByLibrary.simpleMessage(
      "Report title should be at least 5 letters",
    ),
    "reportingCybercrimes": MessageLookupByLibrary.simpleMessage(
      "Reporting cybercrimes",
    ),
    "securityTips": MessageLookupByLibrary.simpleMessage("Security Tips"),
    "sendingReport": MessageLookupByLibrary.simpleMessage("Send report"),
    "signIn": MessageLookupByLibrary.simpleMessage("signed in "),
    "signInSuccess": MessageLookupByLibrary.simpleMessage(
      "signed in successfully",
    ),
    "submitReport": MessageLookupByLibrary.simpleMessage("Submit Report"),
    "tip1": MessageLookupByLibrary.simpleMessage(
      "Enable two-factor authentication (2FA) to protect your accounts from hacking",
    ),
    "tip10": MessageLookupByLibrary.simpleMessage(
      "Update your operating system and applications to avoid security vulnerabilities.",
    ),
    "tip2": MessageLookupByLibrary.simpleMessage(
      "Avoid clicking on suspicious links or links sent from untrusted sources.",
    ),
    "tip3": MessageLookupByLibrary.simpleMessage(
      "Make sure that the websites you visit begin with HTTPS before entering any sensitive data.",
    ),
    "tip4": MessageLookupByLibrary.simpleMessage(
      "Use and regularly update security software to protect against viruses and hacks",
    ),
    "tip5": MessageLookupByLibrary.simpleMessage(
      "Use a reliable VPN when connecting to public or open networks.",
    ),
    "tip6": MessageLookupByLibrary.simpleMessage(
      "Choose strong and long passwords and do not use the same password for more than one account.",
    ),
    "tip7": MessageLookupByLibrary.simpleMessage(
      "Keep backups of your important data in a safe place.",
    ),
    "tip8": MessageLookupByLibrary.simpleMessage(
      "Report any attempted fraud or cyber threat immediately.",
    ),
    "tip9": MessageLookupByLibrary.simpleMessage(
      "Avoid conducting financial transactions over public Wi-Fi networks.",
    ),
    "usingEmergencyNumbers": MessageLookupByLibrary.simpleMessage(
      "Please use these numbers only in actual emergencies.",
    ),
    "water": MessageLookupByLibrary.simpleMessage("Water"),
    "writeReportDescribtion": MessageLookupByLibrary.simpleMessage(
      "Write Report describtion",
    ),
  };
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\generated\l10n.dart =====
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class S {
  S();

  static S? _current;

  static S get current {
    assert(
      _current != null,
      'No instance of S was loaded. Try to initialize the S delegate before accessing S.current.',
    );
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<S> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = S();
      S._current = instance;

      return instance;
    });
  }

  static S of(BuildContext context) {
    final instance = S.maybeOf(context);
    assert(
      instance != null,
      'No instance of S present in the widget tree. Did you add S.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static S? maybeOf(BuildContext context) {
    return Localizations.of<S>(context, S);
  }

  /// `Hello`
  String get greeting {
    return Intl.message('Hello', name: 'greeting', desc: '', args: []);
  }

  /// `Submit new report`
  String get reportButtonTitle {
    return Intl.message(
      'Submit new report',
      name: 'reportButtonTitle',
      desc: '',
      args: [],
    );
  }

  /// `You can submit a new report`
  String get reportButtonDiscription {
    return Intl.message(
      'You can submit a new report',
      name: 'reportButtonDiscription',
      desc: '',
      args: [],
    );
  }

  /// `Easily and quickly`
  String get reportButtonDiscriptionContinue {
    return Intl.message(
      'Easily and quickly',
      name: 'reportButtonDiscriptionContinue',
      desc: '',
      args: [],
    );
  }

  /// `Quick options`
  String get quickOptions {
    return Intl.message(
      'Quick options',
      name: 'quickOptions',
      desc: '',
      args: [],
    );
  }

  /// `My Reports`
  String get myReports {
    return Intl.message('My Reports', name: 'myReports', desc: '', args: []);
  }

  /// `Security Tips`
  String get securityTips {
    return Intl.message(
      'Security Tips',
      name: 'securityTips',
      desc: '',
      args: [],
    );
  }

  /// `Emergency Numbers`
  String get emergencyNumbers {
    return Intl.message(
      'Emergency Numbers',
      name: 'emergencyNumbers',
      desc: '',
      args: [],
    );
  }

  /// `Ministry awareness`
  String get ministryAwareness {
    return Intl.message(
      'Ministry awareness',
      name: 'ministryAwareness',
      desc: '',
      args: [],
    );
  }

  /// `Cyber â€‹â€‹fraud warning`
  String get cyberFraudWarning {
    return Intl.message(
      'Cyber â€‹â€‹fraud warning',
      name: 'cyberFraudWarning',
      desc: '',
      args: [],
    );
  }

  /// `Protect yourself from cybercrime,`
  String get cyberFraudWarningContinue {
    return Intl.message(
      'Protect yourself from cybercrime,',
      name: 'cyberFraudWarningContinue',
      desc: '',
      args: [],
    );
  }

  /// ` fraud, and threats`
  String get cyberFraudWarningContinue2 {
    return Intl.message(
      ' fraud, and threats',
      name: 'cyberFraudWarningContinue2',
      desc: '',
      args: [],
    );
  }

  /// `Reporting cybercrimes`
  String get reportingCybercrimes {
    return Intl.message(
      'Reporting cybercrimes',
      name: 'reportingCybercrimes',
      desc: '',
      args: [],
    );
  }

  /// `Report cybercrimes and cyber fraud `
  String get cyberFraudWarningContinue3 {
    return Intl.message(
      'Report cybercrimes and cyber fraud ',
      name: 'cyberFraudWarningContinue3',
      desc: '',
      args: [],
    );
  }

  /// `to protect yourself`
  String get cyberFraudWarningContinue4 {
    return Intl.message(
      'to protect yourself',
      name: 'cyberFraudWarningContinue4',
      desc: '',
      args: [],
    );
  }

  /// `Submit Report`
  String get submitReport {
    return Intl.message(
      'Submit Report',
      name: 'submitReport',
      desc: '',
      args: [],
    );
  }

  /// `Report title`
  String get reportTitle {
    return Intl.message(
      'Report title',
      name: 'reportTitle',
      desc: '',
      args: [],
    );
  }

  /// `Home`
  String get home {
    return Intl.message('Home', name: 'home', desc: '', args: []);
  }

  /// `Notifications`
  String get notifications {
    return Intl.message(
      'Notifications',
      name: 'notifications',
      desc: '',
      args: [],
    );
  }

  /// `Profile`
  String get profile {
    return Intl.message('Profile', name: 'profile', desc: '', args: []);
  }

  /// `Email`
  String get email {
    return Intl.message('Email', name: 'email', desc: '', args: []);
  }

  /// `Phone Number`
  String get phoneNumber {
    return Intl.message(
      'Phone Number',
      name: 'phoneNumber',
      desc: '',
      args: [],
    );
  }

  /// `National ID`
  String get nationalID {
    return Intl.message('National ID', name: 'nationalID', desc: '', args: []);
  }

  /// `Logout`
  String get logout {
    return Intl.message('Logout', name: 'logout', desc: '', args: []);
  }

  /// `There are no notifications at the moment.`
  String get noNotfi {
    return Intl.message(
      'There are no notifications at the moment.',
      name: 'noNotfi',
      desc: '',
      args: [],
    );
  }

  /// `There are no Report from that user`
  String get noReports {
    return Intl.message(
      'There are no Report from that user',
      name: 'noReports',
      desc: '',
      args: [],
    );
  }

  /// `Error While Louding`
  String get errorWhileLouding {
    return Intl.message(
      'Error While Louding',
      name: 'errorWhileLouding',
      desc: '',
      args: [],
    );
  }

  /// `Enable two-factor authentication (2FA) to protect your accounts from hacking`
  String get tip1 {
    return Intl.message(
      'Enable two-factor authentication (2FA) to protect your accounts from hacking',
      name: 'tip1',
      desc: '',
      args: [],
    );
  }

  /// `Avoid clicking on suspicious links or links sent from untrusted sources.`
  String get tip2 {
    return Intl.message(
      'Avoid clicking on suspicious links or links sent from untrusted sources.',
      name: 'tip2',
      desc: '',
      args: [],
    );
  }

  /// `Make sure that the websites you visit begin with HTTPS before entering any sensitive data.`
  String get tip3 {
    return Intl.message(
      'Make sure that the websites you visit begin with HTTPS before entering any sensitive data.',
      name: 'tip3',
      desc: '',
      args: [],
    );
  }

  /// `Use and regularly update security software to protect against viruses and hacks`
  String get tip4 {
    return Intl.message(
      'Use and regularly update security software to protect against viruses and hacks',
      name: 'tip4',
      desc: '',
      args: [],
    );
  }

  /// `Use a reliable VPN when connecting to public or open networks.`
  String get tip5 {
    return Intl.message(
      'Use a reliable VPN when connecting to public or open networks.',
      name: 'tip5',
      desc: '',
      args: [],
    );
  }

  /// `Choose strong and long passwords and do not use the same password for more than one account.`
  String get tip6 {
    return Intl.message(
      'Choose strong and long passwords and do not use the same password for more than one account.',
      name: 'tip6',
      desc: '',
      args: [],
    );
  }

  /// `Keep backups of your important data in a safe place.`
  String get tip7 {
    return Intl.message(
      'Keep backups of your important data in a safe place.',
      name: 'tip7',
      desc: '',
      args: [],
    );
  }

  /// `Report any attempted fraud or cyber threat immediately.`
  String get tip8 {
    return Intl.message(
      'Report any attempted fraud or cyber threat immediately.',
      name: 'tip8',
      desc: '',
      args: [],
    );
  }

  /// `Avoid conducting financial transactions over public Wi-Fi networks.`
  String get tip9 {
    return Intl.message(
      'Avoid conducting financial transactions over public Wi-Fi networks.',
      name: 'tip9',
      desc: '',
      args: [],
    );
  }

  /// `Update your operating system and applications to avoid security vulnerabilities.`
  String get tip10 {
    return Intl.message(
      'Update your operating system and applications to avoid security vulnerabilities.',
      name: 'tip10',
      desc: '',
      args: [],
    );
  }

  /// `Please use these numbers only in actual emergencies.`
  String get usingEmergencyNumbers {
    return Intl.message(
      'Please use these numbers only in actual emergencies.',
      name: 'usingEmergencyNumbers',
      desc: '',
      args: [],
    );
  }

  /// `Ambulance`
  String get ambulance {
    return Intl.message('Ambulance', name: 'ambulance', desc: '', args: []);
  }

  /// `Police`
  String get police {
    return Intl.message('Police', name: 'police', desc: '', args: []);
  }

  /// `Fire Fighters`
  String get fireFighters {
    return Intl.message(
      'Fire Fighters',
      name: 'fireFighters',
      desc: '',
      args: [],
    );
  }

  /// `HelpLine`
  String get HelpLine {
    return Intl.message('HelpLine', name: 'HelpLine', desc: '', args: []);
  }

  /// `Electrical emergency`
  String get electricalEmergency {
    return Intl.message(
      'Electrical emergency',
      name: 'electricalEmergency',
      desc: '',
      args: [],
    );
  }

  /// `Fire emergency`
  String get fireEmergency {
    return Intl.message(
      'Fire emergency',
      name: 'fireEmergency',
      desc: '',
      args: [],
    );
  }

  /// `Water`
  String get water {
    return Intl.message('Water', name: 'water', desc: '', args: []);
  }

  /// `Enter Report Title`
  String get enterReportTitle {
    return Intl.message(
      'Enter Report Title',
      name: 'enterReportTitle',
      desc: '',
      args: [],
    );
  }

  /// `Report title should be at least 5 letters`
  String get reportTitleAtLeast5 {
    return Intl.message(
      'Report title should be at least 5 letters',
      name: 'reportTitleAtLeast5',
      desc: '',
      args: [],
    );
  }

  /// `Report title`
  String get reporTitle {
    return Intl.message('Report title', name: 'reporTitle', desc: '', args: []);
  }

  /// `Example: Robbing a store`
  String get reportEx {
    return Intl.message(
      'Example: Robbing a store',
      name: 'reportEx',
      desc: '',
      args: [],
    );
  }

  /// `enter report describtion`
  String get enterReportDescribtion {
    return Intl.message(
      'enter report describtion',
      name: 'enterReportDescribtion',
      desc: '',
      args: [],
    );
  }

  /// `report describtion should be at least 10`
  String get reportDescribtionAtLeast10 {
    return Intl.message(
      'report describtion should be at least 10',
      name: 'reportDescribtionAtLeast10',
      desc: '',
      args: [],
    );
  }

  /// `Report describtion`
  String get reportDescribtion {
    return Intl.message(
      'Report describtion',
      name: 'reportDescribtion',
      desc: '',
      args: [],
    );
  }

  /// `Write Report describtion`
  String get writeReportDescribtion {
    return Intl.message(
      'Write Report describtion',
      name: 'writeReportDescribtion',
      desc: '',
      args: [],
    );
  }

  /// `Location (Optional)`
  String get location {
    return Intl.message(
      'Location (Optional)',
      name: 'location',
      desc: '',
      args: [],
    );
  }

  /// `Example: wsatt albald ,Cairo`
  String get locationEx {
    return Intl.message(
      'Example: wsatt albald ,Cairo',
      name: 'locationEx',
      desc: '',
      args: [],
    );
  }

  /// `Photos & Videos`
  String get photosAndVideos {
    return Intl.message(
      'Photos & Videos',
      name: 'photosAndVideos',
      desc: '',
      args: [],
    );
  }

  /// `Tap the icons to add media`
  String get addPhotosAndVideos {
    return Intl.message(
      'Tap the icons to add media',
      name: 'addPhotosAndVideos',
      desc: '',
      args: [],
    );
  }

  /// `Alert!`
  String get alert {
    return Intl.message('Alert!', name: 'alert', desc: '', args: []);
  }

  /// `you should add atleast one photo or a video`
  String get mustAddMedia {
    return Intl.message(
      'you should add atleast one photo or a video',
      name: 'mustAddMedia',
      desc: '',
      args: [],
    );
  }

  /// `Send report`
  String get sendingReport {
    return Intl.message(
      'Send report',
      name: 'sendingReport',
      desc: '',
      args: [],
    );
  }

  /// `Adding photo`
  String get addingPhoto {
    return Intl.message(
      'Adding photo',
      name: 'addingPhoto',
      desc: '',
      args: [],
    );
  }

  /// `Adding video`
  String get addingVideo {
    return Intl.message(
      'Adding video',
      name: 'addingVideo',
      desc: '',
      args: [],
    );
  }

  /// `signed in `
  String get signIn {
    return Intl.message('signed in ', name: 'signIn', desc: '', args: []);
  }

  /// `signed in successfully`
  String get signInSuccess {
    return Intl.message(
      'signed in successfully',
      name: 'signInSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Didn't sing in`
  String get notSignedIn {
    return Intl.message(
      'Didn\'t sing in',
      name: 'notSignedIn',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<S> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'en'),
      Locale.fromSubtags(languageCode: 'ar'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<S> load(Locale locale) => S.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\app_theme.dart =====
import 'package:flutter/material.dart';

class AppTheme {
  static const Color primaryColor = Color(0xFFDD3F34);
  static const Color white = Color(0xFFFFFFFF);
  static const Color black = Color(0xFF34383B);
  static const Color lightGrey = Color(0xFFF5F5F5);
  static const lightRed = Color(0xFFFAD1CF);
  static const Color grey = Color(0xE0E0E0E0);
  static const darkGrey = Color(0xfff9e9e9e);
  static const primaryGradientColors = [
    Color(0xffDB3022),
    Color(0xFFFF9A8B),
    Color(0xffDB3022),
  ];
  static final Color primaryShadowColor = const Color(
    0xFFFF7F37,
  ).withOpacity(0.4);

  //

  static ThemeData lightTheme = ThemeData(
    primaryColor: primaryColor,
    scaffoldBackgroundColor: white,
    bottomNavigationBarTheme: BottomNavigationBarThemeData(
      type: BottomNavigationBarType.fixed,
      backgroundColor: white,
      selectedItemColor: primaryColor,
      unselectedItemColor: lightGrey,
      showUnselectedLabels: false,
      showSelectedLabels: false,
    ),

    textTheme: TextTheme(
      titleMedium: TextStyle(
        fontSize: 18,
        fontWeight: FontWeight.bold,
        color: black,
      ),
      titleSmall: TextStyle(
        fontSize: 14,
        fontWeight: FontWeight.w400,
        color: black,
      ),
    ),

    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: primaryColor,
        padding: EdgeInsets.only(top: 8),
      ),
    ),
  );

  // dark theme

  static ThemeData darkTheme = ThemeData(
    primaryColor: primaryColor,
    scaffoldBackgroundColor: black,
    bottomNavigationBarTheme: BottomNavigationBarThemeData(
      type: BottomNavigationBarType.fixed,
      backgroundColor: black,
      selectedItemColor: primaryColor,
      unselectedItemColor: white,
      showUnselectedLabels: false,
      showSelectedLabels: false,
    ),

    textTheme: TextTheme(
      titleMedium: TextStyle(
        fontSize: 18,
        fontWeight: FontWeight.bold,
        color: white,
      ),
      titleSmall: TextStyle(
        fontSize: 14,
        fontWeight: FontWeight.w400,
        color: white,
      ),
    ),

    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: primaryColor,
        padding: EdgeInsets.only(top: 8),
      ),
    ),
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\contants.dart =====
const kUserData = 'userData';
const isLoggedIn = 'loggedIn';
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\firebase_options.dart =====
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBHDBni0xaIYi7qt3u5XdkOjRS2p0JAYeo',
    appId: '1:536287924777:web:3ae2479728c41cf3c0c238',
    messagingSenderId: '536287924777',
    projectId: 'depi-project-1dda8',
    authDomain: 'depi-project-1dda8.firebaseapp.com',
    storageBucket: 'depi-project-1dda8.firebasestorage.app',
    measurementId: 'G-H2X46H7NLY',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAeracAMFlbOyrX1vrIUpID2qwKXa_IfOU',
    appId: '1:536287924777:android:a9d0f015b00e9dbac0c238',
    messagingSenderId: '536287924777',
    projectId: 'depi-project-1dda8',
    storageBucket: 'depi-project-1dda8.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDnLLucdBf8kkxarm51qQyoReQLU0P_rEU',
    appId: '1:536287924777:ios:0742c9ef1fa072f8c0c238',
    messagingSenderId: '536287924777',
    projectId: 'depi-project-1dda8',
    storageBucket: 'depi-project-1dda8.firebasestorage.app',
    iosBundleId: 'com.example.depiProject',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDnLLucdBf8kkxarm51qQyoReQLU0P_rEU',
    appId: '1:536287924777:ios:0742c9ef1fa072f8c0c238',
    messagingSenderId: '536287924777',
    projectId: 'depi-project-1dda8',
    storageBucket: 'depi-project-1dda8.firebasestorage.app',
    iosBundleId: 'com.example.depiProject',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBHDBni0xaIYi7qt3u5XdkOjRS2p0JAYeo',
    appId: '1:536287924777:web:64c510d4f7dfe2ffc0c238',
    messagingSenderId: '536287924777',
    projectId: 'depi-project-1dda8',
    authDomain: 'depi-project-1dda8.firebaseapp.com',
    storageBucket: 'depi-project-1dda8.firebasestorage.app',
    measurementId: 'G-GWLCX3J1C4',
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\lib\main.dart =====
import 'dart:developer';

import 'package:depi_project/core/services/custom_bloc_observer.dart';
import 'package:depi_project/features/splash/presentation/views/splash_view.dart';

import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

import 'core/helpers/on_generate_routes.dart';
import 'core/services/get_it_service.dart';
import 'core/utils/shared_preferences_singleton.dart';
import 'firebase_options.dart';
import 'generated/l10n.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  Bloc.observer = CustomBlocObserver();

  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    log('Firebase initialized');
  } on Exception catch (e) {
    log('Error initializing Firebase: $e');
  }
  await SharedPreferencesSingleton.init();

  await dotenv.load(fileName: ".env");

  setupGetit();

  runApp(const DEPI());
}

class DEPI extends StatelessWidget {
  const DEPI({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData(
        scaffoldBackgroundColor: const Color.fromARGB(255, 245, 247, 245),
        fontFamily: 'Cairo',
      ),
      localizationsDelegates: [
        S.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: S.delegate.supportedLocales,
      locale: const Locale('en'),
      debugShowCheckedModeBanner: false,
      onGenerateRoute: onGenerateRoute,
      initialRoute: SplashScreen.routeName,
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\get_directory_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a directory using `getDirectoryPath`,
///  then displays the selected directory in a dialog.
class GetDirectoryPage extends StatelessWidget {
  /// Default Constructor
  const GetDirectoryPage({super.key});

  Future<void> _getDirectoryPath(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final String? directoryPath =
        await FileSelectorPlatform.instance.getDirectoryPath(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPath == null) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(directoryPath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to ask user to choose a directory'),
              onPressed: () => _getDirectoryPath(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPath, {super.key});

  /// The path selected in the dialog.
  final String directoryPath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directory'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPath),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\get_multiple_directories_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select one or more directories using `getDirectoryPaths`,
/// then displays the selected directories in a dialog.
class GetMultipleDirectoriesPage extends StatelessWidget {
  /// Default Constructor
  const GetMultipleDirectoriesPage({super.key});

  Future<void> _getDirectoryPaths(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final List<String> directoryPaths =
        await FileSelectorPlatform.instance.getDirectoryPaths(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPaths.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) =>
            TextDisplay(directoryPaths.join('\n')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Select multiple directories'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text(
                  'Press to ask user to choose multiple directories'),
              onPressed: () => _getDirectoryPaths(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoriesPaths, {super.key});

  /// The path selected in the dialog.
  final String directoriesPaths;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directories'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoriesPaths),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\home_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Home Page of the application.
class HomePage extends StatelessWidget {
  /// Default Constructor
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final ButtonStyle style = ElevatedButton.styleFrom(
      backgroundColor: Colors.blue,
      foregroundColor: Colors.white,
    );
    return Scaffold(
      appBar: AppBar(
        title: const Text('File Selector Demo Home Page'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: style,
              child: const Text('Open a text file'),
              onPressed: () => Navigator.pushNamed(context, '/open/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open an image'),
              onPressed: () => Navigator.pushNamed(context, '/open/image'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open multiple images'),
              onPressed: () => Navigator.pushNamed(context, '/open/images'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Save a file'),
              onPressed: () => Navigator.pushNamed(context, '/save/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directory dialog'),
              onPressed: () => Navigator.pushNamed(context, '/directory'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directories dialog'),
              onPressed: () =>
                  Navigator.pushNamed(context, '/multi-directories'),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

import 'get_directory_page.dart';
import 'get_multiple_directories_page.dart';
import 'home_page.dart';
import 'open_image_page.dart';
import 'open_multiple_images_page.dart';
import 'open_text_page.dart';
import 'save_text_page.dart';

void main() {
  runApp(const MyApp());
}

/// MyApp is the Main Application.
class MyApp extends StatelessWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'File Selector Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: const HomePage(),
      routes: <String, WidgetBuilder>{
        '/open/image': (BuildContext context) => const OpenImagePage(),
        '/open/images': (BuildContext context) =>
            const OpenMultipleImagesPage(),
        '/open/text': (BuildContext context) => const OpenTextPage(),
        '/save/text': (BuildContext context) => SaveTextPage(),
        '/directory': (BuildContext context) => const GetDirectoryPage(),
        '/multi-directories': (BuildContext context) =>
            const GetMultipleDirectoriesPage()
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\open_image_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select an image file using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenImagePage extends StatelessWidget {
  /// Default Constructor
  const OpenImagePage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'images',
      extensions: <String>['jpg', 'png'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String filePath = file.path;

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => ImageDisplay(fileName, filePath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open an image'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open an image file(png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays an image in a dialog.
class ImageDisplay extends StatelessWidget {
  /// Default Constructor.
  const ImageDisplay(this.fileName, this.filePath, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The path to the selected file.
  final String filePath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: kIsWeb ? Image.network(filePath) : Image.file(File(filePath)),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\open_multiple_images_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select multiple image files using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenMultipleImagesPage extends StatelessWidget {
  /// Default Constructor
  const OpenMultipleImagesPage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup jpgsTypeGroup = XTypeGroup(
      label: 'JPEGs',
      extensions: <String>['jpg', 'jpeg'],
    );
    const XTypeGroup pngTypeGroup = XTypeGroup(
      label: 'PNGs',
      extensions: <String>['png'],
    );
    final List<XFile> files = await FileSelectorPlatform.instance
        .openFiles(acceptedTypeGroups: <XTypeGroup>[
      jpgsTypeGroup,
      pngTypeGroup,
    ]);
    if (files.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => MultipleImagesDisplay(files),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open multiple images'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open multiple images (png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class MultipleImagesDisplay extends StatelessWidget {
  /// Default Constructor.
  const MultipleImagesDisplay(this.files, {super.key});

  /// The files containing the images.
  final List<XFile> files;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Gallery'),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: Center(
        child: Row(
          children: <Widget>[
            ...files.map(
              (XFile file) => Flexible(
                  child: kIsWeb
                      ? Image.network(file.path)
                      : Image.file(File(file.path))),
            )
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\open_text_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a text file using `openFile`, then
/// displays its contents in a dialog.
class OpenTextPage extends StatelessWidget {
  /// Default Constructor
  const OpenTextPage({super.key});

  Future<void> _openTextFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'text',
      extensions: <String>['txt', 'json'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String fileContent = await file.readAsString();

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(fileName, fileContent),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open a text file (json, txt)'),
              onPressed: () => _openTextFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Default Constructor.
  const TextDisplay(this.fileName, this.fileContent, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The contents of the text file.
  final String fileContent;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(fileContent),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\save_text_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:typed_data';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a save location using `getSavePath`,
/// then writes text to a file at that location.
class SaveTextPage extends StatelessWidget {
  /// Default Constructor
  SaveTextPage({super.key});

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _contentController = TextEditingController();

  Future<void> _saveFile() async {
    final String fileName = _nameController.text;
    final FileSaveLocation? result =
        await FileSelectorPlatform.instance.getSaveLocation(
      options: SaveDialogOptions(suggestedName: fileName),
    );
    // Operation was canceled by the user.
    if (result == null) {
      return;
    }
    final String text = _contentController.text;
    final Uint8List fileData = Uint8List.fromList(text.codeUnits);
    const String fileMimeType = 'text/plain';
    final XFile textFile =
        XFile.fromData(fileData, mimeType: fileMimeType, name: fileName);
    await textFile.saveTo(result.path);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Save text into a file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: '(Optional) Suggest File Name',
                ),
              ),
            ),
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _contentController,
                decoration: const InputDecoration(
                  hintText: 'Enter File Contents',
                ),
              ),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              onPressed: _saveFile,
              child: const Text('Press to save a text file'),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\pubspec.yaml =====
name: file_selector_linux_example
description: Local testbed for Linux file_selector implementation.
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.3.0
  flutter: ">=3.19.0"

dependencies:
  file_selector_linux:
    path: ../
  file_selector_platform_interface: ^2.6.0
  flutter:
    sdk: flutter

dev_dependencies:
  flutter_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\lib\src\messages.g.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

/// A Pigeon representation of the GTK_FILE_CHOOSER_ACTION_* options.
enum PlatformFileChooserActionType {
  open,
  chooseDirectory,
  save,
}

/// A Pigeon representation of the Linux portion of an `XTypeGroup`.
class PlatformTypeGroup {
  PlatformTypeGroup({
    this.label = '',
    this.extensions = const <String>[],
    this.mimeTypes = const <String>[],
  });

  String label;

  List<String> extensions;

  List<String> mimeTypes;

  Object encode() {
    return <Object?>[
      label,
      extensions,
      mimeTypes,
    ];
  }

  static PlatformTypeGroup decode(Object result) {
    result as List<Object?>;
    return PlatformTypeGroup(
      label: result[0]! as String,
      extensions: (result[1] as List<Object?>?)!.cast<String>(),
      mimeTypes: (result[2] as List<Object?>?)!.cast<String>(),
    );
  }
}

/// Options for GKT file chooser.
///
/// These correspond to gtk_file_chooser_set_* options.
class PlatformFileChooserOptions {
  PlatformFileChooserOptions({
    this.allowedFileTypes,
    this.currentFolderPath,
    this.currentName,
    this.acceptButtonLabel,
    this.selectMultiple,
  });

  List<PlatformTypeGroup>? allowedFileTypes;

  String? currentFolderPath;

  String? currentName;

  String? acceptButtonLabel;

  /// Whether to allow multiple file selection.
  ///
  /// Nullable because it does not apply to the "save" action.
  bool? selectMultiple;

  Object encode() {
    return <Object?>[
      allowedFileTypes,
      currentFolderPath,
      currentName,
      acceptButtonLabel,
      selectMultiple,
    ];
  }

  static PlatformFileChooserOptions decode(Object result) {
    result as List<Object?>;
    return PlatformFileChooserOptions(
      allowedFileTypes:
          (result[0] as List<Object?>?)?.cast<PlatformTypeGroup>(),
      currentFolderPath: result[1] as String?,
      currentName: result[2] as String?,
      acceptButtonLabel: result[3] as String?,
      selectMultiple: result[4] as bool?,
    );
  }
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is PlatformFileChooserActionType) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else if (value is PlatformTypeGroup) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is PlatformFileChooserOptions) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null
            ? null
            : PlatformFileChooserActionType.values[value];
      case 130:
        return PlatformTypeGroup.decode(readValue(buffer)!);
      case 131:
        return PlatformFileChooserOptions.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FileSelectorApi {
  /// Constructor for [FileSelectorApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FileSelectorApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Shows an file chooser with the given [type] and [options], returning the
  /// list of selected paths.
  ///
  /// An empty list corresponds to a cancelled selection.
  Future<List<String>> showFileChooser(PlatformFileChooserActionType type,
      PlatformFileChooserOptions options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_linux.FileSelectorApi.showFileChooser$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[type, options]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!.cast<String>();
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\lib\file_selector_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;

import 'src/messages.g.dart';

/// An implementation of [FileSelectorPlatform] for Linux.
class FileSelectorLinux extends FileSelectorPlatform {
  /// Creates a new plugin implementation instance.
  FileSelectorLinux({
    @visibleForTesting FileSelectorApi? api,
  }) : _hostApi = api ?? FileSelectorApi();

  final FileSelectorApi _hostApi;

  /// Registers the Linux implementation.
  static void registerWith() {
    FileSelectorPlatform.instance = FileSelectorLinux();
  }

  @override
  Future<XFile?> openFile({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.open,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: false,
        ));
    return paths.isEmpty ? null : XFile(paths.first);
  }

  @override
  Future<List<XFile>> openFiles({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.open,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: true,
        ));
    return paths.map((String path) => XFile(path)).toList();
  }

  @override
  Future<String?> getSavePath({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) async {
    final FileSaveLocation? location = await getSaveLocation(
        acceptedTypeGroups: acceptedTypeGroups,
        options: SaveDialogOptions(
          initialDirectory: initialDirectory,
          suggestedName: suggestedName,
          confirmButtonText: confirmButtonText,
        ));
    return location?.path;
  }

  @override
  Future<FileSaveLocation?> getSaveLocation({
    List<XTypeGroup>? acceptedTypeGroups,
    SaveDialogOptions options = const SaveDialogOptions(),
  }) async {
    // TODO(stuartmorgan): Add the selected type group here and return it. See
    // https://github.com/flutter/flutter/issues/107093
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.save,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: options.initialDirectory,
          currentName: options.suggestedName,
          acceptButtonLabel: options.confirmButtonText,
        ));
    return paths.isEmpty ? null : FileSaveLocation(paths.first);
  }

  @override
  Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.chooseDirectory,
        PlatformFileChooserOptions(
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: false,
        ));
    return paths.isEmpty ? null : paths.first;
  }

  @override
  Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    return _hostApi.showFileChooser(
        PlatformFileChooserActionType.chooseDirectory,
        PlatformFileChooserOptions(
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: true,
        ));
  }
}

List<PlatformTypeGroup>? _platformTypeGroupsFromXTypeGroups(
    List<XTypeGroup>? groups) {
  return groups?.map(_platformTypeGroupFromXTypeGroup).toList();
}

PlatformTypeGroup _platformTypeGroupFromXTypeGroup(XTypeGroup group) {
  final String label = group.label ?? '';
  if (group.allowsAny) {
    return PlatformTypeGroup(
      label: label,
      extensions: <String>['*'],
    );
  }
  if ((group.extensions?.isEmpty ?? true) &&
      (group.mimeTypes?.isEmpty ?? true)) {
    throw ArgumentError('Provided type group $group does not allow '
        'all files, but does not set any of the Linux-supported filter '
        'categories. "extensions" or "mimeTypes" must be non-empty for Linux '
        'if anything is non-empty.');
  }
  return PlatformTypeGroup(
      label: label,
      // Covert to GtkFileFilter's *.<extension> format.
      extensions: group.extensions
              ?.map((String extension) => '*.$extension')
              .toList() ??
          <String>[],
      mimeTypes: group.mimeTypes ?? <String>[]);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\pigeons\messages.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  input: 'pigeons/messages.dart',
  gobjectHeaderOut: 'linux/messages.g.h',
  gobjectSourceOut: 'linux/messages.g.cc',
  gobjectOptions: GObjectOptions(module: 'Ffs'),
  dartOut: 'lib/src/messages.g.dart',
  copyrightHeader: 'pigeons/copyright.txt',
))

/// A Pigeon representation of the GTK_FILE_CHOOSER_ACTION_* options.
enum PlatformFileChooserActionType { open, chooseDirectory, save }

/// A Pigeon representation of the Linux portion of an `XTypeGroup`.
class PlatformTypeGroup {
  const PlatformTypeGroup({
    this.label = '',
    this.extensions = const <String>[],
    this.mimeTypes = const <String>[],
  });

  final String label;
  final List<String> extensions;
  final List<String> mimeTypes;
}

/// Options for GKT file chooser.
///
/// These correspond to gtk_file_chooser_set_* options.
class PlatformFileChooserOptions {
  PlatformFileChooserOptions({
    required this.allowedFileTypes,
    required this.currentFolderPath,
    required this.currentName,
    required this.acceptButtonLabel,
    this.selectMultiple,
  });

  final List<PlatformTypeGroup>? allowedFileTypes;
  final String? currentFolderPath;
  final String? currentName;
  final String? acceptButtonLabel;

  /// Whether to allow multiple file selection.
  ///
  /// Nullable because it does not apply to the "save" action.
  final bool? selectMultiple;
}

@HostApi(dartHostTestHandler: 'TestFileSelectorApi')
abstract class FileSelectorApi {
  /// Shows an file chooser with the given [type] and [options], returning the
  /// list of selected paths.
  ///
  /// An empty list corresponds to a cancelled selection.
  List<String> showFileChooser(
      PlatformFileChooserActionType type, PlatformFileChooserOptions options);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\test\file_selector_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:file_selector_linux/src/messages.g.dart';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late FakeFileSelectorApi api;
  late FileSelectorLinux plugin;

  setUp(() {
    api = FakeFileSelectorApi();
    plugin = FileSelectorLinux(api: api);
  });

  test('registers instance', () {
    FileSelectorLinux.registerWith();
    expect(FileSelectorPlatform.instance, isA<FileSelectorLinux>());
  });

  group('openFile', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect((await plugin.openFile())?.path, path);

      expect(api.passedType, PlatformFileChooserActionType.open);
      expect(api.passedOptions?.selectMultiple, false);
    });

    test('handles empty return for cancel', () async {
      api.result = <String>[];

      expect(await plugin.openFile(), null);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.openFile(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.openFile(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('openFiles', () {
    test('passes the core flags correctly', () async {
      api.result = <String>['/foo/bar', 'baz'];

      final List<XFile> files = await plugin.openFiles();

      expect(files.length, 2);
      expect(files[0].path, api.result[0]);
      expect(files[1].path, api.result[1]);

      expect(api.passedType, PlatformFileChooserActionType.open);
      expect(api.passedOptions?.selectMultiple, true);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.openFiles(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.openFiles(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getSaveLocation', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect((await plugin.getSaveLocation())?.path, path);

      expect(api.passedType, PlatformFileChooserActionType.save);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(initialDirectory: path));

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(confirmButtonText: button));

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getSavePath (deprecated)', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect(await plugin.getSavePath(), path);

      expect(api.passedType, PlatformFileChooserActionType.save);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSavePath(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getSavePath(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.getSavePath(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getDirectoryPath', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect(await plugin.getDirectoryPath(), path);

      expect(api.passedType, PlatformFileChooserActionType.chooseDirectory);
      expect(api.passedOptions?.selectMultiple, false);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getDirectoryPath(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Select Folder';
      await plugin.getDirectoryPath(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });
  });

  group('getDirectoryPaths', () {
    test('passes the core flags correctly', () async {
      api.result = <String>['/foo/bar', 'baz'];

      expect(await plugin.getDirectoryPaths(), api.result);

      expect(api.passedType, PlatformFileChooserActionType.chooseDirectory);
      expect(api.passedOptions?.selectMultiple, true);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getDirectoryPaths(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Select one or mode folders';
      await plugin.getDirectoryPaths(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('passes multiple flag correctly', () async {
      await plugin.getDirectoryPaths();

      expect(api.passedOptions?.selectMultiple, true);
    });
  });
}

/// Fake implementation that stores arguments and provides a canned response.
class FakeFileSelectorApi implements FileSelectorApi {
  List<String> result = <String>[];
  PlatformFileChooserActionType? passedType;
  PlatformFileChooserOptions? passedOptions;

  @override
  Future<List<String>> showFileChooser(PlatformFileChooserActionType type,
      PlatformFileChooserOptions options) async {
    passedType = type;
    passedOptions = options;
    return result;
  }

  @override
  // ignore: non_constant_identifier_names
  BinaryMessenger? get pigeonVar_binaryMessenger => null;

  @override
  // ignore: non_constant_identifier_names
  String get pigeonVar_messageChannelSuffix => '';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\pubspec.yaml =====
name: file_selector_linux
description: Liunx implementation of the file_selector plugin.
repository: https://github.com/flutter/packages/tree/main/packages/file_selector/file_selector_linux
issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+file_selector%22
version: 0.9.3+2

environment:
  sdk: ^3.3.0
  flutter: ">=3.19.0"

flutter:
  plugin:
    implements: file_selector
    platforms:
      linux:
        pluginClass: FileSelectorPlugin
        dartPluginClass: FileSelectorLinux

dependencies:
  cross_file: ^0.3.1
  file_selector_platform_interface: ^2.6.0
  flutter:
    sdk: flutter

dev_dependencies:
  flutter_test:
    sdk: flutter
  pigeon: ^22.6.2

topics:
  - files
  - file-selection
  - file-selector
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mime/mime.dart';
import 'package:video_player/video_player.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'Image Picker Demo',
      home: MyHomePage(title: 'Image Picker Example'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, this.title});

  final String? title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  List<XFile>? _mediaFileList;

  // This must be called from within a setState() callback
  void _setImageFileListFromFile(XFile? value) {
    _mediaFileList = value == null ? null : <XFile>[value];
  }

  dynamic _pickImageError;
  bool _isVideo = false;

  VideoPlayerController? _controller;
  VideoPlayerController? _toBeDisposed;
  String? _retrieveDataError;

  final ImagePickerPlatform _picker = ImagePickerPlatform.instance;
  final TextEditingController maxWidthController = TextEditingController();
  final TextEditingController maxHeightController = TextEditingController();
  final TextEditingController qualityController = TextEditingController();

  Future<void> _playVideo(XFile? file) async {
    if (file != null && mounted) {
      await _disposeVideoController();
      final VideoPlayerController controller =
          VideoPlayerController.file(File(file.path));
      _controller = controller;
      await controller.setVolume(1.0);
      await controller.initialize();
      await controller.setLooping(true);
      await controller.play();
      setState(() {});
    }
  }

  Future<void> _onImageButtonPressed(
    ImageSource source, {
    required BuildContext context,
    bool allowMultiple = false,
    bool isMedia = false,
  }) async {
    if (_controller != null) {
      await _controller!.setVolume(0.0);
    }
    if (context.mounted) {
      if (_isVideo) {
        final List<XFile> files;
        if (allowMultiple) {
          files = await _picker.getMultiVideoWithOptions();
        } else {
          final XFile? file = await _picker.getVideo(
              source: source, maxDuration: const Duration(seconds: 10));
          files = <XFile>[if (file != null) file];
        }
        if (files.isNotEmpty && context.mounted) {
          _showPickedSnackBar(context, files);
          // Just play the first file, to keep the example simple.
          await _playVideo(files.first);
        }
      } else if (allowMultiple) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final ImageOptions imageOptions = ImageOptions(
              maxWidth: maxWidth,
              maxHeight: maxHeight,
              imageQuality: quality,
            );
            final List<XFile> pickedFileList = isMedia
                ? await _picker.getMedia(
                    options: MediaOptions(
                      allowMultiple: allowMultiple,
                      imageOptions: imageOptions,
                    ),
                  )
                : await _picker.getMultiImageWithOptions(
                    options: MultiImagePickerOptions(
                      imageOptions: imageOptions,
                    ),
                  );
            if (pickedFileList.isNotEmpty && context.mounted) {
              _showPickedSnackBar(context, pickedFileList);
            }
            setState(() {
              _mediaFileList = pickedFileList;
            });
          } catch (e) {
            setState(() {
              _pickImageError = e;
            });
          }
        });
      } else if (isMedia) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final List<XFile> pickedFileList = <XFile>[];
            final XFile? media = _firstOrNull(await _picker.getMedia(
              options: MediaOptions(
                  allowMultiple: allowMultiple,
                  imageOptions: ImageOptions(
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    imageQuality: quality,
                  )),
            ));

            if (media != null) {
              pickedFileList.add(media);
              setState(() {
                _mediaFileList = pickedFileList;
              });
            }
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      } else {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final XFile? pickedFile = await _picker.getImageFromSource(
              source: source,
              options: ImagePickerOptions(
                maxWidth: maxWidth,
                maxHeight: maxHeight,
                imageQuality: quality,
              ),
            );
            if (pickedFile != null && context.mounted) {
              _showPickedSnackBar(context, <XFile>[pickedFile]);
            }
            setState(() => _setImageFileListFromFile(pickedFile));
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      }
    }
  }

  @override
  void deactivate() {
    if (_controller != null) {
      _controller!.setVolume(0.0);
      _controller!.pause();
    }
    super.deactivate();
  }

  @override
  void dispose() {
    _disposeVideoController();
    maxWidthController.dispose();
    maxHeightController.dispose();
    qualityController.dispose();
    super.dispose();
  }

  Future<void> _disposeVideoController() async {
    if (_toBeDisposed != null) {
      await _toBeDisposed!.dispose();
    }
    _toBeDisposed = _controller;
    _controller = null;
  }

  Widget _previewVideo() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_controller == null) {
      return const Text(
        'You have not yet picked a video',
        textAlign: TextAlign.center,
      );
    }
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: AspectRatioVideo(_controller),
    );
  }

  Widget _previewImages() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_mediaFileList != null) {
      return Semantics(
        label: 'image_picker_example_picked_images',
        child: ListView.builder(
          key: UniqueKey(),
          itemBuilder: (BuildContext context, int index) {
            final XFile image = _mediaFileList![index];
            final String? mime = lookupMimeType(_mediaFileList![index].path);
            return Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                Text(image.name,
                    key: const Key('image_picker_example_picked_image_name')),
                Semantics(
                  label: 'image_picker_example_picked_image',
                  child: mime == null || mime.startsWith('image/')
                      ? Image.file(
                          File(_mediaFileList![index].path),
                          errorBuilder: (BuildContext context, Object error,
                              StackTrace? stackTrace) {
                            return const Center(
                                child:
                                    Text('This image type is not supported'));
                          },
                        )
                      : _buildInlineVideoPlayer(index),
                ),
              ],
            );
          },
          itemCount: _mediaFileList!.length,
        ),
      );
    } else if (_pickImageError != null) {
      return Text(
        'Pick image error: $_pickImageError',
        textAlign: TextAlign.center,
      );
    } else {
      return const Text(
        'You have not yet picked an image.',
        textAlign: TextAlign.center,
      );
    }
  }

  Widget _buildInlineVideoPlayer(int index) {
    final VideoPlayerController controller =
        VideoPlayerController.file(File(_mediaFileList![index].path));
    controller.setVolume(1.0);
    controller.initialize();
    controller.setLooping(true);
    controller.play();
    return Center(child: AspectRatioVideo(controller));
  }

  Widget _handlePreview() {
    if (_isVideo) {
      return _previewVideo();
    } else {
      return _previewImages();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title!),
      ),
      body: Align(
        alignment: Alignment.topCenter,
        child: _handlePreview(),
      ),
      floatingActionButton: Column(
        mainAxisAlignment: MainAxisAlignment.end,
        children: <Widget>[
          Semantics(
            label: 'image_picker_example_from_gallery',
            child: FloatingActionButton.extended(
              key: const Key('image_picker_example_from_gallery'),
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'image0',
              tooltip: 'Pick image from gallery',
              label: const Text('Pick image from gallery'),
              icon: const Icon(Icons.photo),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  allowMultiple: true,
                );
              },
              heroTag: 'image1',
              tooltip: 'Pick multiple images',
              label: const Text('Pick multiple images'),
              icon: const Icon(Icons.photo_library),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMedia: true,
                );
              },
              heroTag: 'media',
              tooltip: 'Pick item from gallery',
              label: const Text('Pick item from gallery'),
              icon: const Icon(Icons.photo_outlined),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  allowMultiple: true,
                  isMedia: true,
                );
              },
              heroTag: 'multipleMedia',
              tooltip: 'Pick multiple items',
              label: const Text('Pick multiple items'),
              icon: const Icon(Icons.photo_library_outlined),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton.extended(
                onPressed: () {
                  _isVideo = false;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'image2',
                tooltip: 'Take a photo',
                label: const Text('Take a photo'),
                icon: const Icon(Icons.camera_alt),
              ),
            ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'video',
              tooltip: 'Pick video from gallery',
              label: const Text('Pick video from gallery'),
              icon: const Icon(Icons.video_file),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery,
                    context: context, allowMultiple: true);
              },
              heroTag: 'multiVideo',
              tooltip: 'Pick multiple videos',
              label: const Text('Pick multiple videos'),
              icon: const Icon(Icons.video_library),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton.extended(
                backgroundColor: Colors.red,
                onPressed: () {
                  _isVideo = true;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'takeVideo',
                tooltip: 'Take a video',
                label: const Text('Take a video'),
                icon: const Icon(Icons.videocam),
              ),
            ),
        ],
      ),
    );
  }

  Text? _getRetrieveErrorWidget() {
    if (_retrieveDataError != null) {
      final Text result = Text(_retrieveDataError!);
      _retrieveDataError = null;
      return result;
    }
    return null;
  }

  Future<void> _displayPickImageDialog(
      BuildContext context, OnPickImageCallback onPick) async {
    return showDialog(
        context: context,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('Add optional parameters'),
            content: Column(
              children: <Widget>[
                TextField(
                  controller: maxWidthController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxWidth if desired'),
                ),
                TextField(
                  controller: maxHeightController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxHeight if desired'),
                ),
                TextField(
                  controller: qualityController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                      hintText: 'Enter quality if desired'),
                ),
              ],
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('CANCEL'),
                onPressed: () {
                  Navigator.of(context).pop();
                },
              ),
              TextButton(
                  child: const Text('PICK'),
                  onPressed: () {
                    final double? width = maxWidthController.text.isNotEmpty
                        ? double.parse(maxWidthController.text)
                        : null;
                    final double? height = maxHeightController.text.isNotEmpty
                        ? double.parse(maxHeightController.text)
                        : null;
                    final int? quality = qualityController.text.isNotEmpty
                        ? int.parse(qualityController.text)
                        : null;
                    onPick(width, height, quality);
                    Navigator.of(context).pop();
                  }),
            ],
          );
        });
  }

  void _showPickedSnackBar(BuildContext context, List<XFile> files) {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text('Picked: ${files.map((XFile it) => it.name).join(',')}'),
      duration: const Duration(seconds: 2),
    ));
  }
}

typedef OnPickImageCallback = void Function(
    double? maxWidth, double? maxHeight, int? quality);

class AspectRatioVideo extends StatefulWidget {
  const AspectRatioVideo(this.controller, {super.key});

  final VideoPlayerController? controller;

  @override
  AspectRatioVideoState createState() => AspectRatioVideoState();
}

class AspectRatioVideoState extends State<AspectRatioVideo> {
  VideoPlayerController? get controller => widget.controller;
  bool initialized = false;

  void _onVideoControllerUpdate() {
    if (!mounted) {
      return;
    }
    if (initialized != controller!.value.isInitialized) {
      initialized = controller!.value.isInitialized;
      setState(() {});
    }
  }

  @override
  void initState() {
    super.initState();
    controller!.addListener(_onVideoControllerUpdate);
  }

  @override
  void dispose() {
    controller!.removeListener(_onVideoControllerUpdate);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (initialized) {
      return Center(
        child: AspectRatio(
          aspectRatio: controller!.value.aspectRatio,
          child: VideoPlayer(controller!),
        ),
      );
    } else {
      return Container();
    }
  }
}

T? _firstOrNull<T>(List<T> list) {
  return list.isEmpty ? null : list.first;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\example\pubspec.yaml =====
name: example
description: Example for image_picker_linux implementation.
publish_to: 'none'
version: 1.0.0

environment:
  sdk: ^3.6.0
  flutter: ">=3.27.0"

dependencies:
  flutter:
    sdk: flutter
  image_picker_linux:
    # When depending on this package from a real application you should use:
    #   image_picker_linux: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ..
  image_picker_platform_interface: ^2.11.0
  mime: ^2.0.0
  video_player: ^2.1.4

dev_dependencies:
  flutter_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\lib\image_picker_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';

/// The Linux implementation of [ImagePickerPlatform].
///
/// This class implements the `package:image_picker` functionality for
/// Linux.
class ImagePickerLinux extends CameraDelegatingImagePickerPlatform {
  /// Constructs a platform implementation.
  ImagePickerLinux();

  /// The file selector used to prompt the user to select images or videos.
  @visibleForTesting
  static FileSelectorPlatform fileSelector = FileSelectorLinux();

  /// Registers this class as the default instance of [ImagePickerPlatform].
  static void registerWith() {
    ImagePickerPlatform.instance = ImagePickerLinux();
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<PickedFile?> pickImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    final XFile? file = await getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getVideo.
  @override
  Future<PickedFile?> pickVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    final XFile? file = await getVideo(
        source: source,
        preferredCameraDevice: preferredCameraDevice,
        maxDuration: maxDuration);
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<XFile?> getImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    return getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
  }

  // [ImagePickerOptions] options are not currently supported. If any
  // of its fields are set, they will be silently ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getImageFromSource({
    required ImageSource source,
    ImagePickerOptions options = const ImagePickerOptions(),
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getImageFromSource(source: source);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Images', mimeTypes: <String>['image/*']);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `preferredCameraDevice` and `maxDuration` arguments are not currently
  // supported. If either of these arguments are supplied, they will be silently
  // ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getVideo(
            source: source,
            preferredCameraDevice: preferredCameraDevice,
            maxDuration: maxDuration);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Videos', mimeTypes: <String>['video/*']);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMultiImage({
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
  }) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Images', mimeTypes: <String>['image/*']);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  @override
  Future<List<XFile>> getMultiVideoWithOptions(
      {MultiVideoPickerOptions options =
          const MultiVideoPickerOptions()}) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Videos', mimeTypes: <String>['video/*']);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMedia({required MediaOptions options}) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'Images and videos',
      mimeTypes: <String>['image/*', 'video/*'],
    );

    List<XFile> files;

    if (options.allowMultiple) {
      files = await fileSelector
          .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    } else {
      final XFile? file = await fileSelector
          .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
      files = <XFile>[
        if (file != null) file,
      ];
    }
    return files;
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\test\image_picker_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:image_picker_linux/image_picker_linux.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'image_picker_linux_test.mocks.dart';

@GenerateMocks(<Type>[FileSelectorPlatform])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  // Returns the captured type groups from a mock call result, assuming that
  // exactly one call was made and only the type groups were captured.
  List<XTypeGroup> capturedTypeGroups(VerificationResult result) {
    return result.captured.single as List<XTypeGroup>;
  }

  late ImagePickerLinux plugin;
  late MockFileSelectorPlatform mockFileSelectorPlatform;

  setUp(() {
    plugin = ImagePickerLinux();
    mockFileSelectorPlatform = MockFileSelectorPlatform();

    when(mockFileSelectorPlatform.openFile(
            acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
        .thenAnswer((_) async => null);

    when(mockFileSelectorPlatform.openFiles(
            acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
        .thenAnswer((_) async => List<XFile>.empty());

    ImagePickerLinux.fileSelector = mockFileSelectorPlatform;
  });

  test('registered instance', () {
    ImagePickerLinux.registerWith();
    expect(ImagePickerPlatform.instance, isA<ImagePickerLinux>());
  });

  group('images', () {
    test('pickImage passes the accepted type groups correctly', () async {
      await plugin.pickImage(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImage passes the accepted type groups correctly', () async {
      await plugin.getImage(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImageFromSource passes the accepted type groups correctly',
        () async {
      await plugin.getImageFromSource(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImageFromSource calls delegate when source is camera', () async {
      const String fakePath = '/tmp/foo';
      plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
      expect(
          (await plugin.getImageFromSource(source: ImageSource.camera))!.path,
          fakePath);
    });

    test(
        'getImageFromSource throws StateError when source is camera with no delegate',
        () async {
      await expectLater(plugin.getImageFromSource(source: ImageSource.camera),
          throwsStateError);
    });

    test('getMultiImage passes the accepted type groups correctly', () async {
      await plugin.getMultiImage();

      final VerificationResult result = verify(
          mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });
  });

  group('videos', () {
    test('pickVideo passes the accepted type groups correctly', () async {
      await plugin.pickVideo(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['video/*']);
    });

    test('getVideo passes the accepted type groups correctly', () async {
      await plugin.getVideo(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['video/*']);
    });

    test('getVideo calls delegate when source is camera', () async {
      const String fakePath = '/tmp/foo';
      plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
      expect(
          (await plugin.getVideo(source: ImageSource.camera))!.path, fakePath);
    });

    test('getVideo throws StateError when source is camera with no delegate',
        () async {
      await expectLater(
          plugin.getVideo(source: ImageSource.camera), throwsStateError);
    });

    test('getMultiVideoWithOptions passes the accepted type groups correctly',
        () async {
      await plugin.getMultiVideoWithOptions();

      final VerificationResult result = verify(
          mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['video/*']);
    });
  });

  group('media', () {
    test('getMedia passes the accepted type groups correctly', () async {
      await plugin.getMedia(options: const MediaOptions(allowMultiple: true));

      final VerificationResult result = verify(
          mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes,
          <String>['image/*', 'video/*']);
    });

    test('multiple media handles an empty path response gracefully', () async {
      expect(
          await plugin.getMedia(
            options: const MediaOptions(
              allowMultiple: true,
            ),
          ),
          <String>[]);
    });

    test('single media handles an empty path response gracefully', () async {
      expect(
          await plugin.getMedia(
            options: const MediaOptions(
              allowMultiple: false,
            ),
          ),
          <String>[]);
    });
  });
}

class FakeCameraDelegate extends ImagePickerCameraDelegate {
  FakeCameraDelegate({this.result});

  XFile? result;

  @override
  Future<XFile?> takePhoto(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }

  @override
  Future<XFile?> takeVideo(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\test\image_picker_linux_test.mocks.dart =====
// Mocks generated by Mockito 5.4.4 from annotations
// in image_picker_linux/test/image_picker_linux_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

/// A class which mocks [FileSelectorPlatform].
///
/// See the documentation for Mockito's code generation for more information.
class MockFileSelectorPlatform extends _i1.Mock
    implements _i2.FileSelectorPlatform {
  MockFileSelectorPlatform() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i2.XFile?> openFile({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFile,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<_i2.XFile?>.value(),
      ) as _i3.Future<_i2.XFile?>);

  @override
  _i3.Future<List<_i2.XFile>> openFiles({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFiles,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<_i2.XFile>>.value(<_i2.XFile>[]),
      ) as _i3.Future<List<_i2.XFile>>);

  @override
  _i3.Future<String?> getSavePath({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSavePath,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #suggestedName: suggestedName,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);

  @override
  _i3.Future<_i2.FileSaveLocation?> getSaveLocation({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    _i2.SaveDialogOptions? options = const _i2.SaveDialogOptions(),
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSaveLocation,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #options: options,
          },
        ),
        returnValue: _i3.Future<_i2.FileSaveLocation?>.value(),
      ) as _i3.Future<_i2.FileSaveLocation?>);

  @override
  _i3.Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPath,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);

  @override
  _i3.Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPaths,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<String>>.value(<String>[]),
      ) as _i3.Future<List<String>>);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\pubspec.yaml =====
name: image_picker_linux
description: Linux platform implementation of image_picker
repository: https://github.com/flutter/packages/tree/main/packages/image_picker/image_picker_linux
issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+image_picker%22
version: 0.2.2

environment:
  sdk: ^3.6.0
  flutter: ">=3.27.0"

flutter:
  plugin:
    implements: image_picker
    platforms:
      linux:
        dartPluginClass: ImagePickerLinux

dependencies:
  file_selector_linux: ^0.9.1+3
  file_selector_platform_interface: ^2.2.0
  flutter:
    sdk: flutter
  image_picker_platform_interface: ^2.11.0

dev_dependencies:
  build_runner: ^2.1.5
  flutter_test:
    sdk: flutter
  mockito: ^5.4.4

topics:
  - image-picker
  - files
  - file-selection
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\integration_test\path_provider_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('getTemporaryDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getTemporaryPath();
    _verifySampleFile(result, 'temporaryDirectory');
  });

  testWidgets('getDownloadDirectory', (WidgetTester tester) async {
    if (!Platform.isLinux) {
      return;
    }
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getDownloadsPath();
    _verifySampleFile(result, 'downloadDirectory');
  });

  testWidgets('getApplicationDocumentsDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationDocumentsPath();
    _verifySampleFile(result, 'applicationDocuments');
  });

  testWidgets('getApplicationSupportDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationSupportPath();
    _verifySampleFile(result, 'applicationSupport');
  });

  testWidgets('getApplicationCacheDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationCachePath();
    _verifySampleFile(result, 'applicationCache');
  });
}

/// Verify a file called [name] in [directoryPath] by recreating it with test
/// contents when necessary.
void _verifySampleFile(String? directoryPath, String name) {
  expect(directoryPath, isNotNull);
  if (directoryPath == null) {
    return;
  }
  final Directory directory = Directory(directoryPath);
  final File file = File('${directory.path}${Platform.pathSeparator}$name');

  if (file.existsSync()) {
    file.deleteSync();
    expect(file.existsSync(), isFalse);
  }

  file.writeAsStringSync('Hello world!');
  expect(file.readAsStringSync(), 'Hello world!');
  expect(directory.listSync(), isNotEmpty);
  file.deleteSync();
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path_provider_linux/path_provider_linux.dart';

void main() {
  runApp(const MyApp());
}

/// Sample app
class MyApp extends StatefulWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _tempDirectory = 'Unknown';
  String? _downloadsDirectory = 'Unknown';
  String? _appSupportDirectory = 'Unknown';
  String? _appCacheDirectory = 'Unknown';
  String? _documentsDirectory = 'Unknown';
  final PathProviderLinux _provider = PathProviderLinux();

  @override
  void initState() {
    super.initState();
    initDirectories();
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initDirectories() async {
    String? tempDirectory;
    String? downloadsDirectory;
    String? appSupportDirectory;
    String? appCacheDirectory;
    String? documentsDirectory;
    // Platform messages may fail, so we use a try/catch PlatformException.
    try {
      tempDirectory = await _provider.getTemporaryPath();
    } on PlatformException {
      tempDirectory = 'Failed to get temp directory.';
    }
    try {
      downloadsDirectory = await _provider.getDownloadsPath();
    } on PlatformException {
      downloadsDirectory = 'Failed to get downloads directory.';
    }

    try {
      documentsDirectory = await _provider.getApplicationDocumentsPath();
    } on PlatformException {
      documentsDirectory = 'Failed to get documents directory.';
    }

    try {
      appSupportDirectory = await _provider.getApplicationSupportPath();
    } on PlatformException {
      appSupportDirectory = 'Failed to get documents directory.';
    }

    try {
      appCacheDirectory = await _provider.getApplicationCachePath();
    } on PlatformException {
      appCacheDirectory = 'Failed to get cache directory.';
    }
    // If the widget was removed from the tree while the asynchronous platform
    // message was in flight, we want to discard the reply rather than calling
    // setState to update our non-existent appearance.
    if (!mounted) {
      return;
    }

    setState(() {
      _tempDirectory = tempDirectory;
      _downloadsDirectory = downloadsDirectory;
      _appSupportDirectory = appSupportDirectory;
      _appCacheDirectory = appCacheDirectory;
      _documentsDirectory = documentsDirectory;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Path Provider Linux example app'),
        ),
        body: Center(
          child: Column(
            children: <Widget>[
              Text('Temp Directory: $_tempDirectory\n'),
              Text('Documents Directory: $_documentsDirectory\n'),
              Text('Downloads Directory: $_downloadsDirectory\n'),
              Text('Application Support Directory: $_appSupportDirectory\n'),
              Text('Application Cache Directory: $_appCacheDirectory\n'),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\pubspec.yaml =====
name: pathproviderexample
description: Demonstrates how to use the path_provider_linux plugin.
publish_to: "none"

environment:
  sdk: ">=2.19.0 <4.0.0"
  flutter: ">=3.7.0"

dependencies:
  flutter:
    sdk: flutter

  path_provider_linux:
    # When depending on this package from a real application you should use:
    #   path_provider_linux: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ../

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// getApplicationId() is implemented using FFI; export a stub for platforms
// that don't support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'get_application_id_stub.dart'
    if (dart.library.ffi) 'get_application_id_real.dart';
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id_real.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;

// GApplication* g_application_get_default();
typedef _GApplicationGetDefaultC = IntPtr Function();
typedef _GApplicationGetDefaultDart = int Function();

// const gchar* g_application_get_application_id(GApplication* application);
typedef _GApplicationGetApplicationIdC = Pointer<Utf8> Function(IntPtr);
typedef _GApplicationGetApplicationIdDart = Pointer<Utf8> Function(int);

/// Interface for interacting with libgio.
@visibleForTesting
class GioUtils {
  /// Creates a default instance that uses the real libgio.
  GioUtils() {
    try {
      _gio = DynamicLibrary.open('libgio-2.0.so');
    } on ArgumentError {
      _gio = null;
    }
  }

  DynamicLibrary? _gio;

  /// True if libgio was opened successfully.
  bool get libraryIsPresent => _gio != null;

  /// Wraps `g_application_get_default`.
  int gApplicationGetDefault() {
    if (_gio == null) {
      return 0;
    }
    final _GApplicationGetDefaultDart getDefault = _gio!
        .lookupFunction<_GApplicationGetDefaultC, _GApplicationGetDefaultDart>(
            'g_application_get_default');
    return getDefault();
  }

  /// Wraps g_application_get_application_id.
  Pointer<Utf8> gApplicationGetApplicationId(int app) {
    if (_gio == null) {
      return nullptr;
    }
    final _GApplicationGetApplicationIdDart gApplicationGetApplicationId = _gio!
        .lookupFunction<_GApplicationGetApplicationIdC,
                _GApplicationGetApplicationIdDart>(
            'g_application_get_application_id');
    return gApplicationGetApplicationId(app);
  }
}

/// Allows overriding the default GioUtils instance with a fake for testing.
@visibleForTesting
GioUtils? gioUtilsOverride;

/// Gets the application ID for this app.
String? getApplicationId() {
  final GioUtils gio = gioUtilsOverride ?? GioUtils();
  if (!gio.libraryIsPresent) {
    return null;
  }

  final int app = gio.gApplicationGetDefault();
  if (app == 0) {
    return null;
  }
  final Pointer<Utf8> appId = gio.gApplicationGetApplicationId(app);
  if (appId == nullptr) {
    return null;
  }
  return appId.toDartString();
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id_stub.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Gets the application ID for this app.
String? getApplicationId() => null;
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\path_provider_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:xdg_directories/xdg_directories.dart' as xdg;

import 'get_application_id.dart';

/// The linux implementation of [PathProviderPlatform]
///
/// This class implements the `package:path_provider` functionality for Linux.
class PathProviderLinux extends PathProviderPlatform {
  /// Constructs an instance of [PathProviderLinux]
  PathProviderLinux() : _environment = Platform.environment;

  /// Constructs an instance of [PathProviderLinux] with the given [environment]
  @visibleForTesting
  PathProviderLinux.private(
      {Map<String, String> environment = const <String, String>{},
      String? executableName,
      String? applicationId})
      : _environment = environment,
        _executableName = executableName,
        _applicationId = applicationId;

  final Map<String, String> _environment;
  String? _executableName;
  String? _applicationId;

  /// Registers this class as the default instance of [PathProviderPlatform]
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderLinux();
  }

  @override
  Future<String?> getTemporaryPath() {
    final String environmentTmpDir = _environment['TMPDIR'] ?? '';
    return Future<String?>.value(
      environmentTmpDir.isEmpty ? '/tmp' : environmentTmpDir,
    );
  }

  @override
  Future<String?> getApplicationSupportPath() async {
    final Directory directory =
        Directory(path.join(xdg.dataHome.path, await _getId()));
    if (directory.existsSync()) {
      return directory.path;
    }

    // This plugin originally used the executable name as a directory.
    // Use that if it exists for backwards compatibility.
    final Directory legacyDirectory =
        Directory(path.join(xdg.dataHome.path, await _getExecutableName()));
    if (legacyDirectory.existsSync()) {
      return legacyDirectory.path;
    }

    // Create the directory, because mobile implementations assume the directory exists.
    await directory.create(recursive: true);
    return directory.path;
  }

  @override
  Future<String?> getApplicationDocumentsPath() {
    return Future<String?>.value(xdg.getUserDirectory('DOCUMENTS')?.path);
  }

  @override
  Future<String?> getApplicationCachePath() async {
    final Directory directory =
        Directory(path.join(xdg.cacheHome.path, await _getId()));
    if (!directory.existsSync()) {
      await directory.create(recursive: true);
    }
    return directory.path;
  }

  @override
  Future<String?> getDownloadsPath() {
    return Future<String?>.value(xdg.getUserDirectory('DOWNLOAD')?.path);
  }

  // Gets the name of this executable.
  Future<String> _getExecutableName() async {
    _executableName ??= path.basenameWithoutExtension(
        await File('/proc/self/exe').resolveSymbolicLinks());
    return _executableName!;
  }

  // Gets the unique ID for this application.
  Future<String> _getId() async {
    _applicationId ??= getApplicationId();
    // If no application ID then fall back to using the executable name.
    return _applicationId ?? await _getExecutableName();
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\path_provider_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

export 'src/path_provider_linux.dart';
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\test\get_application_id_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/src/get_application_id_real.dart';

class _FakeGioUtils implements GioUtils {
  int? application;
  Pointer<Utf8>? applicationId;

  @override
  bool libraryIsPresent = false;

  @override
  int gApplicationGetDefault() => application!;

  @override
  Pointer<Utf8> gApplicationGetApplicationId(int app) => applicationId!;
}

void main() {
  late _FakeGioUtils fakeGio;

  setUp(() {
    fakeGio = _FakeGioUtils();
    gioUtilsOverride = fakeGio;
  });

  tearDown(() {
    gioUtilsOverride = null;
  });

  test('returns null if libgio is not available', () {
    expect(getApplicationId(), null);
  });

  test('returns null if g_paplication_get_default returns 0', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 0;
    expect(getApplicationId(), null);
  });

  test('returns null if g_application_get_application_id returns nullptr', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 1;
    fakeGio.applicationId = nullptr;
    expect(getApplicationId(), null);
  });

  test('returns value if g_application_get_application_id returns a value', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 1;
    const String id = 'foo';
    final Pointer<Utf8> idPtr = id.toNativeUtf8();
    fakeGio.applicationId = idPtr;
    expect(getApplicationId(), id);
    calloc.free(idPtr);
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\test\path_provider_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:xdg_directories/xdg_directories.dart' as xdg;

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  PathProviderLinux.registerWith();

  test('registered instance', () {
    expect(PathProviderPlatform.instance, isA<PathProviderLinux>());
  });

  test('getTemporaryPath defaults to TMPDIR', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{'TMPDIR': '/run/user/0/tmp'},
    );
    expect(await plugin.getTemporaryPath(), '/run/user/0/tmp');
  });

  test('getTemporaryPath uses fallback if TMPDIR is empty', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{'TMPDIR': ''},
    );
    expect(await plugin.getTemporaryPath(), '/tmp');
  });

  test('getTemporaryPath uses fallback if TMPDIR is unset', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{},
    );
    expect(await plugin.getTemporaryPath(), '/tmp');
  });

  test('getApplicationSupportPath', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary',
        applicationId: 'com.example.Test');
    // Note this will fail if ${xdg.dataHome.path}/path_provider_linux_test_binary exists on the local filesystem.
    expect(await plugin.getApplicationSupportPath(),
        '${xdg.dataHome.path}/com.example.Test');
  });

  test('getApplicationSupportPath uses executable name if no application Id',
      () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary');
    expect(await plugin.getApplicationSupportPath(),
        '${xdg.dataHome.path}/path_provider_linux_test_binary');
  });

  test('getApplicationDocumentsPath', () async {
    final PathProviderPlatform plugin = PathProviderPlatform.instance;
    expect(await plugin.getApplicationDocumentsPath(), startsWith('/'));
  });

  test('getApplicationCachePath', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary');
    expect(await plugin.getApplicationCachePath(),
        '${xdg.cacheHome.path}/path_provider_linux_test_binary');
  });

  test('getDownloadsPath', () async {
    final PathProviderPlatform plugin = PathProviderPlatform.instance;
    expect(await plugin.getDownloadsPath(), startsWith('/'));
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\pubspec.yaml =====
name: path_provider_linux
description: Linux implementation of the path_provider plugin
repository: https://github.com/flutter/packages/tree/main/packages/path_provider/path_provider_linux
issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+path_provider%22
version: 2.2.1

environment:
  sdk: ">=2.19.0 <4.0.0"
  flutter: ">=3.7.0"

flutter:
  plugin:
    implements: path_provider
    platforms:
      linux:
        dartPluginClass: PathProviderLinux

dependencies:
  ffi: ">=1.1.2 <3.0.0"
  flutter:
    sdk: flutter
  path: ^1.8.0
  path_provider_platform_interface: ^2.1.0
  xdg_directories: ">=0.2.0 <2.0.0"

dev_dependencies:
  flutter_test:
    sdk: flutter

topics:
  - files
  - path-provider
  - paths
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\integration_test\shared_preferences_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('SharedPreferencesLinux', () {
    late SharedPreferencesLinux preferences;

    const Map<String, Object> flutterTestValues = <String, Object>{
      'flutter.String': 'hello world',
      'flutter.Bool': true,
      'flutter.Int': 42,
      'flutter.Double': 3.14159,
      'flutter.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> prefixTestValues = <String, Object>{
      'prefix.String': 'hello world',
      'prefix.Bool': true,
      'prefix.Int': 42,
      'prefix.Double': 3.14159,
      'prefix.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> nonPrefixTestValues = <String, Object>{
      'String': 'hello world',
      'Bool': true,
      'Int': 42,
      'Double': 3.14159,
      'StringList': <String>['foo', 'bar'],
    };

    final Map<String, Object> allTestValues = <String, Object>{};

    allTestValues.addAll(flutterTestValues);
    allTestValues.addAll(prefixTestValues);
    allTestValues.addAll(nonPrefixTestValues);

    Future<void> addData() async {
      await preferences.setValue('String', 'String', allTestValues['String']!);
      await preferences.setValue('Bool', 'Bool', allTestValues['Bool']!);
      await preferences.setValue('Int', 'Int', allTestValues['Int']!);
      await preferences.setValue('Double', 'Double', allTestValues['Double']!);
      await preferences.setValue(
          'StringList', 'StringList', allTestValues['StringList']!);
      await preferences.setValue(
          'String', 'prefix.String', allTestValues['prefix.String']!);
      await preferences.setValue(
          'Bool', 'prefix.Bool', allTestValues['prefix.Bool']!);
      await preferences.setValue(
          'Int', 'prefix.Int', allTestValues['prefix.Int']!);
      await preferences.setValue(
          'Double', 'prefix.Double', allTestValues['prefix.Double']!);
      await preferences.setValue('StringList', 'prefix.StringList',
          allTestValues['prefix.StringList']!);
      await preferences.setValue(
          'String', 'flutter.String', allTestValues['flutter.String']!);
      await preferences.setValue(
          'Bool', 'flutter.Bool', allTestValues['flutter.Bool']!);
      await preferences.setValue(
          'Int', 'flutter.Int', allTestValues['flutter.Int']!);
      await preferences.setValue(
          'Double', 'flutter.Double', allTestValues['flutter.Double']!);
      await preferences.setValue('StringList', 'flutter.StringList',
          allTestValues['flutter.StringList']!);
    }

    setUp(() async {
      preferences = SharedPreferencesLinux();
      await addData();
    });

    tearDown(() async {
      await preferences.clearWithParameters(
        ClearParameters(
          filter: PreferencesFilter(prefix: ''),
        ),
      );
    });

    testWidgets('getAll', (WidgetTester _) async {
      final Map<String, Object> values = await preferences.getAll();
      expect(values['flutter.String'], allTestValues['flutter.String']);
      expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
      expect(values['flutter.Int'], allTestValues['flutter.Int']);
      expect(values['flutter.Double'], allTestValues['flutter.Double']);
      expect(values['flutter.StringList'], allTestValues['flutter.StringList']);
    });

    group('withPrefix', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('prefix.');
        Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithPrefix('flutter.');
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('');
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });

    group('withParameters', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('get all with allow list', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.String'},
            ),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters with allow list',
          (WidgetTester _) async {
        await addData();
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.StringList'},
            ),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });
  });

  group('shared_preferences_async', () {
    const SharedPreferencesLinuxOptions emptyOptions =
        SharedPreferencesLinuxOptions();

    const String stringKey = 'testString';
    const String boolKey = 'testBool';
    const String intKey = 'testInt';
    const String doubleKey = 'testDouble';
    const String listKey = 'testList';

    const String testString = 'hello world';
    const bool testBool = true;
    const int testInt = 42;
    const double testDouble = 3.14159;
    const List<String> testList = <String>['foo', 'bar'];

    Future<SharedPreferencesAsyncPlatform> getPreferences(
        {bool clear = true}) async {
      final SharedPreferencesAsyncPlatform preferences =
          SharedPreferencesAsyncPlatform.instance!;
      if (clear) {
        await preferences.clear(
            const ClearPreferencesParameters(filter: PreferencesFilters()),
            emptyOptions);
      }
      return preferences;
    }

    testWidgets('set and get String', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setString(stringKey, testString, emptyOptions);
      expect(await preferences.getString(stringKey, emptyOptions), testString);
    });

    testWidgets('set and get bool', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setBool(boolKey, testBool, emptyOptions);
      expect(await preferences.getBool(boolKey, emptyOptions), testBool);
    });

    testWidgets('set and get int', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setInt(intKey, testInt, emptyOptions);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
    });

    testWidgets('set and get double', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    });

    testWidgets('set and get StringList', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
    testWidgets('getStringList does not throw cast error',
        (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      await (preferences as SharedPreferencesAsyncLinux).reload(emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList returns mutable list', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      final List<String>? list =
          await preferences.getStringList(listKey, emptyOptions);
      list?.add('value');
      expect(list?.length, testList.length + 1);
    });

    testWidgets('getPreferences', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(gotAll.length, 5);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
      expect(gotAll[intKey], testInt);
      expect(gotAll[doubleKey], testDouble);
      expect(gotAll[listKey], testList);
    });

    testWidgets('getPreferences with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(gotAll.length, 2);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
    });

    testWidgets('getKeys', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(keys.length, 5);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
      expect(keys, contains(intKey));
      expect(keys, contains(doubleKey));
      expect(keys, contains(listKey));
    });

    testWidgets('getKeys with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(keys.length, 2);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
    });

    testWidgets('clear', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), null);
      expect(await preferences.getDouble(doubleKey, emptyOptions), null);
      expect(await preferences.getStringList(listKey, emptyOptions), null);
    });

    testWidgets('clear with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);
      await preferences.clear(
        const ClearPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );
      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'SharedPreferences Demo',
      home: SharedPreferencesDemo(),
    );
  }
}

class SharedPreferencesDemo extends StatefulWidget {
  const SharedPreferencesDemo({super.key});

  @override
  SharedPreferencesDemoState createState() => SharedPreferencesDemoState();
}

class SharedPreferencesDemoState extends State<SharedPreferencesDemo> {
  final SharedPreferencesAsyncPlatform? _prefs =
      SharedPreferencesAsyncPlatform.instance;
  final SharedPreferencesLinuxOptions options =
      const SharedPreferencesLinuxOptions();
  static const String _counterKey = 'counter';
  late Future<int> _counter;

  Future<void> _incrementCounter() async {
    final int? value = await _prefs!.getInt(_counterKey, options);
    final int counter = (value ?? 0) + 1;

    setState(() {
      _counter = _prefs.setInt(_counterKey, counter, options).then((_) {
        return counter;
      });
    });
  }

  Future<void> _getAndSetCounter() async {
    setState(() {
      _counter = _prefs!.getInt(_counterKey, options).then((int? counter) {
        return counter ?? 0;
      });
    });
  }

  @override
  void initState() {
    super.initState();
    _getAndSetCounter();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SharedPreferences Demo'),
      ),
      body: Center(
          child: FutureBuilder<int>(
              future: _counter,
              builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
                switch (snapshot.connectionState) {
                  case ConnectionState.none:
                  case ConnectionState.waiting:
                    return const CircularProgressIndicator();
                  case ConnectionState.active:
                  case ConnectionState.done:
                    if (snapshot.hasError) {
                      return Text('Error: ${snapshot.error}');
                    } else {
                      return Text(
                        'Button tapped ${snapshot.data} time${snapshot.data == 1 ? '' : 's'}.\n\n'
                        'This should persist across restarts.',
                      );
                    }
                }
              })),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\pubspec.yaml =====
name: shared_preferences_linux_example
description: Demonstrates how to use the shared_preferences_linux plugin.
publish_to: none

environment:
  sdk: ^3.3.0
  flutter: ">=3.19.0"

dependencies:
  flutter:
    sdk: flutter
  shared_preferences_linux:
    # When depending on this package from a real application you should use:
    #   shared_preferences_linux: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ../
  shared_preferences_platform_interface: ^2.4.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\lib\shared_preferences_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:convert' show json;

import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:path/path.dart' as path;
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

const String _defaultFileName = 'shared_preferences';

const String _defaultPrefix = 'flutter.';

/// The Linux implementation of [SharedPreferencesStorePlatform].
///
/// This class implements the `package:shared_preferences` functionality for Linux.
class SharedPreferencesLinux extends SharedPreferencesStorePlatform {
  /// Deprecated instance of [SharedPreferencesLinux].
  /// Use [SharedPreferencesStorePlatform.instance] instead.
  @Deprecated('Use `SharedPreferencesStorePlatform.instance` instead.')
  static SharedPreferencesLinux instance = SharedPreferencesLinux();

  /// Registers the Linux implementation.
  static void registerWith() {
    SharedPreferencesStorePlatform.instance = SharedPreferencesLinux();
    // A temporary work-around for having two plugins contained in a single package.
    SharedPreferencesAsyncLinux.registerWith();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_linux instance used to find the support directory.
  @visibleForTesting
  PathProviderLinux pathProvider = PathProviderLinux();

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences() async {
    _cachedPreferences ??= await _reload(
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }

  @override
  Future<bool> clear() async {
    return clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<bool> clearWithPrefix(String prefix) async {
    return clearWithParameters(
        ClearParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<bool> clearWithParameters(ClearParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;

    final Map<String, Object> preferences = await _readPreferences();
    preferences.removeWhere((String key, _) =>
        key.startsWith(filter.prefix) &&
        (filter.allowList == null || filter.allowList!.contains(key)));
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getAll() async {
    return getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<Map<String, Object>> getAllWithPrefix(String prefix) async {
    return getAllWithParameters(
        GetAllParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<Map<String, Object>> getAllWithParameters(
      GetAllParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;
    final Map<String, Object> withPrefix =
        Map<String, Object>.from(await _readPreferences());
    withPrefix.removeWhere((String key, _) => !(key.startsWith(filter.prefix) &&
        (filter.allowList?.contains(key) ?? true)));
    return withPrefix;
  }

  @override
  Future<bool> remove(String key) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences.remove(key);
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<bool> setValue(String valueType, String key, Object value) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences[key] = value;
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }
}

/// The Linux implementation of [SharedPreferencesAsyncPlatform].
///
/// This class implements the `package:shared_preferences` functionality for Linux.
base class SharedPreferencesAsyncLinux extends SharedPreferencesAsyncPlatform {
  /// Registers the Linux implementation.
  static void registerWith() {
    SharedPreferencesAsyncPlatform.instance = SharedPreferencesAsyncLinux();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_linux instance used to find the support directory.
  @visibleForTesting
  PathProviderLinux pathProvider = PathProviderLinux();

  @override
  Future<Set<String>> getKeys(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return (await getPreferences(parameters, options)).keys.toSet();
  }

  @override
  Future<void> setString(
    String key,
    String value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setBool(
    String key,
    bool value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setDouble(
    String key,
    double value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setInt(
    String key,
    int value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setStringList(
    String key,
    List<String> value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<String?> getString(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as String?;
  }

  @override
  Future<bool?> getBool(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as bool?;
  }

  @override
  Future<double?> getDouble(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as double?;
  }

  @override
  Future<int?> getInt(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as int?;
  }

  @override
  Future<List<String>?> getStringList(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return (data[key] as List<Object?>?)?.cast<String>().toList();
  }

  @override
  Future<void> clear(ClearPreferencesParameters parameters,
      SharedPreferencesOptions options) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final PreferencesFilters filter = parameters.filter;
    final Map<String, Object> preferences =
        await _readPreferences(linuxOptions.fileName);
    preferences.removeWhere((String key, _) =>
        filter.allowList == null || filter.allowList!.contains(key));
    await _writePreferences(
      preferences,
      linuxOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getPreferences(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return _readAll(parameters.filter.allowList, options);
  }

  /// Reloads preferences from file.
  @visibleForTesting
  Future<void> reload(
    SharedPreferencesLinuxOptions options,
  ) async {
    _cachedPreferences = await _reload(options.fileName);
  }

  Future<Map<String, Object>> _readAll(
    Set<String>? allowList,
    SharedPreferencesOptions options,
  ) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> prefs =
        Map<String, Object>.from(await _readPreferences(linuxOptions.fileName));
    prefs.removeWhere((String key, _) => !(allowList?.contains(key) ?? true));
    return prefs;
  }

  Future<void> _setValue(
      String key, Object value, SharedPreferencesOptions options) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> preferences =
        await _readPreferences(linuxOptions.fileName);
    preferences[key] = value;
    await _writePreferences(
      preferences,
      linuxOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences(String fileName) async {
    _cachedPreferences ??= await _reload(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }
}

/// Gets the file where the preferences are stored.
Future<File?> _getLocalDataFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  pathProvider = pathProvider ?? PathProviderLinux();
  final String? directory = await pathProvider.getApplicationSupportPath();
  if (directory == null) {
    return null;
  }
  final String fileLocation = path.join(directory, '$fileName.json');
  return fs.file(fileLocation);
}

/// Gets the preferences from the stored file and saves them in cache.
Future<Map<String, Object>> _reload(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  Map<String, Object> preferences = <String, Object>{};
  final File? localDataFile = await _getLocalDataFile(
    fileName,
    fs: fs,
    pathProvider: pathProvider,
  );
  if (localDataFile != null && localDataFile.existsSync()) {
    final String stringMap = localDataFile.readAsStringSync();
    if (stringMap.isNotEmpty) {
      final Object? data = json.decode(stringMap);
      if (data is Map) {
        preferences = data.cast<String, Object>();
      }
    }
  }
  return preferences;
}

/// Writes the cached preferences to disk. Returns [true] if the operation
/// succeeded.
Future<bool> _writePreferences(
  Map<String, Object> preferences,
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  try {
    final File? localDataFile = await _getLocalDataFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    if (localDataFile == null) {
      debugPrint('Unable to determine where to write preferences.');
      return false;
    }
    if (!localDataFile.existsSync()) {
      localDataFile.createSync(recursive: true);
    }
    final String stringMap = json.encode(preferences);
    localDataFile.writeAsStringSync(stringMap);
  } catch (e) {
    debugPrint('Error saving preferences to disk: $e');
    return false;
  }
  return true;
}

/// Linux specific SharedPreferences Options.
class SharedPreferencesLinuxOptions extends SharedPreferencesOptions {
  /// Constructor for SharedPreferencesLinuxOptions.
  const SharedPreferencesLinuxOptions({
    this.fileName = 'shared_preferences',
  });

  /// The name of the file to store preferences in.
  final String fileName;

  /// Returns a new instance of [SharedPreferencesLinuxOptions] from an existing
  /// [SharedPreferencesOptions].
  static SharedPreferencesLinuxOptions fromSharedPreferencesOptions(
      SharedPreferencesOptions options) {
    if (options is SharedPreferencesLinuxOptions) {
      return options;
    }
    return const SharedPreferencesLinuxOptions();
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\fake_path_provider_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

/// Fake implementation of PathProviderLinux that returns hard-coded paths,
/// allowing tests to run on any platform.
///
/// Note that this should only be used with an in-memory filesystem, as the
/// path it returns is a root path that does not actually exist on Linux.
class FakePathProviderLinux extends PathProviderPlatform
    implements PathProviderLinux {
  @override
  Future<String?> getApplicationSupportPath() async => r'/appsupport';

  @override
  Future<String?> getTemporaryPath() async => null;

  @override
  Future<String?> getLibraryPath() async => null;

  @override
  Future<String?> getApplicationDocumentsPath() async => null;

  @override
  Future<String?> getDownloadsPath() async => null;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\legacy_shared_preferences_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'dart:convert';

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

import 'fake_path_provider_linux.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderLinux pathProvider;

  SharedPreferencesLinux.registerWith();

  const Map<String, Object> flutterTestValues = <String, Object>{
    'flutter.String': 'hello world',
    'flutter.Bool': true,
    'flutter.Int': 42,
    'flutter.Double': 3.14159,
    'flutter.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> prefixTestValues = <String, Object>{
    'prefix.String': 'hello world',
    'prefix.Bool': true,
    'prefix.Int': 42,
    'prefix.Double': 3.14159,
    'prefix.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> nonPrefixTestValues = <String, Object>{
    'String': 'hello world',
    'Bool': true,
    'Int': 42,
    'Double': 3.14159,
    'StringList': <String>['foo', 'bar'],
  };

  final Map<String, Object> allTestValues = <String, Object>{};

  allTestValues.addAll(flutterTestValues);
  allTestValues.addAll(prefixTestValues);
  allTestValues.addAll(nonPrefixTestValues);

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderLinux();
  });

  Future<String> getFilePath() async {
    final String? directory = await pathProvider.getApplicationSupportPath();
    return path.join(directory!, 'shared_preferences.json');
  }

  Future<void> writeTestFile(String value) async {
    fs.file(await getFilePath())
      ..createSync(recursive: true)
      ..writeAsStringSync(value);
  }

  Future<String> readTestFile() async {
    return fs.file(await getFilePath()).readAsStringSync();
  }

  SharedPreferencesLinux getPreferences() {
    final SharedPreferencesLinux prefs = SharedPreferencesLinux();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('registered instance', () async {
    SharedPreferencesLinux.registerWith();
    expect(
        SharedPreferencesStorePlatform.instance, isA<SharedPreferencesLinux>());
  });

  test('getAll', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('prefix.');
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with allow list', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String?, Object?> all = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.Bool'},
        ),
      ),
    );
    expect(all.length, 1);
    expect(all['prefix.Bool'], prefixTestValues['prefix.Bool']);
  });

  test('remove', () async {
    await writeTestFile('{"key1":"one","key2":2}');
    final SharedPreferencesLinux prefs = getPreferences();

    await prefs.remove('key2');

    expect(await readTestFile(), '{"key1":"one"}');
  });

  test('setValue', () async {
    await writeTestFile('{}');
    final SharedPreferencesLinux prefs = getPreferences();

    await prefs.setValue('', 'key1', 'one');
    await prefs.setValue('', 'key2', 2);

    expect(await readTestFile(), '{"key1":"one","key2":2}');
  });

  test('clear', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    expect(await readTestFile(), json.encode(flutterTestValues));
    await prefs.clear();
    expect(await readTestFile(), '{}');
  });

  test('clearWithPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithPrefix('prefix.');
    final Map<String, Object> noValues =
        await prefs.getAllWithPrefix('prefix.');
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('');
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithPrefix('');
    final Map<String, Object> noValues = await prefs.getAllWithPrefix('');
    expect(noValues, hasLength(0));
  });

  test('clearWithParameters', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('clearWithParameters with allow list', () async {
    await writeTestFile(json.encode(prefixTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.StringList'},
        ),
      ),
    );
    final Map<String, Object> someValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(someValues, hasLength(4));
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(noValues, hasLength(0));
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\shared_preferences_linux_async_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/types.dart';

import 'fake_path_provider_linux.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderLinux pathProvider;

  SharedPreferencesAsyncLinux.registerWith();

  const String stringKey = 'testString';
  const String boolKey = 'testBool';
  const String intKey = 'testInt';
  const String doubleKey = 'testDouble';
  const String listKey = 'testList';

  const String testString = 'hello world';
  const bool testBool = true;
  const int testInt = 42;
  const double testDouble = 3.14159;
  const List<String> testList = <String>['foo', 'bar'];

  const SharedPreferencesLinuxOptions emptyOptions =
      SharedPreferencesLinuxOptions();

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderLinux();
  });

  SharedPreferencesAsyncLinux getPreferences() {
    final SharedPreferencesAsyncLinux prefs = SharedPreferencesAsyncLinux();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('set and get String', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), testString);
  });

  test('set and get bool', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setBool(boolKey, testBool, emptyOptions);
    expect(await preferences.getBool(boolKey, emptyOptions), testBool);
  });

  test('set and get int', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setInt(intKey, testInt, emptyOptions);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
  });

  test('set and get double', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
  });

  test('set and get StringList', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setStringList(listKey, testList, emptyOptions);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });

  test('getPreferences', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);

    expect(gotAll.length, 5);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
    expect(gotAll[intKey], testInt);
    expect(gotAll[doubleKey], testDouble);
    expect(gotAll[listKey], testList);
  });

  test('getPreferences with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
            filter:
                PreferencesFilters(allowList: <String>{stringKey, boolKey})),
        emptyOptions);

    expect(gotAll.length, 2);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
  });

  test('getKeys', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(filter: PreferencesFilters()),
      emptyOptions,
    );

    expect(keys.length, 5);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
    expect(keys, contains(intKey));
    expect(keys, contains(doubleKey));
    expect(keys, contains(listKey));
  });

  test('getKeys with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );

    expect(keys.length, 2);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
  });

  test('clear', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), null);
    expect(await preferences.getDouble(doubleKey, emptyOptions), null);
    expect(await preferences.getStringList(listKey, emptyOptions), null);
  });

  test('clear with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
      const ClearPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\pubspec.yaml =====
name: shared_preferences_linux
description: Linux implementation of the shared_preferences plugin
repository: https://github.com/flutter/packages/tree/main/packages/shared_preferences/shared_preferences_linux
issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+shared_preferences%22
version: 2.4.1

environment:
  sdk: ^3.3.0
  flutter: ">=3.19.0"

flutter:
  plugin:
    implements: shared_preferences
    platforms:
      linux:
        dartPluginClass: SharedPreferencesLinux

dependencies:
  file: ">=6.0.0 <8.0.0"
  flutter:
    sdk: flutter
  path: ^1.8.0
  path_provider_linux: ^2.0.0
  path_provider_platform_interface: ^2.0.0
  shared_preferences_platform_interface: ^2.4.0

dev_dependencies:
  flutter_test:
    sdk: flutter

topics:
  - persistence
  - shared-preferences
  - storage
===== C:\Users\target\Depi\graduation_project\Team-dpi-\macos\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json =====
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\test\widget_test.dart =====
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:depi_project/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const DEPI());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\web\manifest.json =====
{
    "name": "depi_project",
    "short_name": "depi_project",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\android\src\main\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="io.flutter.plugins.firebase.firestore">
    <application>
        <service android:name="com.google.firebase.components.ComponentDiscoveryService">
            <meta-data android:name="com.google.firebase.components:io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestoreRegistrar"
                       android:value="com.google.firebase.components.ComponentRegistrar" />
        </service>
    </application>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\dartpad\lib\main.dart =====
// ignore_for_file: prefer_const_constructors_in_immutables,unnecessary_const,library_private_types_in_public_api,avoid_print
// Copyright 2021, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: defaultFirebaseOptions);
  runApp(FirestoreExampleApp());
}

/// A reference to the list of movies.
/// We are using `withConverter` to ensure that interactions with the collection
/// are type-safe.
final moviesRef = FirebaseFirestore.instance
    .collection('firestore-example-app')
    .withConverter<Movie>(
      fromFirestore: (snapshots, _) => Movie.fromJson(snapshots.data()!),
      toFirestore: (movie, _) => movie.toJson(),
    );

/// The different ways that we can filter/sort movies.
enum MovieQuery {
  year,
  likesAsc,
  likesDesc,
  score,
  sciFi,
  fantasy,
}

extension on Query<Movie> {
  /// Create a firebase query from a [MovieQuery]
  Query<Movie> queryBy(MovieQuery query) {
    return switch (query) {
      MovieQuery.fantasy => where('genre', arrayContainsAny: ['Fantasy']),
      MovieQuery.sciFi => where('genre', arrayContainsAny: ['Sci-Fi']),
      MovieQuery.likesAsc ||
      MovieQuery.likesDesc =>
        orderBy('likes', descending: query == MovieQuery.likesDesc),
      MovieQuery.year => orderBy('year', descending: true),
      MovieQuery.score => orderBy('score', descending: true)
    };
  }
}

/// The entry point of the application.
///
/// Returns a [MaterialApp].
class FirestoreExampleApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Firestore Example App',
      theme: ThemeData.dark(),
      home: const Scaffold(
        body: Center(child: FilmList()),
      ),
    );
  }
}

/// Holds all example app films
class FilmList extends StatefulWidget {
  const FilmList({Key? key}) : super(key: key);

  @override
  _FilmListState createState() => _FilmListState();
}

class _FilmListState extends State<FilmList> {
  MovieQuery query = MovieQuery.year;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text('Firestore Example: Movies'),

            // This is a example use for 'snapshots in sync'.
            // The view reflects the time of the last Firestore sync; which happens any time a field is updated.
            StreamBuilder(
              stream: FirebaseFirestore.instance.snapshotsInSync(),
              builder: (context, _) {
                return Text(
                  'Latest Snapshot: ${DateTime.now()}',
                  style: Theme.of(context).textTheme.bodySmall,
                );
              },
            ),
          ],
        ),
        actions: <Widget>[
          PopupMenuButton<MovieQuery>(
            onSelected: (value) => setState(() => query = value),
            icon: const Icon(Icons.sort),
            itemBuilder: (BuildContext context) {
              return [
                const PopupMenuItem(
                  value: MovieQuery.year,
                  child: Text('Sort by Year'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.score,
                  child: Text('Sort by Score'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.likesAsc,
                  child: Text('Sort by Likes ascending'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.likesDesc,
                  child: Text('Sort by Likes descending'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.fantasy,
                  child: Text('Filter genre Fantasy'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.sciFi,
                  child: Text('Filter genre Sci-Fi'),
                ),
              ];
            },
          ),
          PopupMenuButton<String>(
            onSelected: (_) => _resetLikes(),
            itemBuilder: (BuildContext context) {
              return [
                const PopupMenuItem(
                  value: 'reset_likes',
                  child: Text('Reset like counts (WriteBatch)'),
                ),
              ];
            },
          ),
        ],
      ),
      body: StreamBuilder<QuerySnapshot<Movie>>(
        stream: moviesRef.queryBy(query).snapshots(),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(
              child: Text(snapshot.error.toString()),
            );
          }

          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          final data = snapshot.requireData;

          return ListView.builder(
            itemCount: data.size,
            itemBuilder: (context, index) {
              return _MovieItem(
                data.docs[index].data(),
                data.docs[index].reference,
              );
            },
          );
        },
      ),
    );
  }

  Future<void> _resetLikes() async {
    final movies = await moviesRef.get();
    WriteBatch batch = FirebaseFirestore.instance.batch();

    for (final movie in movies.docs) {
      batch.update(movie.reference, {'likes': 0});
    }
    await batch.commit();
  }
}

/// A single movie row.
class _MovieItem extends StatelessWidget {
  _MovieItem(this.movie, this.reference);

  final Movie movie;
  final DocumentReference<Movie> reference;

  /// Returns the movie poster.
  Widget get poster {
    return SizedBox(
      width: 100,
      child: Image.network(movie.poster),
    );
  }

  /// Returns movie details.
  Widget get details {
    return Padding(
      padding: const EdgeInsets.only(left: 8, right: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          title,
          metadata,
          genres,
          Likes(
            reference: reference,
            currentLikes: movie.likes,
          ),
        ],
      ),
    );
  }

  /// Return the movie title.
  Widget get title {
    return Text(
      '${movie.title} (${movie.year})',
      style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
    );
  }

  /// Returns metadata about the movie.
  Widget get metadata {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(right: 8),
            child: Text('Rated: ${movie.rated}'),
          ),
          Text('Runtime: ${movie.runtime}'),
        ],
      ),
    );
  }

  /// Returns a list of genre movie tags.
  List<Widget> get genreItems {
    return [
      for (final genre in movie.genre)
        Padding(
          padding: const EdgeInsets.only(right: 2),
          child: Chip(
            backgroundColor: Colors.lightBlue,
            label: Text(
              genre,
              style: const TextStyle(color: Colors.white),
            ),
          ),
        ),
    ];
  }

  /// Returns all genres.
  Widget get genres {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Wrap(
        children: genreItems,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4, top: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          poster,
          Flexible(child: details),
        ],
      ),
    );
  }
}

/// Displays and manages the movie 'like' count.
class Likes extends StatefulWidget {
  /// Constructs a new [Likes] instance with a given [DocumentReference] and
  /// current like count.
  Likes({
    Key? key,
    required this.reference,
    required this.currentLikes,
  }) : super(key: key);

  /// The reference relating to the counter.
  final DocumentReference<Movie> reference;

  /// The number of current likes (before manipulation).
  final int currentLikes;

  @override
  _LikesState createState() => _LikesState();
}

class _LikesState extends State<Likes> {
  /// A local cache of the current likes, used to immediately render the updated
  /// likes count after an update, even while the request isn't completed yet.
  late int _likes = widget.currentLikes;

  Future<void> _onLike() async {
    final currentLikes = _likes;

    // Increment the 'like' count straight away to show feedback to the user.
    setState(() {
      _likes = currentLikes + 1;
    });

    try {
      // Update the likes using a transaction.
      // We use a transaction because multiple users could update the likes count
      // simultaneously. As such, our likes count may be different from the likes
      // count on the server.
      int newLikes = await FirebaseFirestore.instance
          .runTransaction<int>((transaction) async {
        DocumentSnapshot<Movie> movie =
            await transaction.get<Movie>(widget.reference);

        if (!movie.exists) {
          throw Exception('Document does not exist!');
        }

        int updatedLikes = movie.data()!.likes + 1;
        transaction.update(widget.reference, {'likes': updatedLikes});
        return updatedLikes;
      });

      // Update with the real count once the transaction has completed.
      setState(() => _likes = newLikes);
    } catch (e, s) {
      print(s);
      print('Failed to update likes for document! $e');

      // If the transaction fails, revert back to the old count
      setState(() => _likes = currentLikes);
    }
  }

  @override
  void didUpdateWidget(Likes oldWidget) {
    super.didUpdateWidget(oldWidget);
    // The likes on the server changed, so we need to update our local cache to
    // keep things in sync. Otherwise if another user updates the likes,
    // we won't see the update.
    if (widget.currentLikes != oldWidget.currentLikes) {
      _likes = widget.currentLikes;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        IconButton(
          iconSize: 20,
          onPressed: _onLike,
          icon: const Icon(Icons.favorite),
        ),
        Text('$_likes likes'),
      ],
    );
  }
}

@immutable
class Movie {
  Movie({
    required this.genre,
    required this.likes,
    required this.poster,
    required this.rated,
    required this.runtime,
    required this.title,
    required this.year,
  });

  Movie.fromJson(Map<String, Object?> json)
      : this(
          genre: (json['genre']! as List).cast<String>(),
          likes: json['likes']! as int,
          poster: json['poster']! as String,
          rated: json['rated']! as String,
          runtime: json['runtime']! as String,
          title: json['title']! as String,
          year: json['year']! as int,
        );

  final String poster;
  final int likes;
  final String title;
  final int year;
  final String runtime;
  final String rated;
  final List<String> genre;

  Map<String, Object?> toJson() {
    return {
      'genre': genre,
      'likes': likes,
      'poster': poster,
      'rated': rated,
      'runtime': runtime,
      'title': title,
      'year': year,
    };
  }
}

const defaultFirebaseOptions = const FirebaseOptions(
  apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
  appId: '1:406099696497:web:87e25e51afe982cd3574d0',
  messagingSenderId: '406099696497',
  projectId: 'flutterfire-e2e-tests',
  authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
  databaseURL:
      'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
  storageBucket: 'flutterfire-e2e-tests.appspot.com',
  measurementId: 'G-JN95N1JV2E',
);
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\dartpad\dartpad_metadata.yaml =====
name: Cloud Firestore Example
mode: flutter
files:
  - name: lib/main.dart
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\android\app\src\debug\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\android\app\src\main\res\drawable\launch_background.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\android\app\src\main\res\drawable-v21\launch_background.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\android\app\src\main\res\values\styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\android\app\src\main\res\values-night\styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\android\app\src\main\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="example"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\android\app\src\profile\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\android\app\google-services.json =====
{
  "project_info": {
    "project_number": "406099696497",
    "firebase_url": "https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app",
    "project_id": "flutterfire-e2e-tests",
    "storage_bucket": "flutterfire-e2e-tests.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:d86a91cc7b338b233574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.analytics.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:a241c4b471513a203574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.appcheck.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-7bvmqp0fffe24vm2arng0dtdeh2tvkgl.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.appcheck.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:21d5142deea38dda3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.auth.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-emmujnd7g2ammh5uu9ni6v04p4ateqac.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-in8bfp0nali85oul1o98huoar6eo1vv1.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:3ef965ff044efc0b3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.database.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:40da41183cb3d3ff3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dynamiclinksexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:175ea7a64b2faf5e3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.firestore.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:7ca3394493cc601a3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.functions.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:6d1c1fbf4688f39c3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.installations.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:74ebb073d7727cd43574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.messaging.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:f54b85cfa36a39f73574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.remoteconfig.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0d4ed619c031c0ac3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.tests"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ib9hj9281l3343cm3nfvvdotaojrthdc.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-lc54d5l8sp90k39r0bb39ovsgo1s9bek.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:899c6485cfce26c13574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase_ui_example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ltgvphphcckosvqhituel5km2k3aecg8.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase_ui_example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:bc0b12b0605df8633574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecoreexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0f3f7bfe78b8b7103574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecrashlyticsexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:2751af6868a69f073574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasestorageexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\collection_reference_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runCollectionReferenceTests() {
  group('$CollectionReference', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<CollectionReference<Map<String, dynamic>>> initializeTest(
      String id,
    ) async {
      CollectionReference<Map<String, dynamic>> collection =
          firestore.collection('flutter-tests/$id/query-tests');
      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      await Future.forEach(snapshot.docs,
          (DocumentSnapshot<Map<String, dynamic>> documentSnapshot) {
        return documentSnapshot.reference.delete();
      });
      return collection;
    }

    test('add() adds a document', () async {
      CollectionReference<Map<String, dynamic>> collection =
          await initializeTest('collection-reference-add');
      var rand = Random();
      var randNum = rand.nextInt(999999);
      DocumentReference<Map<String, dynamic>> doc = await collection.add({
        'value': randNum,
      });
      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
      expect(randNum, equals(snapshot.data()!['value']));
    });

    test(
      'snapshots() can be reused',
      () async {
        final foo = await initializeTest('foo');

        final snapshot = foo.snapshots();
        final snapshot2 = foo.snapshots();

        expect(
          await snapshot.first,
          isA<QuerySnapshot<Map<String, dynamic>>>()
              .having((e) => e.docs, 'docs', []),
        );
        expect(
          await snapshot2.first,
          isA<QuerySnapshot<Map<String, dynamic>>>()
              .having((e) => e.docs, 'docs', []),
        );

        await foo.add({'value': 42});

        expect(
          await snapshot.first,
          isA<QuerySnapshot<Map<String, dynamic>>>()
              .having((e) => e.docs, 'docs', [
            isA<QueryDocumentSnapshot>()
                .having((e) => e.data(), 'data', {'value': 42}),
          ]),
        );
        expect(
          await snapshot2.first,
          isA<QuerySnapshot<Map<String, dynamic>>>()
              .having((e) => e.docs, 'docs', [
            isA<QueryDocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.data(), 'data', {'value': 42}),
          ]),
        );
      },
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );

    group(
      'withConverter',
      () {
        test(
          'add/snapshot',
          () async {
            final foo = await initializeTest('foo');
            final fooConverter = foo.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            final fooSnapshot = foo.snapshots();
            final fooConverterSnapshot = fooConverter.snapshots();

            await expectLater(
              fooSnapshot,
              emits(
                isA<QuerySnapshot<Map<String, dynamic>>>()
                    .having((e) => e.docs, 'docs', []),
              ),
            );
            await expectLater(
              fooConverterSnapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', []),
              ),
            );

            final newDocument = await fooConverter.add(42);

            await expectLater(
              newDocument.get(),
              completion(
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ),
            );

            await expectLater(
              fooSnapshot,
              emits(
                isA<QuerySnapshot>().having((e) => e.docs, 'docs', [
                  isA<QueryDocumentSnapshot>()
                      .having((e) => e.data(), 'data', {'value': 42}),
                ]),
              ),
            );
            await expectLater(
              fooConverterSnapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                  isA<QueryDocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                ]),
              ),
            );

            await foo.add({'value': 21});

            await expectLater(
              fooSnapshot,
              emits(
                isA<QuerySnapshot>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals([
                    isA<QueryDocumentSnapshot<Map<String, dynamic>>>()
                        .having((e) => e.data(), 'data', {'value': 42}),
                    isA<QueryDocumentSnapshot<Map<String, dynamic>>>()
                        .having((e) => e.data(), 'data', {'value': 21}),
                  ]),
                ),
              ),
            );

            await expectLater(
              fooConverterSnapshot,
              emits(
                isA<QuerySnapshot<int>>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals([
                    isA<QueryDocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 42),
                    isA<QueryDocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 21),
                  ]),
                ),
              ),
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'returning null from `fromFirestore` should not throw a null check error',
          () async {
            final foo = await initializeTest('foo');
            await foo.add({'value': 42});
            final fooConverter = foo.withConverter(
              fromFirestore: (_, __) => null,
              toFirestore: (_, __) => {}, // unused
            );

            final fooConverterSnapshot = fooConverter.snapshots();

            await expectLater(
              fooConverterSnapshot,
              emits(
                // ignore: prefer_void_to_null
                isA<QuerySnapshot<Null>>().having((e) => e.docs, 'docs', [
                  // ignore: prefer_void_to_null
                  isA<QueryDocumentSnapshot<Null>>()
                      .having((e) => e.data(), 'data', null),
                ]),
              ),
            );
          },
        );
      },
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\document_change_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runDocumentChangeTests() {
  group('$DocumentChange', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<CollectionReference<Map<String, dynamic>>> initializeTest(
      String id,
    ) async {
      CollectionReference<Map<String, dynamic>> collection =
          firestore.collection('flutter-tests/$id/query-tests');

      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      await Future.forEach(snapshot.docs,
          (DocumentSnapshot<Map<String, dynamic>> documentSnapshot) {
        return documentSnapshot.reference.delete();
      });
      return collection;
    }

    test(
      'can add/update values to null in the document',
      () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('null-test');
        DocumentReference<Map<String, dynamic>> doc1 = collection.doc('doc1');

        await expectLater(
          doc1.snapshots(),
          emits(
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((q) => q.exists, 'exists', false),
          ),
        );

        await doc1.set(<String, Object?>{
          'key': null,
          'key2': 42,
        });

        await expectLater(
          doc1.snapshots(),
          emits(
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((q) => q.exists, 'exists', true)
                .having((q) => q.data(), 'data()', <String, Object?>{
              'key': null,
              'key2': 42,
            }),
          ),
        );

        await doc1.set({
          'key': null,
          'key2': null,
        });

        await expectLater(
          doc1.snapshots(),
          emits(
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((q) => q.exists, 'exists', true)
                .having((q) => q.data(), 'data()', <String, Object?>{
              'key': null,
              'key2': null,
            }),
          ),
        );
      },
      timeout: const Timeout.factor(8),
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );

    test(
      'returns the correct metadata when adding and removing',
      () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('add-remove-document');
        DocumentReference<Map<String, dynamic>> doc1 = collection.doc('doc1');

        // Set something in the database
        await doc1.set({'name': 'doc1'});

        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.snapshots();
        int call = 0;

        StreamSubscription subscription = stream.listen(
          expectAsync1(
            (QuerySnapshot<Map<String, dynamic>> snapshot) {
              call++;
              if (call == 1) {
                expect(snapshot.docs.length, equals(1));
                expect(snapshot.docChanges.length, equals(1));
                expect(snapshot.docChanges[0], isA<DocumentChange>());
                DocumentChange<Map<String, dynamic>> change =
                    snapshot.docChanges[0];
                expect(change.newIndex, equals(0));
                expect(change.oldIndex, equals(-1));
                expect(change.type, equals(DocumentChangeType.added));
                expect(change.doc.data()!['name'], equals('doc1'));
              } else if (call == 2) {
                expect(snapshot.docs.length, equals(0));
                expect(snapshot.docChanges.length, equals(1));
                expect(snapshot.docChanges[0], isA<DocumentChange>());
                DocumentChange<Map<String, dynamic>> change =
                    snapshot.docChanges[0];
                expect(change.newIndex, equals(-1));
                expect(change.oldIndex, equals(0));
                expect(change.type, equals(DocumentChangeType.removed));
                expect(change.doc.data()!['name'], equals('doc1'));
              } else {
                fail('Should not have been called');
              }
            },
            count: 2,
            reason: 'Stream should only have been called twice.',
          ),
        );

        await Future.delayed(
          const Duration(seconds: 1),
        ); // Ensure listener fires
        await doc1.delete();

        await subscription.cancel();
      },
      skip: defaultTargetPlatform == TargetPlatform.windows ||
          defaultTargetPlatform == TargetPlatform.android,
    );

    test(
      'returns the correct metadata when modifying',
      () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('add-modify-document');
        DocumentReference<Map<String, dynamic>> doc1 = collection.doc('doc1');
        DocumentReference<Map<String, dynamic>> doc2 = collection.doc('doc2');
        DocumentReference<Map<String, dynamic>> doc3 = collection.doc('doc3');

        await doc1.set({'value': 1});
        await doc2.set({'value': 2});
        await doc3.set({'value': 3});
        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.orderBy('value').snapshots();

        int call = 0;
        StreamSubscription subscription = stream.listen(
          expectAsync1(
            (QuerySnapshot<Map<String, dynamic>> snapshot) {
              call++;
              if (call == 1) {
                expect(snapshot.docs.length, equals(3));
                expect(snapshot.docChanges.length, equals(3));
                snapshot.docChanges.asMap().forEach(
                    (int index, DocumentChange<Map<String, dynamic>> change) {
                  expect(change.oldIndex, equals(-1));
                  expect(change.newIndex, equals(index));
                  expect(change.type, equals(DocumentChangeType.added));
                  expect(change.doc.data()!['value'], equals(index + 1));
                });
              } else if (call == 2) {
                expect(snapshot.docs.length, equals(3));
                expect(snapshot.docChanges.length, equals(1));
                DocumentChange<Map<String, dynamic>> change =
                    snapshot.docChanges[0];
                expect(change.oldIndex, equals(0));
                expect(change.newIndex, equals(2));
                expect(change.type, equals(DocumentChangeType.modified));
                expect(change.doc.id, equals('doc1'));
              } else {
                fail('Should not have been called');
              }
            },
            count: 2,
            reason: 'Stream should only have been called twice.',
          ),
        );

        await Future.delayed(
          const Duration(seconds: 1),
        ); // Ensure listener fires
        await doc1.update({'value': 4});

        await subscription.cancel();
      },
      skip: defaultTargetPlatform == TargetPlatform.windows,
    );
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\document_reference_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runDocumentReferenceTests() {
  group('$DocumentReference', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    group(
      'DocumentReference.snapshots()',
      () {
        test('returns a [Stream]', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots();
          expect(stream, isA<Stream<DocumentSnapshot<Map<String, dynamic>>>>());
        });

        test('can be reused', () async {
          final foo = await initializeTest('foo');

          final snapshot = foo.snapshots();
          final snapshot2 = foo.snapshots();

          expect(
            await snapshot.first,
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.exists, 'exists', false),
          );
          expect(
            await snapshot2.first,
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.exists, 'exists', false),
          );

          await foo.set({'value': 42});

          expect(
            await snapshot.first,
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.data(), 'data', {'value': 42}),
          );
          expect(
            await snapshot2.first,
            isA<DocumentSnapshot<Map<String, dynamic>>>()
                .having((e) => e.data(), 'data', {'value': 42}),
          );
        });

        test('listens to a single response', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots();
          StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>?
              subscription;

          subscription = stream.listen(
            expectAsync1(
              (DocumentSnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.exists, isFalse);
              },
              reason: 'Stream should only have been called once.',
            ),
          );

          addTearDown(() async {
            await subscription?.cancel();
          });
        });

        test('listens to a single response from cache', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots(source: ListenSource.cache);
          StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>?
              subscription;

          subscription = stream.listen(
            expectAsync1(
              (DocumentSnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.exists, isFalse);
              },
              reason: 'Stream should only have been called once.',
            ),
          );

          addTearDown(() async {
            await subscription?.cancel();
          });
        });

        test('listens to a document from cache', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot-cache');
          await document.set({'foo': 'bar'});
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots(source: ListenSource.cache);
          StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>?
              subscription;

          subscription = stream.listen(
            expectAsync1(
              (DocumentSnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.exists, isTrue);
                expect(snapshot.data(), equals({'foo': 'bar'}));
              },
              reason: 'Stream should only have been called once.',
            ),
          );

          addTearDown(() async {
            await subscription?.cancel();
          });
        });

        test('listens to multiple documents', () async {
          DocumentReference<Map<String, dynamic>> doc1 =
              await initializeTest('document-snapshot-1');
          DocumentReference<Map<String, dynamic>> doc2 =
              await initializeTest('document-snapshot-2');

          await doc1.set({'test': 'value1'});
          await doc2.set({'test': 'value2'});

          final value1 = doc1.snapshots().first.then((s) => s.data()!['test']);
          final value2 = doc2.snapshots().first.then((s) => s.data()!['test']);

          await expectLater(value1, completion('value1'));
          await expectLater(value2, completion('value2'));
        });

        test('listens to a multiple changes response', () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-snapshot-multiple');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots();
          int call = 0;

          StreamSubscription subscription = stream.listen(
            expectAsync1(
              (DocumentSnapshot<Map<String, dynamic>> snapshot) {
                call++;
                if (call == 1) {
                  expect(snapshot.exists, isFalse);
                } else if (call == 2) {
                  expect(snapshot.exists, isTrue);
                  expect(snapshot.data()!['bar'], equals('baz'));
                } else if (call == 3) {
                  expect(snapshot.exists, isFalse);
                } else if (call == 4) {
                  expect(snapshot.exists, isTrue);
                  expect(snapshot.data()!['foo'], equals('bar'));
                } else if (call == 5) {
                  expect(snapshot.exists, isTrue);
                  expect(snapshot.data()!['foo'], equals('baz'));
                } else {
                  fail('Should not have been called');
                }
              },
              count: 5,
              reason: 'Stream should only have been called five times.',
            ),
          );

          await Future.delayed(
            const Duration(seconds: 1),
          ); // allow stream to return a noop-doc
          await document.set({'bar': 'baz'});
          await document.delete();
          await document.set({'foo': 'bar'});
          await document.update({'foo': 'baz'});

          await subscription.cancel();
          await Future.delayed(
            const Duration(seconds: 1),
          );
        });

        test('listeners throws a [FirebaseException]', () async {
          DocumentReference<Map<String, dynamic>> document =
              firestore.doc('not-allowed/document');
          Stream<DocumentSnapshot<Map<String, dynamic>>> stream =
              document.snapshots();

          try {
            await stream.first;
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }

          fail('Should have thrown a [FirebaseException]');
        });
      },
    );

    group('DocumentReference.delete()', () {
      test('delete() deletes a document', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-delete');
        await document.set({
          'foo': 'bar',
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(snapshot.exists, isTrue);
        await document.delete();
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(snapshot2.exists, isFalse);
      });

      test(
        'throws a [FirebaseException] on error',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              firestore.doc('not-allowed/document');

          try {
            await document.delete();
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }
          fail('Should have thrown a [FirebaseException]');
        },
        //This will fail on web until this is resolved: https://github.com/dart-lang/sdk/issues/52572
        skip: kIsWeb,
      );
    });

    group('DocumentReference.get()', () {
      test('gets a document from server', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-get-server');
        await document.set({'foo': 'bar'});
        DocumentSnapshot<Map<String, dynamic>> snapshot =
            await document.get(const GetOptions(source: Source.server));
        expect(snapshot.data(), {'foo': 'bar'});
        expect(snapshot.metadata.isFromCache, isFalse);
      });

      test(
        'gets a document from cache',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-get-cache');
          await document.set({'foo': 'bar'});
          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await document.get(const GetOptions(source: Source.cache));
          expect(snapshot.data(), equals({'foo': 'bar'}));
          expect(snapshot.metadata.isFromCache, isTrue);
        },
        skip: kIsWeb,
      );

      test(
        'throws a [FirebaseException] on error',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              firestore.doc('not-allowed/document');

          try {
            await document.get();
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }
          fail('Should have thrown a [FirebaseException]');
        },
      );
    });

    group('DocumentReference.set()', () {
      test('sets data', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-set');
        await document.set({'foo': 'bar'});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(snapshot.data(), equals({'foo': 'bar'}));
        await document.set({'bar': 'baz'});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(snapshot2.data(), equals({'bar': 'baz'}));
      });

      test('set() merges data', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-set-merge');
        await document.set({'foo': 'bar'});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(snapshot.data(), equals({'foo': 'bar'}));
        await document
            .set({'foo': 'ben', 'bar': 'baz'}, SetOptions(merge: true));
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(snapshot2.data(), equals({'foo': 'ben', 'bar': 'baz'}));
      });

      test(
        'set() merges fields',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-set-merge-fields');
          Map<String, dynamic> initialData = {
            'foo': 'bar',
            'bar': 123,
            'baz': '456',
          };
          Map<String, dynamic> dataToSet = {
            'foo': 'should-not-merge',
            'bar': 456,
            'baz': 'foo',
          };
          await document.set(initialData);
          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await document.get();
          expect(snapshot.data(), equals(initialData));
          await document.set(
            dataToSet,
            SetOptions(
              mergeFields: [
                'bar',
                FieldPath(const ['baz']),
              ],
            ),
          );
          DocumentSnapshot<Map<String, dynamic>> snapshot2 =
              await document.get();
          expect(
            snapshot2.data(),
            equals({'foo': 'bar', 'bar': 456, 'baz': 'foo'}),
          );
        },
      );

      test(
        'throws a [FirebaseException] on error',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              firestore.doc('not-allowed/document');

          try {
            await document.set({'foo': 'bar'});
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }
          fail('Should have thrown a [FirebaseException]');
        },
      );

      test('set and return all possible datatypes', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-types');

        await document.set({
          'string': 'foo bar',
          'number_32': 123,
          // Equivalent of `Number.MAX_SAFE_INTEGER` in JS, can't go higher than this.
          'number_64': 9007199254740991,
          'bool_true': true,
          'bool_false': false,
          'map': {
            'foo': 'bar',
            'bar': {'baz': 'ben'},
          },
          'list': [
            1,
            '2',
            true,
            false,
            {'foo': 'bar'},
          ],
          'null': null,
          'timestamp': Timestamp.now(),
          'geopoint': const GeoPoint(1, 2),
          'vectorValue': const VectorValue([1, 2, 3]),
          'reference': firestore.doc('foo/bar'),
          'nan': double.nan,
          'infinity': double.infinity,
          'negative_infinity': double.negativeInfinity,
        });

        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        Map<String, dynamic> data = snapshot.data()!;

        expect(data['string'], equals('foo bar'));
        expect(data['number_32'], equals(123));
        expect(data['number_64'], equals(9007199254740991));
        expect(data['bool_true'], isTrue);
        expect(data['bool_false'], isFalse);
        expect(
          data['map'],
          equals(<String, dynamic>{
            'foo': 'bar',
            'bar': {'baz': 'ben'},
          }),
        );
        expect(
          data['list'],
          equals([
            1,
            '2',
            true,
            false,
            {'foo': 'bar'},
          ]),
        );
        expect(data['null'], equals(null));
        expect(data['timestamp'], isA<Timestamp>());
        expect(data['geopoint'], isA<GeoPoint>());
        expect((data['geopoint'] as GeoPoint).latitude, equals(1));
        expect((data['geopoint'] as GeoPoint).longitude, equals(2));
        expect(data['vectorValue'], isA<VectorValue>());
        expect(
          (data['vectorValue'] as VectorValue).toArray(),
          equals([1, 2, 3]),
        );
        expect(data['reference'], isA<DocumentReference>());
        expect((data['reference'] as DocumentReference).id, equals('bar'));
        expect(data['nan'].isNaN, equals(true));
        expect(data['infinity'], equals(double.infinity));
        expect(data['negative_infinity'], equals(double.negativeInfinity));
      });
    });

    group('DocumentReference.update()', () {
      test('updates data', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-update');
        await document.set({'foo': 'bar'});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(snapshot.data(), equals({'foo': 'bar'}));
        await document.update({'bar': 'baz'});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(snapshot2.data(), equals({'foo': 'bar', 'bar': 'baz'}));
      });

      test('updates nested data using dots', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-update-field-path');
        await document.set({
          'foo': {'bar': 'baz'},
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(
          snapshot.data(),
          equals({
            'foo': {'bar': 'baz'},
          }),
        );

        await document.update({'foo.bar': 'toto'});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(
          snapshot2.data(),
          equals({
            'foo': {'bar': 'toto'},
          }),
        );
      });

      test('updates nested data using FieldPath', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-update-field-path');
        await document.set({
          'foo': {'bar': 'baz'},
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(
          snapshot.data(),
          equals({
            'foo': {'bar': 'baz'},
          }),
        );

        await document.update({
          FieldPath(const ['foo', 'bar']): 'toto',
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(
          snapshot2.data(),
          equals({
            'foo': {'bar': 'toto'},
          }),
        );
      });

      test('updates nested data containing a dot using FieldPath', () async {
        DocumentReference<Map<String, dynamic>> document =
            await initializeTest('document-update-field-path');
        await document.set({'foo.bar': 'baz'});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await document.get();
        expect(
          snapshot.data(),
          equals({'foo.bar': 'baz'}),
        );

        await document.update({
          FieldPath(const ['foo.bar']): 'toto',
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await document.get();
        expect(
          snapshot2.data(),
          equals({'foo.bar': 'toto'}),
        );
      });

      test(
        'throws if document does not exist',
        () async {
          DocumentReference<Map<String, dynamic>> document =
              await initializeTest('document-update-not-exists');
          try {
            await document.update({'foo': 'bar'});
            fail('Should have thrown');
          } catch (e) {
            expect(
              e,
              isA<FirebaseException>()
                  .having((e) => e.code, 'code', 'not-found'),
            );
          }
        },
      );
    });

    group('withConverter', () {
      test(
        'set/snapshot/get',
        () async {
          final foo = await initializeTest('foo');
          final fooConverter = foo.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          final fooSnapshot = foo.snapshots();
          final fooConverterSnapshot = fooConverter.snapshots();

          await expectLater(
            fooSnapshot,
            emits(
              isA<DocumentSnapshot<Map<String, dynamic>>>()
                  .having((e) => e.data(), 'data', null),
            ),
          );
          await expectLater(
            fooConverterSnapshot,
            emits(
              isA<DocumentSnapshot<int>>()
                  .having((e) => e.data(), 'data', null),
            ),
          );

          await fooConverter.set(42);

          await expectLater(
            fooSnapshot,
            emits(
              isA<DocumentSnapshot<Map<String, dynamic>>>()
                  .having((e) => e.data(), 'data', {'value': 42}),
            ),
          );
          await expectLater(
            fooConverterSnapshot,
            emits(
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42),
            ),
          );
          await expectLater(
            fooConverter.get(),
            completion(
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42),
            ),
          );

          await foo.set({'value': 21});

          await expectLater(
            fooSnapshot,
            emits(
              isA<DocumentSnapshot<Map<String, dynamic>>>()
                  .having((e) => e.data(), 'data', {'value': 21}),
            ),
          );

          await expectLater(
            fooConverter.get(),
            completion(
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 21),
            ),
          );
        },
        timeout: const Timeout.factor(3),
      );
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\e2e_test.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

import 'collection_reference_e2e.dart';
import 'document_change_e2e.dart';
import 'document_reference_e2e.dart';
import 'field_value_e2e.dart';
import 'firebase_options.dart';
import 'geo_point_e2e.dart';
import 'instance_e2e.dart';
import 'load_bundle_e2e.dart';
import 'query_e2e.dart';
import 'second_database.dart';
import 'settings_e2e.dart';
import 'snapshot_metadata_e2e.dart';
import 'timestamp_e2e.dart';
import 'transaction_e2e.dart';
import 'vector_value_e2e.dart';
import 'web_snapshot_listeners.dart';
import 'write_batch_e2e.dart';

bool kUseFirestoreEmulator = true;

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('cloud_firestore', () {
    setUpAll(() async {
      await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform,
      );
      // Web by default doesn't have persistence enabled
      FirebaseFirestore.instance.settings = const Settings(
        persistenceEnabled: true,
      );

      if (kUseFirestoreEmulator) {
        FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);
      }
    });

    runInstanceTests();

    runCollectionReferenceTests();
    runDocumentChangeTests();
    runDocumentReferenceTests();
    runFieldValueTests();
    runGeoPointTests();
    runVectorValueTests();
    runQueryTests();
    runSnapshotMetadataTests();
    runTimestampTests();
    runTransactionTests();
    runWriteBatchTests();
    runLoadBundleTests();
    runWebSnapshotListenersTests();
    if (defaultTargetPlatform != TargetPlatform.windows) {
      runSecondDatabaseTests();
    }
    if (kIsWeb) {
      runSettingsTest();
    }
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\field_value_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runFieldValueTests() {
  group('$FieldValue', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    group('FieldValue.increment()', () {
      test('increments a number if it exists', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-increment-exists');
        await doc.set({'foo': 2});
        await doc.update({'foo': FieldValue.increment(1)});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals(3));
        // Expect it to be a int
        expect(snapshot.data()!['foo'], isA<int>());
      });

      test('increments a big number if it exists', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-increment-exists');
        await doc.set({'foo': 0});
        await doc.update({'foo': FieldValue.increment(2148000000)});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals(2148000000));
      });

      test('decrements a number', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-decrement-exists');
        await doc.set({'foo': 2});
        await doc.update({'foo': FieldValue.increment(-1)});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals(1));
      });

      test('sets an increment if it does not exist', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-increment-not-exists');
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.exists, isFalse);
        await doc.set({'foo': FieldValue.increment(1)});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await doc.get();
        expect(snapshot2.data()!['foo'], equals(1));
      });
    });

    group('FieldValue.serverTimestamp()', () {
      test('sets a new server time value', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-server-timestamp-new');
        await doc.set({'foo': FieldValue.serverTimestamp()});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], isA<Timestamp>());
      });

      test('updates a server time value', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-server-timestamp-update');
        await doc.set({'foo': FieldValue.serverTimestamp()});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        Timestamp serverTime1 = snapshot.data()!['foo'];
        expect(serverTime1, isA<Timestamp>());
        await Future.delayed(const Duration(milliseconds: 100));
        await doc.update({'foo': FieldValue.serverTimestamp()});
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await doc.get();
        Timestamp serverTime2 = snapshot2.data()!['foo'];
        expect(serverTime2, isA<Timestamp>());
        expect(
          serverTime2.microsecondsSinceEpoch >
              serverTime1.microsecondsSinceEpoch,
          isTrue,
        );
      });
    });

    group('FieldValue.delete()', () {
      test('removes a value', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-delete');
        await doc.set({'foo': 'bar', 'bar': 'baz'});
        await doc.update({'bar': FieldValue.delete()});
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data(), equals(<String, dynamic>{'foo': 'bar'}));
      });
    });

    group('FieldValue.arrayUnion()', () {
      test('updates an existing array', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-union-update-array');
        await doc.set({
          'foo': [1, 2],
        });
        await doc.update({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([1, 2, 3, 4]));
      });

      test('updates an array if current value is not an array', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-union-replace');
        await doc.set({'foo': 'bar'});
        await doc.update({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([3, 4]));
      });

      test('sets an array if current value is not an array', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-union-replace');
        await doc.set({'foo': 'bar'});
        await doc.set({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([3, 4]));
      });
    });

    group('FieldValue.arrayRemove()', () {
      test('removes items in an array', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-remove-existing');
        await doc.set({
          'foo': [1, 2, 3, 4],
        });
        await doc.update({
          'foo': FieldValue.arrayRemove([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([1, 2]));
      });

      test('removes & updates an array if existing item is not an array',
          () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-remove-replace');
        await doc.set({'foo': 'bar'});
        await doc.update({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([3, 4]));
      });

      test('removes & sets an array if existing item is not an array',
          () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('field-value-array-remove-replace');
        await doc.set({'foo': 'bar'});
        await doc.set({
          'foo': FieldValue.arrayUnion([3, 4]),
        });
        DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
        expect(snapshot.data()!['foo'], equals([3, 4]));
      });

      // ignore: todo
      // TODO(salakar): test is currently failing on CI but unable to reproduce locally
      test(
        'updates with nested types',
        () async {
          DocumentReference<Map<String, dynamic>> doc =
              await initializeTest('field-value-nested-types');

          DocumentReference<Map<String, dynamic>> ref =
              FirebaseFirestore.instance.doc('foo/bar');

          await doc.set({
            'foo': [1],
          });
          await doc.update({
            'foo': FieldValue.arrayUnion([2, ref]),
          });
          DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
          expect(snapshot.data()!['foo'], equals([1, 2, ref]));
        },
        skip: true,
      );

      test('query should restore nested Timestamp', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('nested-timestamp');
        await Future.wait([
          doc.set({
            'nested': {
              'timestamp': Timestamp.fromDate(DateTime(2020)),
            },
            'timestamp': Timestamp.fromDate(DateTime(2020)),
          }),
        ]);

        final snapshot = await doc.get();

        expect(snapshot.data()!['timestamp'], isA<Timestamp>());
        expect(snapshot.data()!['nested']['timestamp'], isA<Timestamp>());
      });

      test('query should restore nested Timestamp in List', () async {
        DocumentReference<Map<String, dynamic>> doc =
            await initializeTest('nested-timestamp');
        await doc.set({
          'timestamp': Timestamp.fromDate(DateTime.now()),
          'logs': [
            {
              'createdAt': Timestamp.fromDate(DateTime.now()),
            },
          ],
        });

        final snapshot = await doc.get();

        expect(snapshot.data()!['timestamp'], isA<Timestamp>());
        expect(snapshot.data()!['logs'][0]['createdAt'], isA<Timestamp>());
      });
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\firebase_options.dart =====
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    return switch (defaultTargetPlatform) {
      TargetPlatform.android => android,
      TargetPlatform.iOS => ios,
      TargetPlatform.macOS => macos,
      TargetPlatform.windows => android,
      TargetPlatform.linux => throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        ),
      _ => throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        )
    };
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:175ea7a64b2faf5e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:0670bc5fe8574a9c3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-l9gojfp6b3h1cgie1se28a9ol9fmsvvk.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:0670bc5fe8574a9c3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-l9gojfp6b3h1cgie1se28a9ol9fmsvvk.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\firebase_options_secondary.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options_secondary.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    return switch (defaultTargetPlatform) {
      TargetPlatform.android => android,
      TargetPlatform.iOS => ios,
      TargetPlatform.macOS => macos,
      TargetPlatform.windows => android,
      _ => throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        )
    };
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyAFh7c37C6MyAVwRJylz7EwvzZSECqmcus',
    appId: '1:866672724757:web:3a0fad9cba4848ea19f71c',
    messagingSenderId: '866672724757',
    projectId: 'flutterfire-e2e-tests-2',
    authDomain: 'flutterfire-e2e-tests-2.firebaseapp.com',
    storageBucket: 'flutterfire-e2e-tests-2.appspot.com',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAMoRmAcD_NW0DVoO40ThJO1zDF2vDB7Rs',
    appId: '1:866672724757:android:d069b410181b65cf19f71c',
    messagingSenderId: '866672724757',
    projectId: 'flutterfire-e2e-tests-2',
    storageBucket: 'flutterfire-e2e-tests-2.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDfWh055gUcnS6_Gqd_Jjwy7boVm5_E8oI',
    appId: '1:866672724757:ios:142139d84dda4ed419f71c',
    messagingSenderId: '866672724757',
    projectId: 'flutterfire-e2e-tests-2',
    storageBucket: 'flutterfire-e2e-tests-2.appspot.com',
    iosClientId:
        '866672724757-rncbdu3qrn0j423e1tfk2jg7jdvrhd8i.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestoreExample',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDfWh055gUcnS6_Gqd_Jjwy7boVm5_E8oI',
    appId: '1:866672724757:ios:3e35357fc677cc5719f71c',
    messagingSenderId: '866672724757',
    projectId: 'flutterfire-e2e-tests-2',
    storageBucket: 'flutterfire-e2e-tests-2.appspot.com',
    iosClientId:
        '866672724757-fup6o8riklmmc7mbo3b1jolbeadbb84m.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\geo_point_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runGeoPointTests() {
  group('$GeoPoint', () {
    late FirebaseFirestore /*?*/ firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    test('sets a $GeoPoint & returns one', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('geo-point');

      await doc.set({'foo': const GeoPoint(10, -10)});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      GeoPoint geopoint = snapshot.data()!['foo'];
      expect(geopoint, isA<GeoPoint>());
      expect(geopoint.latitude, equals(10));
      expect(geopoint.longitude, equals(-10));
    });

    test('updates a $GeoPoint & returns', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('geo-point-update');

      await doc.set({'foo': const GeoPoint(10, -10)});

      await doc.update({'foo': const GeoPoint(-10, 10)});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      GeoPoint geopoint = snapshot.data()!['foo'];
      expect(geopoint, isA<GeoPoint>());
      expect(geopoint.latitude, equals(-10));
      expect(geopoint.longitude, equals(10));
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\instance_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:convert';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runInstanceTests() {
  group(
    '$FirebaseFirestore.instance',
    () {
      late FirebaseFirestore firestore;

      setUpAll(() async {
        firestore = FirebaseFirestore.instance;
      });

      test(
        'snapshotsInSync()',
        () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('flutter-tests/insync');

          // Ensure deleted
          await documentReference.delete();

          StreamController controller = StreamController();
          StreamSubscription insync;
          StreamSubscription snapshots;

          int inSyncCount = 0;

          insync = firestore.snapshotsInSync().listen((_) {
            controller.add('insync=$inSyncCount');
            inSyncCount++;
          });

          snapshots = documentReference.snapshots().listen((ds) {
            controller.add('snapshot-exists=${ds.exists}');
          });

          // Allow the snapshots to trigger...
          await Future.delayed(const Duration(seconds: 1));

          await documentReference.set({'foo': 'bar'});

          await expectLater(
            controller.stream,
            emitsInOrder([
              'insync=0', // No other snapshots
              'snapshot-exists=false',
              'insync=1',
              'snapshot-exists=true',
              'insync=2',
            ]),
          );

          await controller.close();
          await insync.cancel();
          await snapshots.cancel();
        },
        skip: kIsWeb,
      );

      test(
        'enableNetwork()',
        () async {
          // Write some data while online
          await firestore.enableNetwork();
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('flutter-tests/enable-network');
          await documentReference.set({'foo': 'bar'});

          // Disable the network
          await firestore.disableNetwork();

          StreamController controller = StreamController();

          // Set some data while offline
          // ignore: unawaited_futures
          documentReference.set({'foo': 'baz'}).then((_) async {
            // Only when back online will this trigger
            controller.add(true);
          });

          // Go back online
          await firestore.enableNetwork();

          await expectLater(controller.stream, emits(true));
          await controller.close();
        },
        skip: kIsWeb,
      );

      test(
        'disableNetwork()',
        () async {
          // Write some data while online
          await firestore.enableNetwork();
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('flutter-tests/disable-network');
          await documentReference.set({'foo': 'bar'});

          // Disable the network
          await firestore.disableNetwork();

          // Get data from cache
          DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
              await documentReference.get();
          expect(documentSnapshot.metadata.isFromCache, isTrue);
          expect(documentSnapshot.data()!['foo'], equals('bar'));

          // Go back online once test complete
          await firestore.enableNetwork();
        },
        skip: kIsWeb,
      );

      test(
        'waitForPendingWrites()',
        () async {
          await firestore.waitForPendingWrites();
        },
        skip: kIsWeb,
      );

      test(
        'terminate() / clearPersistence()',
        () async {
          // Since the firestore instance has already been used,
          // calling `clearPersistence` will throw a native error.
          // We first check it does throw as expected, then terminate
          // the instance, and then check whether clearing succeeds.
          try {
            await firestore.clearPersistence();
            fail('Should have thrown');
          } on FirebaseException catch (e) {
            expect(e.code, equals('failed-precondition'));
          } catch (e) {
            fail('$e');
          }

          await firestore.terminate();
          await firestore.clearPersistence();
        },
        skip: kIsWeb || defaultTargetPlatform == TargetPlatform.windows,
      );

      test(
        'setIndexConfigurationFromJSON()',
        () async {
          final json = jsonEncode({
            'indexes': [
              {
                'collectionGroup': 'posts',
                'queryScope': 'COLLECTION',
                'fields': [
                  {'fieldPath': 'author', 'arrayConfig': 'CONTAINS'},
                  {'fieldPath': 'timestamp', 'order': 'DESCENDING'},
                ],
              }
            ],
            'fieldOverrides': [
              {
                'collectionGroup': 'posts',
                'fieldPath': 'myBigMapField',
                'indexes': [],
              }
            ],
          });

          await firestore.setIndexConfigurationFromJSON(json);
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );

      test('setLoggingEnabled should resolve without issue', () async {
        await FirebaseFirestore.setLoggingEnabled(true);
        await FirebaseFirestore.setLoggingEnabled(false);
      });

      test(
          'Settings() - `persistenceEnabled` & `cacheSizeBytes` with acceptable number',
          () async {
        FirebaseFirestore.instance.settings =
            const Settings(persistenceEnabled: true, cacheSizeBytes: 10000000);
        // Used to trigger settings
        await FirebaseFirestore.instance
            .collection('flutter-tests')
            .doc('new-doc')
            .set(
          {'some': 'data'},
        );
      });

      test(
          'Settings() - `persistenceEnabled` & `cacheSizeBytes` with `Settings.CACHE_SIZE_UNLIMITED`',
          () async {
        FirebaseFirestore.instance.settings = const Settings(
          persistenceEnabled: true,
          cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED,
        );
        // Used to trigger settings
        await FirebaseFirestore.instance
            .collection('flutter-tests')
            .doc('new-doc')
            .set(
          {'some': 'data'},
        );
      });

      test('Settings() - `persistenceEnabled` & without `cacheSizeBytes`',
          () async {
        FirebaseFirestore.instance.settings =
            const Settings(persistenceEnabled: true);
        // Used to trigger settings
        await FirebaseFirestore.instance
            .collection('flutter-tests')
            .doc('new-doc')
            .set(
          {'some': 'data'},
        );
      });
      test(
        '`PersistenceCacheIndexManager` with default persistence settings for each platform',
        () async {
          if (defaultTargetPlatform == TargetPlatform.windows) {
            try {
              // Windows does not have `PersistenceCacheIndexManager` support
              FirebaseFirestore.instance.persistentCacheIndexManager();
            } catch (e) {
              expect(e, isInstanceOf<UnimplementedError>());
            }
          } else {
            if (kIsWeb) {
              // persistence is disabled by default on web
              final firestore = FirebaseFirestore.instanceFor(
                app: Firebase.app(),
                // Use different firestore instance to test behavior
                databaseId: 'default-web',
              );
              PersistentCacheIndexManager? indexManager =
                  firestore.persistentCacheIndexManager();
              expect(indexManager, isNull);
            } else {
              final firestore = FirebaseFirestore.instanceFor(
                app: Firebase.app(),
                // Use different firestore instance to test behavior
                databaseId: 'default-other-platform-test',
              );
              // macOS, android, iOS have persistence enabled by default
              PersistentCacheIndexManager? indexManager =
                  firestore.persistentCacheIndexManager();
              await indexManager!.enableIndexAutoCreation();
              await indexManager.disableIndexAutoCreation();
              await indexManager.deleteAllIndexes();
            }
          }
        },
      );

      test(
        '`PersistenceCacheIndexManager` with persistence enabled for each platform',
        () async {
          if (kIsWeb) {
            final firestore = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'web-enabled',
            );
            // persistence is disabled by default so we enable it
            firestore.settings = const Settings(persistenceEnabled: true);

            PersistentCacheIndexManager? indexManager =
                firestore.persistentCacheIndexManager();

            await indexManager!.enableIndexAutoCreation();
            await indexManager.disableIndexAutoCreation();
            await indexManager.deleteAllIndexes();

            final firestore2 = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'web-disabled-2',
            );

            // Enable persistence using settings instead of deprecated enablePersistence()
            firestore2.settings = const Settings(persistenceEnabled: true);

            PersistentCacheIndexManager? indexManager2 =
                firestore2.persistentCacheIndexManager();

            await indexManager2!.enableIndexAutoCreation();
            await indexManager2.disableIndexAutoCreation();
            await indexManager2.deleteAllIndexes();
          } else {
            final firestore = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'other-platform-enabled',
            );
            firestore.settings = const Settings(persistenceEnabled: true);
            PersistentCacheIndexManager? indexManager =
                firestore.persistentCacheIndexManager();
            await indexManager!.enableIndexAutoCreation();
            await indexManager.disableIndexAutoCreation();
            await indexManager.deleteAllIndexes();
          }
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );

      test(
        '`PersistenceCacheIndexManager` with persistence disabled for each platform',
        () async {
          if (kIsWeb) {
            final firestore = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'web-disabled-1',
            );
            // persistence is disabled by default so we enable it
            firestore.settings = const Settings(persistenceEnabled: false);

            PersistentCacheIndexManager? indexManager =
                firestore.persistentCacheIndexManager();

            expect(indexManager, isNull);
          } else {
            final firestore = FirebaseFirestore.instanceFor(
              app: Firebase.app(),
              databaseId: 'other-platform-disabled',
            );
            // macOS, android, iOS have persistence enabled by default so we disable it
            firestore.settings = const Settings(persistenceEnabled: false);
            PersistentCacheIndexManager? indexManager =
                firestore.persistentCacheIndexManager();
            expect(indexManager, isNull);
          }
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );
    },
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\load_bundle_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;

void runLoadBundleTests() {
  group('$DocumentReference', () {
    late FirebaseFirestore firestore;

    Future<Uint8List> loadBundleSetup(int number) async {
      // endpoint serves a bundle with 3 documents each containing
      // a 'number' property that increments in value 1-3.
      final url =
          Uri.https('api.rnfirebase.io', '/firestore/e2e-tests/bundle-$number');
      final response = await http.get(url);
      String string = response.body;
      return Uint8List.fromList(string.codeUnits);
    }

    setUp(() async {
      firestore = FirebaseFirestore.instance;
    });

    group('FirebaseFirestore.loadBundle()', () {
      test('loadBundle()', () async {
        const int number = 1;
        const String collection = 'firestore-bundle-tests-$number';
        Uint8List buffer = await loadBundleSetup(number);
        LoadBundleTask task = firestore.loadBundle(buffer);

        // ensure the bundle has been completely cached
        await task.stream.last;

        QuerySnapshot<Map<String, Object?>> snapshot = await firestore
            .collection(collection)
            .get(const GetOptions(source: Source.cache));

        expect(
          snapshot.docs.map((document) => document['number']),
          everyElement(anyOf(1, 2, 3)),
        );
      });

      test(
        'loadBundle(): LoadBundleTaskProgress stream snapshots',
        () async {
          Uint8List buffer = await loadBundleSetup(2);
          LoadBundleTask task = firestore.loadBundle(buffer);

          final list = await task.stream.toList();

          expect(
            list.map((e) => e.totalDocuments),
            everyElement(isNonNegative),
          );
          expect(list.map((e) => e.bytesLoaded), everyElement(isNonNegative));
          expect(
            list.map((e) => e.documentsLoaded),
            everyElement(isNonNegative),
          );
          expect(list.map((e) => e.totalBytes), everyElement(isNonNegative));
          expect(list, everyElement(isInstanceOf<LoadBundleTaskSnapshot>()));

          LoadBundleTaskSnapshot lastSnapshot = list.removeLast();
          expect(lastSnapshot.taskState, LoadBundleTaskState.success);

          expect(
            list.map((e) => e.taskState),
            everyElement(LoadBundleTaskState.running),
          );
        },
        // Working locally but is failing on CI
        skip: kIsWeb,
      );

      test(
        'loadBundle(): error handling for malformed bundle',
        () async {
          final url = Uri.https(
            'api.rnfirebase.io',
            '/firestore/e2e-tests/malformed-bundle',
          );
          final response = await http.get(url);
          String string = response.body;
          Uint8List buffer = Uint8List.fromList(string.codeUnits);

          LoadBundleTask task = firestore.loadBundle(buffer);

          await expectLater(
            task.stream.last,
            throwsA(
              isA<FirebaseException>()
                  .having((e) => e.code, 'code', 'load-bundle-error'),
            ),
          );
        },
      );

      test(
        'loadBundle(): pause and resume stream',
        () async {
          Uint8List buffer = await loadBundleSetup(3);
          LoadBundleTask task = firestore.loadBundle(buffer);
          // Illustrates the pause() & resume() function.
          // A single stream will stop sending events once the listener is unsubscribed

          // Will listen & pause after first event received
          await expectLater(
            task.stream,
            emits(
              isA<LoadBundleTaskSnapshot>().having(
                (ts) => ts.taskState,
                'taskState',
                LoadBundleTaskState.running,
              ),
            ),
          );

          await Future.delayed(const Duration(milliseconds: 1));

          // Will resume & pause after second event received
          await expectLater(
            task.stream,
            emits(
              isA<LoadBundleTaskSnapshot>().having(
                (ts) => ts.taskState,
                'taskState',
                anyOf(LoadBundleTaskState.running, LoadBundleTaskState.success),
              ),
            ),
          );
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );
    });

    group('FirebaseFirestore.namedQueryGet()', () {
      test(
        'namedQueryGet() successful',
        () async {
          const int number = 4;
          Uint8List buffer = await loadBundleSetup(number);
          LoadBundleTask task = firestore.loadBundle(buffer);

          // ensure the bundle has been completely cached
          await task.stream.last;

          // namedQuery 'named-bundle-test' which returns a QuerySnaphot of the same 3 documents
          // with 'number' property
          QuerySnapshot<Map<String, Object?>> snapshot =
              await firestore.namedQueryGet(
            'named-bundle-test-$number',
            options: const GetOptions(source: Source.cache),
          );

          expect(
            snapshot.docs.map((document) => document['number']),
            everyElement(anyOf(1, 2, 3)),
          );
        },
        skip: kIsWeb,
      );

      test(
        'namedQueryGet() error',
        () async {
          Uint8List buffer = await loadBundleSetup(4);
          LoadBundleTask task = firestore.loadBundle(buffer);

          // ensure the bundle has been completely cached
          await task.stream.last;

          await expectLater(
            firestore.namedQueryGet(
              'wrong-name',
              options: const GetOptions(source: Source.cache),
            ),
            throwsA(
              isA<FirebaseException>()
                  .having((e) => e.code, 'code', 'non-existent-named-query'),
            ),
          );
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );
    });

    group('FirebaeFirestore.namedQueryWithConverterGet()', () {
      test('namedQueryWithConverterGet() successful', () async {
        const int number = 4;
        Uint8List buffer = await loadBundleSetup(number);
        LoadBundleTask task = firestore.loadBundle(buffer);

        // ensure the bundle has been completely cached
        await task.stream.last;

        // namedQuery 'named-bundle-test' which returns a QuerySnaphot of the same 3 documents
        // with 'number' property
        QuerySnapshot<ConverterPlaceholder> snapshot =
            await firestore.namedQueryWithConverterGet<ConverterPlaceholder>(
          'named-bundle-test-$number',
          options: const GetOptions(source: Source.cache),
          fromFirestore: ConverterPlaceholder.new,
          toFirestore: (value, options) => value.toFirestore(),
        );

        expect(
          snapshot.docs.map((document) => document['number']),
          everyElement(anyOf(1, 2, 3)),
        );
      });

      test(
        'namedQueryWithConverterGet() error',
        () async {
          Uint8List buffer = await loadBundleSetup(4);
          LoadBundleTask task = firestore.loadBundle(buffer);

          // ensure the bundle has been completely cached
          await task.stream.last;

          await expectLater(
            firestore.namedQueryWithConverterGet<ConverterPlaceholder>(
              'wrong-name',
              options: const GetOptions(source: Source.cache),
              fromFirestore: ConverterPlaceholder.new,
              toFirestore: (value, options) => value.toFirestore(),
            ),
            throwsA(
              isA<FirebaseException>()
                  .having((e) => e.code, 'code', 'non-existent-named-query'),
            ),
          );
        },
        skip: defaultTargetPlatform == TargetPlatform.windows,
      );
    });
  });
}

class ConverterPlaceholder {
  ConverterPlaceholder(this.firestore, this.getOptions);

  final DocumentSnapshot<Map<String, Object?>> firestore;
  final SnapshotOptions? getOptions;

  Map<String, Object?> toFirestore() => firestore.data()!;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\query_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runQueryTests() {
  group('$Query', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<CollectionReference<Map<String, dynamic>>> initializeTest(
      String id,
    ) async {
      CollectionReference<Map<String, dynamic>> collection =
          firestore.collection('flutter-tests/$id/query-tests');
      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      await Future.forEach(snapshot.docs,
          (QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot) {
        return documentSnapshot.reference.delete();
      });
      return collection;
    }

    group('equality', () {
      // testing == override using e2e tests as it is dependent on the platform
      test('handles deeply compares query parameters', () async {
        final movies = firestore.collection('/movies');
        final starWarsComments =
            firestore.collection('/movies/star-wars/comments');

        expect(
          movies.where('genre', arrayContains: ['Flutter']),
          movies.where('genre', arrayContains: ['Flutter']),
        );
        expect(
          movies.where('genre', arrayContains: ['Flutter']),
          isNot(movies.where('genre', arrayContains: ['React'])),
        );
        expect(
          movies.where('genre', arrayContains: ['Flutter']),
          isNot(starWarsComments.where('genre', arrayContains: ['Flutter'])),
        );
      });

      test('differentiate queries from a different app instance', () async {
        final fooApp = await Firebase.initializeApp(
          name: 'foo',
          options: Firebase.app().options,
        );

        expect(
          FirebaseFirestore.instanceFor(app: fooApp)
              .collection('movies')
              .limit(42),
          FirebaseFirestore.instanceFor(app: fooApp)
              .collection('movies')
              .limit(42),
        );

        expect(
          FirebaseFirestore.instance.collection('movies').limit(42),
          isNot(
            FirebaseFirestore.instanceFor(app: fooApp)
                .collection('movies')
                .limit(42),
          ),
        );
      });

      test('differentiate collection group', () async {
        expect(
          firestore.collectionGroup('comments').limit(42),
          firestore.collectionGroup('comments').limit(42),
        );
        expect(
          firestore.collectionGroup('comments').limit(42),
          isNot(firestore.collection('comments').limit(42)),
        );
      });
    });

    /**
     * collectionGroup
     */
    group('collectionGroup()', () {
      test('returns a data via a sub-collection', () async {
        CollectionReference<Map<String, dynamic>> collection =
            firestore.collection('flutter-tests/collection-group/group-test');
        QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

        await Future.forEach(snapshot.docs,
            (DocumentSnapshot documentSnapshot) {
          return documentSnapshot.reference.delete();
        });

        await collection.doc('doc1').set({'foo': 1});
        await collection.doc('doc2').set({'foo': 2});

        QuerySnapshot<Map<String, dynamic>> groupSnapshot = await firestore
            .collectionGroup('group-test')
            .orderBy('foo', descending: true)
            .get();
        expect(groupSnapshot.size, equals(2));
        expect(groupSnapshot.docs[0].data()['foo'], equals(2));
        expect(groupSnapshot.docs[1].data()['foo'], equals(1));
      });

      test(
          'should respond with a FirebaseException, the query requires an index',
          () async {
        try {
          await FirebaseFirestore.instance
              .collectionGroup('collection-group')
              .where('number', isGreaterThan: 1, isLessThan: 3)
              .where('foo', isEqualTo: 'bar')
              .get();
        } catch (error) {
          expect(
            (error as FirebaseException).code,
            equals('failed-precondition'),
          );
          expect(
            error.message,
            'The query requires an index',
          );
        }
      });
    });

    /**
     * get
     */
    group('Query.get()', () {
      test('returns a [QuerySnapshot]', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs = await collection.get();
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
      });

      test('uses [GetOptions] cache', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs =
            await collection.get(const GetOptions(source: Source.cache));
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        expect(qs.metadata.isFromCache, isTrue);
      });

      test('uses [GetOptions] server', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs =
            await collection.get(const GetOptions(source: Source.server));
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        expect(qs.metadata.isFromCache, isFalse);
      });

      test('uses [GetOptions] serverTimestampBehavior previous', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs = await collection.get(
          const GetOptions(
            serverTimestampBehavior: ServerTimestampBehavior.previous,
          ),
        );
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
      });

      test('uses [GetOptions] serverTimestampBehavior estimate', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        QuerySnapshot<Map<String, dynamic>> qs = await collection.get(
          const GetOptions(
            serverTimestampBehavior: ServerTimestampBehavior.estimate,
          ),
        );
        expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
      });

      test(
        'throws a [FirebaseException]',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              firestore.collection('not-allowed');

          try {
            await collection.get();
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals('permission-denied'),
            );
            return;
          }
          fail('Should have thrown a [FirebaseException]');
        },
      );

      test(
        'should respond with a FirebaseException, the query requires an index',
        () async {
          try {
            await FirebaseFirestore.instance
                .collection('flutter-tests')
                .where('number', isGreaterThan: 1, isLessThan: 3)
                .where('foo', isEqualTo: 'bar')
                .get();
          } catch (error) {
            expect(
              (error as FirebaseException).code,
              equals('failed-precondition'),
            );
            expect(
              error.message,
              'The query requires an index',
            );
          }
        },
      );
    });

    /**
     * snapshots
     */
    group('Query.snapshots()', () {
      test('returns a [Stream]', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get');
        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.snapshots();
        expect(stream, isA<Stream<QuerySnapshot<Map<String, dynamic>>>>());
      });

      test('listens to a single response', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get-single');
        await collection.add({'foo': 'bar'});
        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.snapshots();
        StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? subscription;

        subscription = stream.listen(
          expectAsync1(
            (QuerySnapshot<Map<String, dynamic>> snapshot) {
              expect(snapshot.docs.length, equals(1));
              expect(snapshot.docs[0], isA<QueryDocumentSnapshot>());
              QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                  snapshot.docs[0];
              expect(documentSnapshot.data()['foo'], equals('bar'));
            },
            reason: 'Stream should only have been called once.',
          ),
        );
        addTearDown(() async {
          await subscription?.cancel();
        });
      });

      test(
        'listens to a single response from cache with QuerySnapshot',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get-single-cache');
          await collection.add({'foo': 'bar'});
          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots(source: ListenSource.cache);
          StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? subscription;

          subscription = stream.listen(
            expectAsync1(
              (QuerySnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.docs.length, equals(1));
                expect(snapshot.docs[0], isA<QueryDocumentSnapshot>());
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs[0];
                expect(documentSnapshot.data()['foo'], equals('bar'));
              },
              reason: 'Stream should only have been called once.',
            ),
          );
          addTearDown(() async {
            await subscription?.cancel();
          });
        },
        // Failing on CI but works locally
        skip: kIsWeb,
      );

      test('listens to multiple queries', () async {
        CollectionReference<Map<String, dynamic>> collection1 =
            await initializeTest('document-snapshot-1');
        CollectionReference<Map<String, dynamic>> collection2 =
            await initializeTest('document-snapshot-2');

        await collection1.add({'test': 'value1'});
        await collection2.add({'test': 'value2'});

        final value1 = collection1
            .snapshots()
            .first
            .then((s) => s.docs.first.data()['test']);
        final value2 = collection2
            .snapshots()
            .first
            .then((s) => s.docs.first.data()['test']);

        await expectLater(value1, completion('value1'));
        await expectLater(value2, completion('value2'));
      });

      test('listens to a multiple changes response', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('get-multiple');
        await collection.add({'foo': 'bar'});

        Stream<QuerySnapshot<Map<String, dynamic>>> stream =
            collection.snapshots();
        int call = 0;

        StreamSubscription subscription = stream.listen(
          expectAsync1(
            (QuerySnapshot<Map<String, dynamic>> snapshot) {
              call++;
              if (call == 1) {
                expect(snapshot.docs.length, equals(1));
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs[0];
                expect(documentSnapshot.data()['foo'], equals('bar'));
              } else if (call == 2) {
                expect(snapshot.docs.length, equals(2));
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs.firstWhere((doc) => doc.id == 'doc1');
                expect(documentSnapshot.data()['bar'], equals('baz'));
              } else if (call == 3) {
                expect(snapshot.docs.length, equals(1));
                expect(
                  snapshot.docs.where((doc) => doc.id == 'doc1').isEmpty,
                  isTrue,
                );
              } else if (call == 4) {
                expect(snapshot.docs.length, equals(2));
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs.firstWhere((doc) => doc.id == 'doc2');
                expect(documentSnapshot.data()['foo'], equals('bar'));
              } else if (call == 5) {
                expect(snapshot.docs.length, equals(2));
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs.firstWhere((doc) => doc.id == 'doc2');
                expect(documentSnapshot.data()['foo'], equals('baz'));
              } else {
                fail('Should not have been called');
              }
            },
            count: 5,
            reason: 'Stream should only have been called five times.',
          ),
        );

        await Future.delayed(const Duration(milliseconds: 500));
        await collection.doc('doc1').set({'bar': 'baz'});
        await collection.doc('doc1').delete();
        await collection.doc('doc2').set({'foo': 'bar'});
        await collection.doc('doc2').update({'foo': 'baz'});

        await subscription.cancel();
      });

      test(
        'listeners throws a [FirebaseException] with Query',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              firestore.collection('not-allowed');
          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots();

          try {
            await stream.first;
          } catch (error) {
            expect(error, isA<FirebaseException>());
            expect(
              (error as FirebaseException).code,
              equals(
                'permission-denied',
              ),
            );
            return;
          }

          fail('Should have thrown a [FirebaseException]');
        },
      );
    });

    /**
     * End At
     */

    group('Query.endAt{Document}()', () {
      test('ends at string field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .endAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').endAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('ends at string field paths with Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .endAt({2}).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').endAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('ends at field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy(FieldPath(const ['bar', 'value']), descending: true)
            .endAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy(FieldPath(const ['foo'])).endAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('endAtDocument() ends at a document field value', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 1},
          }),
        ]);

        DocumentSnapshot endAtSnapshot = await collection.doc('doc2').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value')
            .endAtDocument(endAtSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));
      });

      test('endAtDocument() ends at a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endAt-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc4').set({
            'bar': {'value': 4},
          }),
        ]);

        DocumentSnapshot endAtSnapshot = await collection.doc('doc3').get();

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.endAtDocument(endAtSnapshot).get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc3'));
      });
    });

    /**
     * Start At
     */

    group('Query.startAt{Document}()', () {
      test('starts at string field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .startAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').startAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('starts at string field paths with Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .startAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').startAt({2}).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('starts at field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy(FieldPath(const ['bar', 'value']), descending: true)
            .startAt([2]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
            .orderBy(FieldPath(const ['foo']))
            .startAt([2]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('startAtDocument() starts at a document field value', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-document-field-value');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 1},
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value')
            .startAtDocument(startAtSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));
      });

      test('startAtDocument() starts at a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAt-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc4').set({
            'bar': {'value': 4},
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc3').get();

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.startAtDocument(startAtSnapshot).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc4'));
      });
    });

    /**
     * End Before
     */

    group('Query.endBefore{Document}()', () {
      test('ends before string field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .endBefore([1]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').endBefore([3]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('ends before string field paths with Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .endBefore({1}).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').endBefore([3]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('ends before field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy(FieldPath(const ['bar', 'value']), descending: true)
            .endBefore([1]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
            .orderBy(FieldPath(const ['foo']))
            .endBefore([3]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc1'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('endbeforeDocument() ends before a document field value', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-document-field-value');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 1},
          }),
        ]);

        DocumentSnapshot endAtSnapshot = await collection.doc('doc1').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value')
            .endBeforeDocument(endAtSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));
      });

      test('endBeforeDocument() ends before a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endBefore-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc4').set({
            'bar': {'value': 4},
          }),
        ]);

        DocumentSnapshot endAtSnapshot = await collection.doc('doc4').get();

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.endBeforeDocument(endAtSnapshot).get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc3'));
      });
    });

    /**
     * Start after
     */
    group('Query.startAfter{Document}()', () {
      test('starts after string field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfter-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value', descending: true)
            .startAfter([3]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo').startAfter([1]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('starts after field paths', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfter-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'foo': 2,
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'foo': 3,
            'bar': {'value': 3},
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy(FieldPath(const ['bar', 'value']), descending: true)
            .startAfter([3]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
            .orderBy(FieldPath(const ['foo']))
            .startAfter([1]).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc3'));
      });

      test('startAfterDocument() starts after a document field value',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfter-document-field-value');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 1},
          }),
        ]);

        DocumentSnapshot startAfterSnapshot =
            await collection.doc('doc3').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .orderBy('bar.value')
            .startAfterDocument(startAfterSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc1'));
      });

      test('startAfterDocument() starts after a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfter-document');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': {'value': 1},
          }),
          collection.doc('doc2').set({
            'bar': {'value': 2},
          }),
          collection.doc('doc3').set({
            'bar': {'value': 3},
          }),
          collection.doc('doc4').set({
            'bar': {'value': 4},
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.startAfterDocument(startAtSnapshot).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc4'));
      });

      testWidgets(
        'throws exception without orderBy() on field used for inequality query',
        (_) async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfterDocument-inequality-field-throw');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 10},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 10},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 10},
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
          Query inequalityQuery =
              collection.where('bar.value', isGreaterThan: 5);

          await expectLater(
            inequalityQuery.startAfterDocument(startAtSnapshot).get(),
            throwsA(
              isA<FirebaseException>().having(
                (e) => e.message,
                'message',
                contains(
                  'Client specified an invalid argument',
                ),
              ),
            ),
          );
        },
        // firebase-js-sdk does not require an orderBy() field to be set for this to work
        skip: kIsWeb,
      );

      testWidgets(
        'throws exception without correct orderBy("wrong-field") field used for inequality query',
        (_) async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest(
            'startAfterDocument-wrong-inequality-field-throw',
          );
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc2').set(
              {
                'bar': {'value': 10},
                'wrong-field': 2,
              },
            ),
            collection.doc('doc3').set(
              {
                'bar': {'value': 10},
                'wrong-field': 2,
              },
            ),
            collection.doc('doc4').set(
              {
                'bar': {'value': 10},
                'wrong-field': 2,
              },
            ),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
          Query inequalityQuery =
              collection.where('bar.value', isGreaterThan: 5);
          await expectLater(
            inequalityQuery
                .orderBy('wrong-field')
                .startAfterDocument(startAtSnapshot)
                .get(),
            throwsA(
              isA<FirebaseException>().having(
                (e) => e.message,
                'message',
                contains(
                  'Client specified an invalid argument',
                ),
              ),
            ),
          );
        },
        // firebase-js-sdk does not require an orderBy() field to be set for this to work
        skip: kIsWeb,
      );

      testWidgets(
          'Successful request when using orderBy() with same field used on inequality query',
          (_) async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startAfterDocument-correct-inequality-field');
        await Future.wait([
          collection.doc('doc1').set({
            'bar': 2,
          }),
          collection.doc('doc2').set({
            'bar': 10,
          }),
          collection.doc('doc3').set({
            'bar': 11,
          }),
          collection.doc('doc4').set({
            'bar': 12,
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
        Query inequalityQuery = collection.where('bar', isGreaterThan: 5);

        final result = await inequalityQuery
            .orderBy('bar')
            .startAfterDocument(startAtSnapshot)
            .get();

        expect(result.size, equals(2));
        expect(result.docs[0].id, equals('doc3'));
        expect(result.docs[1].id, equals('doc4'));
      });
    });

    /**
     * Start & End
     */

    group('Query.startAt/endAt', () {
      test('starts at & ends at a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('start-end-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
          collection.doc('doc4').set({
            'foo': 4,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').startAt([2]).endAt([3]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));
      });

      test('starts at & ends before a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('start-end-string');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
          collection.doc('doc4').set({
            'foo': 4,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').startAt([2]).endBefore([4]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));
      });

      test('starts after & ends at a document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('start-end-field-path');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
          collection.doc('doc4').set({
            'foo': 4,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').startAfter([1]).endAt([3]).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));
      });

      test('starts a document and ends before document', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('start-end-document');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
          collection.doc('doc4').set({
            'foo': 4,
          }),
        ]);

        DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
        DocumentSnapshot endBeforeSnapshot = await collection.doc('doc4').get();

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .startAtDocument(startAtSnapshot)
            .endBeforeDocument(endBeforeSnapshot)
            .get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));
      });
    });

    /**
     * Limit
     */

    group('Query.limit{toLast}()', () {
      test('limits documents', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('limit');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.limit(2).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 =
            await collection.orderBy('foo', descending: true).limit(2).get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc3'));
        expect(snapshot2.docs[1].id, equals('doc2'));
      });

      test('limits to last documents', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('limitToLast');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').limitToLast(2).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc2'));
        expect(snapshot.docs[1].id, equals('doc3'));

        QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
            .orderBy('foo', descending: true)
            .limitToLast(2)
            .get();

        expect(snapshot2.docs.length, equals(2));
        expect(snapshot2.docs[0].id, equals('doc2'));
        expect(snapshot2.docs[1].id, equals('doc1'));
      });
    });

    /**
     * Order
     */
    group('Query.orderBy()', () {
      test('allows ordering by documentId', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('order-document-id');

        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 1,
          }),
          collection.doc('doc3').set({
            'foo': 1,
          }),
          collection.doc('doc4').set({
            'bar': 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').orderBy(FieldPath.documentId).get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc3'));
      });

      test('orders async by default', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('order-asc');

        await Future.wait([
          collection.doc('doc1').set({
            'foo': 3,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo').get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc1'));
      });

      test('orders descending', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('order-desc');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 1,
          }),
          collection.doc('doc2').set({
            'foo': 2,
          }),
          collection.doc('doc3').set({
            'foo': 3,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.orderBy('foo', descending: true).get();

        expect(snapshot.docs.length, equals(3));
        expect(snapshot.docs[0].id, equals('doc3'));
        expect(snapshot.docs[1].id, equals('doc2'));
        expect(snapshot.docs[2].id, equals('doc1'));
      });
    });

    /**
     * Where filters
     */

    group('Query.where()', () {
      test('returns documents when querying for properties that are not null',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('not-null');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 'bar',
          }),
          collection.doc('doc2').set({
            'foo': 'bar',
          }),
          collection.doc('doc3').set({
            'foo': null,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isNull: false).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].id, equals('doc1'));
        expect(snapshot.docs[1].id, equals('doc2'));
      });

      test('returns documents when querying properties that are equal to null',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('not-null');
        await Future.wait([
          collection.doc('doc1').set({
            'foo': 'bar',
          }),
          collection.doc('doc2').set({
            'foo': 'bar',
          }),
          collection.doc('doc3').set({
            'foo': null,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isNull: true).get();

        expect(snapshot.docs.length, equals(1));
        expect(snapshot.docs[0].id, equals('doc3'));
      });

      test('returns with equal checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-equal');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': rand,
          }),
          collection.doc('doc2').set({
            'foo': rand,
          }),
          collection.doc('doc3').set({
            'foo': rand + 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isEqualTo: rand).get();

        expect(snapshot.docs.length, equals(2));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'], equals(rand));
        });
      });

      test('returns with not equal checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-not-equal');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': rand,
          }),
          collection.doc('doc2').set({
            'foo': rand,
          }),
          collection.doc('doc3').set({
            'foo': rand + 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isNotEqualTo: rand).get();

        expect(snapshot.docs.length, equals(1));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'], equals(rand + 1));
        });
      });

      test('returns with greater than checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-greater-than');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': rand - 1,
          }),
          collection.doc('doc2').set({
            'foo': rand,
          }),
          collection.doc('doc3').set({
            'foo': rand + 1,
          }),
          collection.doc('doc4').set({
            'foo': rand + 2,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isGreaterThan: rand).get();

        expect(snapshot.docs.length, equals(2));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'] > rand, isTrue);
        });
      });

      test('returns with greater than or equal to checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-greater-than-equal');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': rand - 1,
          }),
          collection.doc('doc2').set({
            'foo': rand,
          }),
          collection.doc('doc3').set({
            'foo': rand + 1,
          }),
          collection.doc('doc4').set({
            'foo': rand + 2,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isGreaterThanOrEqualTo: rand).get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'] >= rand, isTrue);
        });
      });

      test('returns with less than checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-less-than');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': -rand + 1,
          }),
          collection.doc('doc2').set({
            'foo': -rand + 2,
          }),
          collection.doc('doc3').set({
            'foo': rand,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isLessThan: rand).get();

        expect(snapshot.docs.length, equals(2));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'] < rand, isTrue);
        });
      });

      test('returns with less than equal checks', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-less-than');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': -rand + 1,
          }),
          collection.doc('doc2').set({
            'foo': -rand + 2,
          }),
          collection.doc('doc3').set({
            'foo': rand,
          }),
          collection.doc('doc4').set({
            'foo': rand + 1,
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', isLessThanOrEqualTo: rand).get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'] <= rand, isTrue);
        });
      });

      test('returns with array-contains filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-array-contains');
        int rand = Random().nextInt(9999);

        await Future.wait([
          collection.doc('doc1').set({
            'foo': [1, '2', rand],
          }),
          collection.doc('doc2').set({
            'foo': [1, '2', '$rand'],
          }),
          collection.doc('doc3').set({
            'foo': [1, '2', '$rand'],
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where('foo', arrayContains: '$rand').get();

        expect(snapshot.docs.length, equals(2));
        snapshot.docs.forEach((doc) {
          expect(doc.data()['foo'], equals([1, '2', '$rand']));
        });
      });

      test('returns with in filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-in');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('status', whereIn: ['Ready to Ship', 'Ordered']).get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
        });
      });

      test('returns with in filter using Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-in-iterable');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where(
              'status',
              // To force the list to be an iterable
              whereIn: ['Ready to Ship', 'Ordered'].map((e) => e),
            )
            .get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
        });
      });

      test('returns with in filter using Set', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-in');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('status', whereIn: {'Ready to Ship', 'Ordered'}).get();

        expect(snapshot.docs.length, equals(3));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
        });
      });

      test('returns with not-in filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-not-in');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('status', whereNotIn: ['Ready to Ship', 'Ordered']).get();

        expect(snapshot.docs.length, equals(1));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Incomplete', isTrue);
        });
      });

      test('returns with not-in filter with Iterable', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-not-in');

        await Future.wait([
          collection.doc('doc1').set({
            'status': 'Ordered',
          }),
          collection.doc('doc2').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc3').set({
            'status': 'Ready to Ship',
          }),
          collection.doc('doc4').set({
            'status': 'Incomplete',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('status', whereNotIn: {'Ready to Ship', 'Ordered'}).get();

        expect(snapshot.docs.length, equals(1));
        snapshot.docs.forEach((doc) {
          String status = doc.data()['status'];
          expect(status == 'Incomplete', isTrue);
        });
      });

      test('returns with array-contains-any filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-array-contains-any');

        await Future.wait([
          collection.doc('doc1').set({
            'category': ['Appliances', 'Housewares', 'Cooking'],
          }),
          collection.doc('doc2').set({
            'category': ['Appliances', 'Electronics', 'Nursery'],
          }),
          collection.doc('doc3').set({
            'category': ['Audio/Video', 'Electronics'],
          }),
          collection.doc('doc4').set({
            'category': ['Beauty'],
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection.where(
          'category',
          arrayContainsAny: ['Appliances', 'Electronics'],
        ).get();

        // 2nd record should only be returned once
        expect(snapshot.docs.length, equals(3));
      });

      test('returns with array-contains-any filter using Set', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-array-contains-any');

        await Future.wait([
          collection.doc('doc1').set({
            'category': ['Appliances', 'Housewares', 'Cooking'],
          }),
          collection.doc('doc2').set({
            'category': ['Appliances', 'Electronics', 'Nursery'],
          }),
          collection.doc('doc3').set({
            'category': ['Audio/Video', 'Electronics'],
          }),
          collection.doc('doc4').set({
            'category': ['Beauty'],
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection.where(
          'category',
          arrayContainsAny: {'Appliances', 'Electronics'},
        ).get();

        // 2nd record should only be returned once
        expect(snapshot.docs.length, equals(3));
      });

      // When documents have a key with a '.' in them, only a [FieldPath]
      // can access the value, rather than a raw string
      test('returns where FieldPath', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-field-path');

        FieldPath fieldPath = FieldPath(const ['nested', 'foo.bar@gmail.com']);

        await Future.wait([
          collection.doc('doc1').set({
            'nested': {
              'foo.bar@gmail.com': true,
            },
          }),
          collection.doc('doc2').set({
            'nested': {
              'foo.bar@gmail.com': true,
            },
            'foo': 'bar',
          }),
          collection.doc('doc3').set({
            'nested': {
              'foo.bar@gmail.com': false,
            },
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot =
            await collection.where(fieldPath, isEqualTo: true).get();

        expect(snapshot.docs.length, equals(2));
        expect(snapshot.docs[0].get(fieldPath), isTrue);
        expect(snapshot.docs[1].get(fieldPath), isTrue);
        expect(snapshot.docs[1].get('foo'), equals('bar'));
      });

      test('returns results using FieldPath.documentId', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-field-path-document-id');

        DocumentReference<Map<String, dynamic>> docRef = await collection.add({
          'foo': 'bar',
        });

        // Add secondary document for sanity check
        await collection.add({
          'bar': 'baz',
        });

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where(FieldPath.documentId, isEqualTo: docRef.id)
            .get();

        expect(snapshot.docs.length, equals(1));
        expect(snapshot.docs[0].get('foo'), equals('bar'));
      });

      test('returns an encoded DocumentReference', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-document-reference');

        DocumentReference<Map<String, dynamic>> ref =
            FirebaseFirestore.instance.doc('foo/bar');

        await Future.wait([
          collection.add({
            'foo': ref,
          }),
          collection.add({
            'foo': FirebaseFirestore.instance.doc('bar/baz'),
          }),
          collection.add({
            'foo': 'foo/bar',
          }),
        ]);

        QuerySnapshot<Map<String, dynamic>> snapshot = await collection
            .where('foo', isEqualTo: FirebaseFirestore.instance.doc('foo/bar'))
            .get();

        expect(snapshot.docs.length, equals(1));
        expect(snapshot.docs[0].get('foo'), equals(ref));
      });
    });

    group('Query.where() with Filter class', () {
      test(
          'returns documents with `DocumentReference` as an argument in `isEqualTo`',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('doc-ref-arg-isequal-to');
        final ref = FirebaseFirestore.instance.doc('foo/bar');
        final ref2 = FirebaseFirestore.instance.doc('foo/foo');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': 'fantasy',
            'title': 'Book A',
            'ref': FirebaseFirestore.instance.doc('foo/bar'),
          }),
          collection.doc('doc2').set({
            'genre': 'fantasy',
            'title': 'Book B',
            'ref': FirebaseFirestore.instance.doc('foo/bar'),
          }),
          collection.doc('doc3').set({
            'genre': 'fantasy',
            'title': 'Book C',
            'ref': ref2,
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter.and(
                  Filter('genre', isEqualTo: 'fantasy'),
                  Filter('ref', isEqualTo: ref),
                ),
                Filter.and(
                  Filter('genre', isEqualTo: 'fantasy'),
                  Filter(
                    'ref',
                    isEqualTo: ref2,
                  ),
                ),
              ),
            )
            .orderBy('title', descending: true)
            .get();

        expect(results.docs.length, equals(3));
        expect(results.docs[0].data()['title'], equals('Book C'));
        expect(results.docs[1].data()['title'], equals('Book B'));
        expect(results.docs[2].data()['title'], equals('Book A'));
      });

      test(
          'returns documents with `DocumentReference` as an argument in `arrayContains`',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('doc-ref-arg-array-contains');
        final ref = FirebaseFirestore.instance.doc('foo/bar');
        final ref2 = FirebaseFirestore.instance.doc('foo/foo');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': 'fantasy',
            'title': 'Book A',
            'ref': [ref],
          }),
          collection.doc('doc2').set({
            'genre': 'fantasy',
            'title': 'Book B',
            'ref': [ref],
          }),
          collection.doc('doc3').set({
            'genre': 'adventure',
            'title': 'Book C',
            'ref': [ref2],
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter.and(
                  Filter('genre', isEqualTo: 'fantasy'),
                  Filter('ref', arrayContains: ref),
                ),
                Filter.and(
                  Filter('genre', isEqualTo: 'adventure'),
                  Filter(
                    'ref',
                    arrayContains: ref2,
                  ),
                ),
              ),
            )
            .orderBy('title', descending: true)
            .get();

        expect(results.docs.length, equals(3));
        expect(results.docs[0].data()['title'], equals('Book C'));
        expect(results.docs[1].data()['title'], equals('Book B'));
        expect(results.docs[2].data()['title'], equals('Book A'));
      });

      test('returns documents with OR filter for arrayContainsAny', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-array-contains-any');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'title': 'Book A',
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'title': 'Book B',
          }),
          collection.doc('doc3').set({
            'genre': ['mystery', 'thriller'],
            'title': 'Book C',
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter('genre', arrayContainsAny: ['fantasy']),
                Filter('genre', arrayContainsAny: ['sci-fi']),
              ),
            )
            .orderBy('title', descending: true)
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('Book B'));
        expect(results.docs[1].data()['title'], equals('Book A'));
      });

      test('returns documents with AND filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-and');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 3.8,
          }),
          collection.doc('doc3').set({
            'genre': ['sci-fi', 'action'],
            'rating': 4.2,
          }),
        ]);

        final results = await collection
            .where(
              Filter.and(
                Filter('genre', arrayContains: 'sci-fi'),
                Filter('rating', isGreaterThanOrEqualTo: 4.0),
              ),
            )
            .orderBy('rating', descending: true)
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc3'));
        expect(results.docs[0].data()['rating'], equals(4.2));
        expect(results.docs[0].data()['genre'], equals(['sci-fi', 'action']));
      });

      test('returns documents with OR filter and a previous condition',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-and');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': 'fantasy',
            'rating': 4.5,
            'year': 1970,
          }),
          collection.doc('doc2').set({
            'genre': 'fantasy',
            'rating': 3.8,
            'year': 1980,
          }),
          collection.doc('doc3').set({
            'genre': 'sci-fi',
            'rating': 4.2,
            'year': 1980,
          }),
        ]);

        final results = await collection
            .where('genre', isEqualTo: 'fantasy')
            .where(
              Filter.or(
                Filter('year', isEqualTo: 1980),
                Filter('rating', isGreaterThanOrEqualTo: 4.0),
              ),
            )
            .orderBy('rating')
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[0].data()['rating'], equals(3.8));
        expect(results.docs[1].id, equals('doc1'));
        expect(results.docs[1].data()['rating'], equals(4.5));
      });

      test('returns documents with nested OR and AND filters', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-nested');
        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 3.8,
          }),
          collection.doc('doc3').set({
            'genre': ['sci-fi', 'action'],
            'rating': 4.2,
          }),
          collection.doc('doc4').set({
            'genre': ['mystery', 'action'],
            'rating': 4.7,
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter.and(
                  Filter('genre', arrayContains: 'sci-fi'),
                  Filter('rating', isGreaterThanOrEqualTo: 4.0),
                ),
                Filter.and(
                  Filter('genre', arrayContains: 'mystery'),
                  Filter('rating', isGreaterThanOrEqualTo: 4.5),
                ),
              ),
            )
            .orderBy('rating', descending: true)
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc4'));
        expect(results.docs[0].data()['rating'], equals(4.7));
        expect(
          results.docs[0].data()['genre'],
          equals(['mystery', 'action']),
        );
        expect(results.docs[1].id, equals('doc3'));
        expect(results.docs[1].data()['rating'], equals(4.2));
        expect(results.docs[1].data()['genre'], equals(['sci-fi', 'action']));
      });

      test('allow FieldPathType for Filter queries', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('filter-path-type');

        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 3.8,
          }),
          collection.doc('doc3').set({
            'genre': ['sci-fi', 'action'],
            'rating': 4.2,
          }),
          collection.doc('doc4').set({
            'genre': ['mystery', 'action'],
            'rating': 4.7,
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter.and(
                  Filter(FieldPath.documentId, isEqualTo: 'doc1'),
                  Filter('rating', isEqualTo: 4.5),
                ),
                Filter.and(
                  Filter(FieldPath.documentId, isEqualTo: 'doc2'),
                  Filter('rating', isEqualTo: 3.8),
                ),
              ),
            )
            .orderBy(FieldPath.documentId, descending: false)
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[0].data()['rating'], equals(4.5));

        expect(results.docs[1].id, equals('doc2'));
        expect(results.docs[1].data()['rating'], equals(3.8));
      });

      test('allow multiple conjunctive queries', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('multiple-conjunctive-queries');

        final matchMap = {
          'rating1': 3.8,
          'year1': 1970,
          'runtime1': 90,
          'director1': 'Director2',
          'producer1': 'Producer2',
          'budget1': 20000000,
          'boxOffice1': 50000000,
          'actor1': 'Actor2',
          'language1': 'English',
          'award1': 'Award2',
          'genre1': ['sci-fi', 'thriller'],
          'country1': 'USA',
          'released1': true,
          'screenplay1': 'Screenplay2',
          'cinematography1': 'Cinematography2',
          'music1': 'Music2',
          'rating2': 4.2,
          'year2': 1982,
          'runtime2': 60,
          'director2': 'Director3',
          'producer2': 'Producer3',
          'budget2': 30000000,
          'boxOffice2': 60000000,
          'actor2': 'Actor3',
          'language2': 'Korean',
          'award2': 'Award3',
          'genre2': ['sci-fi', 'action'],
          'country2': 'South Korea',
          'released2': false,
          'screenplay2': 'Screenplay3',
        };

        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
            'director': 'Director1',
            'producer': 'Producer1',
            'budget': 10000000,
            'boxOffice': 25000000,
            'actor': 'Actor1',
            'language': 'English',
            'award': 'Award1',
          }),
          collection.doc('doc2').set(matchMap),
          collection.doc('doc3').set(matchMap),
        ]);

        final results = await collection
            .where(
              Filter.and(
                Filter('rating1', isEqualTo: 3.8),
                Filter('year1', isEqualTo: 1970),
                Filter('runtime1', isEqualTo: 90),
                Filter('director1', isEqualTo: 'Director2'),
                Filter('producer1', isEqualTo: 'Producer2'),
                Filter('budget1', isEqualTo: 20000000),
                Filter('boxOffice1', isEqualTo: 50000000),
                Filter('actor1', isEqualTo: 'Actor2'),
                Filter('language1', isEqualTo: 'English'),
                Filter('award1', isEqualTo: 'Award2'),
                Filter('genre1', arrayContainsAny: ['sci-fi']),
                Filter('country1', isEqualTo: 'USA'),
                Filter('released1', isEqualTo: true),
                Filter('screenplay1', isEqualTo: 'Screenplay2'),
                Filter('cinematography1', isEqualTo: 'Cinematography2'),
                Filter('music1', isEqualTo: 'Music2'),
                Filter('rating2', isEqualTo: 4.2),
                Filter('year2', isEqualTo: 1982),
                Filter('runtime2', isEqualTo: 60),
                Filter('director2', isEqualTo: 'Director3'),
                Filter('producer2', isEqualTo: 'Producer3'),
                Filter('budget2', isEqualTo: 30000000),
                Filter('boxOffice2', isEqualTo: 60000000),
                Filter('actor2', isEqualTo: 'Actor3'),
                Filter('language2', isEqualTo: 'Korean'),
                Filter('award2', isEqualTo: 'Award3'),
                Filter('genre2', isEqualTo: ['sci-fi', 'action']),
                Filter('country2', isEqualTo: 'South Korea'),
                Filter('released2', isEqualTo: false),
                Filter('screenplay2', isEqualTo: 'Screenplay3'),
              ),
            )
            .orderBy('rating1', descending: true)
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc3'));
        expect(results.docs[1].id, equals('doc2'));
      });

      test(
        'Can combine `arrayContainsAny` & `isNotEqualTo` in multiple conjunctive queries',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest(
            'array-contain-not-equal-conjunctive-queries',
          );

          await Future.wait([
            collection.doc('doc1').set({
              'genre': ['fantasy', 'sci-fi'],
              'screenplay2': 'bar',
            }),
            collection.doc('doc2').set({
              'genre': ['fantasy', 'sci-fi'],
              'screenplay2': 'bar',
            }),
            collection.doc('doc3').set({
              'genre': ['fantasy', 'sci-fi'],
              'screenplay2': 'foo',
            }),
          ]);

          final results = await collection
              .where(
                Filter.and(
                  Filter('genre', arrayContainsAny: ['sci-fi']),
                  Filter('screenplay2', isNotEqualTo: 'foo'),
                ),
              )
              .orderBy('screenplay2', descending: true)
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc2'));
          expect(results.docs[1].id, equals('doc1'));
        },
      );

      test('allow multiple disjunctive queries', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('multiple-disjunctive-queries');

        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['fantasy', 'action'],
            'rating': 4.5,
            'director': 'Director1',
            'producer': 'Producer1',
            'country': 'USA',
            'budget': 10000000,
            'boxOffice': 25000000,
            'actor': 'Actor1',
          }),
          collection.doc('doc2').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 3.8,
            'year': 1970,
            'runtime': 90,
            'released': true,
            'country': 'Wales',
            'director': 'Director2',
            'producer': 'Producer2',
            'budget': 20000000,
            'boxOffice': 50000000,
            'actor': 'Actor2',
            'language': 'English',
            'award': 'Award2',
          }),
          collection.doc('doc3').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 4.2,
            'year': 1982,
            'runtime': 60,
            'released': false,
            'country': 'Wales',
            'director': 'Director3',
            'producer': 'Producer3',
            'budget': 30000000,
            'boxOffice': 60000000,
            'actor': 'Actor3',
            'language': 'Korean',
            'award': 'Award3',
          }),
          collection.doc('doc4').set({
            'genre': ['sci-fi', 'thriller'],
            'rating': 4.7,
            'year': 1990,
            'runtime': 120,
            'released': true,
            'country': 'Wales',
            'director': 'Director4',
            'producer': 'Producer4',
            'budget': 40000000,
            'boxOffice': 80000000,
            'actor': 'Actor4',
            'language': 'Welsh',
            'award': 'Award4',
          }),
        ]);

        final results = await collection
            .where(
              Filter.or(
                Filter('rating', isEqualTo: 3.8),
                Filter('year', isEqualTo: 1970),
                Filter('runtime', isEqualTo: 90),
                Filter('director', isEqualTo: 'Director2'),
                Filter('country', isEqualTo: 'Wales'),
                Filter('budget', isEqualTo: 20000000),
                Filter('boxOffice', isEqualTo: 50000000),
                Filter('genre', arrayContainsAny: ['sci-fi']),
                Filter('actor', isEqualTo: 'Actor2'),
                Filter('language', isEqualTo: 'English'),
                Filter('award', isEqualTo: 'Award2'),
                Filter('screenWriter', isEqualTo: 'ScreenWriter2'),
                Filter('editor', isEqualTo: 'Editor2'),
                Filter('cinematographer', isEqualTo: 'Cinematographer2'),
                Filter('releaseCountry', isEqualTo: 'Country2'),
                Filter('distributor', isEqualTo: 'Distributor2'),
                Filter('ratingSystem', isEqualTo: 'RatingSystem2'),
                Filter('soundtrackComposer', isEqualTo: 'Composer2'),
                Filter('visualEffectsCompany', isEqualTo: 'EffectsCompany2'),
                Filter('productionCompany', isEqualTo: 'ProductionCompany2'),
                Filter('filmFormat', isEqualTo: 'FilmFormat2'),
                Filter('aspectRatio', isEqualTo: 'AspectRatio2'),
                Filter('colorProcess', isEqualTo: 'ColorProcess2'),
                Filter('soundProcess', isEqualTo: 'SoundProcess2'),
                Filter('numberOfTheaters', isEqualTo: 2000),
                Filter('openingWeekendRevenue', isEqualTo: 10000000),
                Filter('totalDomesticRevenue', isEqualTo: 60000000),
                Filter('totalWorldwideRevenue', isEqualTo: 200000000),
                Filter('estimatedProfit', isEqualTo: 140000000),
                Filter('mainCharacter', isEqualTo: 'MainCharacter2'),
              ),
            )
            .orderBy('rating', descending: true)
            .get();

        expect(results.docs.length, equals(3));
        expect(results.docs[0].id, equals('doc4'));
        expect(results.docs[0].data()['rating'], equals(4.7));
        expect(
          results.docs[0].data()['genre'],
          equals(['sci-fi', 'thriller']),
        );
        expect(results.docs[1].id, equals('doc3'));
        expect(results.docs[1].data()['rating'], equals(4.2));
        expect(results.docs[1].data()['genre'], equals(['sci-fi', 'thriller']));
        expect(results.docs[2].id, equals('doc2'));
        expect(results.docs[2].data()['rating'], equals(3.8));
        expect(results.docs[2].data()['genre'], equals(['sci-fi', 'thriller']));
      });

      test(
        'Can combine  `arrayContainsAny` & `isNotEqualTo` in disjunctive queries',
        () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest(
            'array-contain-not-equal-disjunctive-queries',
          );

          await Future.wait([
            collection.doc('doc1').set({
              'genre': ['fantasy', 'sci-fi'],
              'screenplay2': 'bar',
            }),
            collection.doc('doc2').set({
              'genre': ['fantasy', 'sci-fi'],
              'mainCharacter': 'MainCharacter2',
            }),
            collection.doc('doc3').set({
              'genre': ['fantasy', 'something else'],
              'mainCharacter': 'foo',
            }),
            collection.doc('doc4').set({
              'genre': ['fantasy', 'something else'],
              'mainCharacter': 'MainCharacter2',
            }),
          ]);

          final results = await collection
              .where(
                Filter.or(
                  Filter('genre', arrayContainsAny: ['sci-fi']),
                  Filter('mainCharacter', isNotEqualTo: 'MainCharacter2'),
                ),
              )
              .orderBy('mainCharacter', descending: true)
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc3'));
          expect(results.docs[1].id, equals('doc2'));
        },
      );

      test(
          'allow multiple disjunctive queries for "arrayContainsAny" using ".where() API"',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('multiple-disjunctive-where');

        await Future.wait([
          collection.doc('doc1').set({
            'genre': ['Not', 'Here'],
            'number': 1,
          }),
          collection.doc('doc2').set({
            'genre': ['Animation', 'Another'],
            'number': 2,
          }),
          collection.doc('doc3').set({
            'genre': ['Adventure', 'Another'],
            'number': 3,
          }),
        ]);
        final genres = [
          'Action',
          'Adventure',
          'Animation',
          'Biography',
          'Comedy',
          'Crime',
          'Drama',
          'Documentary',
          'Family',
          'Fantasy',
          'Film-Noir',
          'History',
          'Horror',
          'Music',
          'Musical',
          'Mystery',
          'Romance',
          'Sci-Fi',
          'Sport',
          'Thriller',
          'War',
          'Western',
          'Epic',
          'Tragedy',
          'Satire',
          'Romantic Comedy',
          'Black Comedy',
          'Paranormal',
          'Non-fiction',
          'Realism',
        ];

        final results = await collection
            .where(
              'genre',
              arrayContainsAny: genres,
            )
            .orderBy('number')
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test(
          'allow multiple disjunctive queries for "whereIn" using ".where() API"',
          () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('multiple-disjunctive-where');

        await Future.wait([
          collection.doc('doc1').set({'genre': 'Not this', 'number': 1}),
          collection.doc('doc2').set({'genre': 'Animation', 'number': 2}),
          collection.doc('doc3').set({'genre': 'Adventure', 'number': 3}),
        ]);
        final genres = [
          'Action',
          'Adventure',
          'Animation',
          'Biography',
          'Comedy',
          'Crime',
          'Drama',
          'Documentary',
          'Family',
          'Fantasy',
          'Film-Noir',
          'History',
          'Horror',
          'Music',
          'Musical',
          'Mystery',
          'Romance',
          'Sci-Fi',
          'Sport',
          'Thriller',
          'War',
          'Western',
          'Epic',
          'Tragedy',
          'Satire',
          'Romantic Comedy',
          'Black Comedy',
          'Paranormal',
          'Non-fiction',
          'Realism',
        ];

        final results = await collection
            .where(
              'genre',
              whereIn: genres,
            )
            .orderBy('number')
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test('"whereIn" query combined with "arrayContainsAny"', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-arraycontainsany-in-combined');
        await Future.wait([
          collection.doc('doc1').set({
            'value': [1, 2, 3],
            'prop': 'foo',
          }),
          collection.doc('doc2').set({
            'value': [2, 4, 5],
            'prop': 'bar',
          }),
          collection.doc('doc3').set({
            'value': [6, 7, 8],
            'prop': 'basalt',
          }),
        ]);

        final results = await collection
            .where(
              'value',
              arrayContainsAny: [1, 7],
            )
            .where(
              'prop',
              whereIn: ['foo', 'basalt'],
            )
            .orderBy('prop')
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc3'));
        expect(results.docs[1].id, equals('doc1'));
      });

      test('isEqualTo filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isequalto');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 5}),
          collection.doc('doc3').set({'value': 7}),
        ]);

        final results = await collection
            .where(
              Filter('value', isEqualTo: 5),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[1].id, equals('doc2'));
      });

      test('isNotEqualTo filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isnotequalto');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 5}),
          collection.doc('doc3').set({'value': 7}),
        ]);

        final results = await collection
            .where(
              Filter('value', isNotEqualTo: 5),
            )
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc3'));
      });

      test('isLessThan filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-islessthan');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 7}),
          collection.doc('doc3').set({'value': 9}),
        ]);

        final results = await collection
            .where(
              Filter('value', isLessThan: 7),
            )
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc1'));
      });

      test('isLessThanOrEqualTo filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-islessthanequalto');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 7}),
          collection.doc('doc3').set({'value': 9}),
        ]);

        final results = await collection
            .where(
              Filter('value', isLessThanOrEqualTo: 7),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[1].id, equals('doc2'));
      });

      test('isGreaterThan filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isgreaterthan');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 7}),
          collection.doc('doc3').set({'value': 9}),
        ]);

        final results = await collection
            .where(
              Filter('value', isGreaterThan: 5),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test('isGreaterThanOrEqualTo filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isgreaterthanequalto');
        await Future.wait([
          collection.doc('doc1').set({'value': 5}),
          collection.doc('doc2').set({'value': 7}),
          collection.doc('doc3').set({'value': 9}),
        ]);

        final results = await collection
            .where(
              Filter('value', isGreaterThanOrEqualTo: 7),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc2'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test('arrayContains filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-arraycontains');
        await Future.wait([
          collection.doc('doc1').set({
            'value': [1, 2, 3],
          }),
          collection.doc('doc2').set({
            'value': [1, 4, 5],
          }),
          collection.doc('doc3').set({
            'value': [6, 7, 8],
          }),
        ]);

        final results = await collection
            .where(
              Filter('value', arrayContains: 1),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[1].id, equals('doc2'));
      });

      test('arrayContainsAny filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-arraycontainsany');
        await Future.wait([
          collection.doc('doc1').set({
            'value': [1, 2, 3],
          }),
          collection.doc('doc2').set({
            'value': [1, 4, 5],
          }),
          collection.doc('doc3').set({
            'value': [6, 7, 8],
          }),
        ]);

        final results = await collection
            .where(
              Filter('value', arrayContainsAny: [1, 7]),
            )
            .get();

        expect(results.docs.length, equals(3));
      });

      test('whereIn filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-wherein');
        await Future.wait([
          collection.doc('doc1').set({'value': 'A'}),
          collection.doc('doc2').set({'value': 'B'}),
          collection.doc('doc3').set({'value': 'C'}),
        ]);

        final results = await collection
            .where(
              Filter('value', whereIn: ['A', 'C']),
            )
            .get();

        expect(results.docs.length, equals(2));
        expect(results.docs[0].id, equals('doc1'));
        expect(results.docs[1].id, equals('doc3'));
      });

      test('whereNotIn filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-wherenotin');
        await Future.wait([
          collection.doc('doc1').set({'value': 'A'}),
          collection.doc('doc2').set({'value': 'B'}),
          collection.doc('doc3').set({'value': 'C'}),
        ]);

        final results = await collection
            .where(
              Filter('value', whereNotIn: ['A', 'C']),
            )
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc2'));
      });

      test('isNull filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('where-filter-isnull');
        await Future.wait([
          collection.doc('doc1').set({'value': 'A'}),
          collection.doc('doc2').set({'value': null}),
          collection.doc('doc3').set({'value': 'C'}),
        ]);

        final results = await collection
            .where(
              Filter('value', isNull: true),
            )
            .get();

        expect(results.docs.length, equals(1));
        expect(results.docs[0].id, equals('doc2'));
      });

      test('endAt filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endat-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .endAt([3]).get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
      });

      test('endBefore filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endbefore-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // endBefore
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .endBefore([4]).get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
      });

      test('endBeforeDocument filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('endbeforedocument-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        final documentSnapshot = await collection.doc('doc4').get();

        // endBeforeDocument
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .endBeforeDocument(documentSnapshot)
            .get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
      });

      test('limit filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('limit-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // limit
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .limit(2)
            .get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
      });

      test('limitToLast filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('limittolast-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // limitToLast
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .limitToLast(2)
            .get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('D'));
        expect(results.docs[1].data()['title'], equals('E'));
      });

      test('orderBy filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('orderby-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // orderBy
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: true)
            .get();
        expect(results.docs.length, equals(4));
        expect(results.docs[0].data()['title'], equals('E'));
        expect(results.docs[1].data()['title'], equals('D'));
        expect(results.docs[2].data()['title'], equals('C'));
        expect(results.docs[3].data()['title'], equals('B'));
      });

      test('startAfter filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startafter-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        // startAfter
        results = await collection
            .where(Filter('value', isGreaterThan: 3))
            .orderBy('value', descending: false)
            .startAfter([2]).get();
        expect(results.docs.length, equals(2));
        expect(results.docs[0].data()['title'], equals('D'));
        expect(results.docs[1].data()['title'], equals('E'));
      });

      test('startAfterDocument filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startafterdocument-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        final documentSnapshot = await collection.doc('doc2').get();

// startAfterDocument
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .startAfterDocument(documentSnapshot)
            .get();
        expect(results.docs.length, equals(3));
        expect(results.docs[0].data()['title'], equals('C'));
        expect(results.docs[1].data()['title'], equals('D'));
        expect(results.docs[2].data()['title'], equals('E'));
      });

      test('startAt filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startat-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

// startAt
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .startAt([2]).get();
        expect(results.docs.length, equals(4));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
        expect(results.docs[2].data()['title'], equals('D'));
        expect(results.docs[3].data()['title'], equals('E'));
      });

      test('startAtDocument filter', () async {
        CollectionReference<Map<String, dynamic>> collection =
            await initializeTest('startatdocument-filter');
        await Future.wait([
          collection.doc('doc1').set({'value': 1, 'title': 'A'}),
          collection.doc('doc2').set({'value': 2, 'title': 'B'}),
          collection.doc('doc3').set({'value': 3, 'title': 'C'}),
          collection.doc('doc4').set({'value': 4, 'title': 'D'}),
          collection.doc('doc5').set({'value': 5, 'title': 'E'}),
        ]);

        QuerySnapshot<Map<String, dynamic>> results;

        final documentSnapshot = await collection.doc('doc2').get();

// startAtDocument
        results = await collection
            .where(Filter('value', isGreaterThan: 1))
            .orderBy('value', descending: false)
            .startAtDocument(documentSnapshot)
            .get();
        expect(results.docs.length, equals(4));
        expect(results.docs[0].data()['title'], equals('B'));
        expect(results.docs[1].data()['title'], equals('C'));
        expect(results.docs[2].data()['title'], equals('D'));
        expect(results.docs[3].data()['title'], equals('E'));
      });
    });

    group('withConverter', () {
      test(
        'from a query instead of collection',
        () async {
          final collection = await initializeTest('foo');

          final query = collection //
              .where('value', isGreaterThan: 0)
              .withConverter<int>(
                fromFirestore: (snapshots, _) =>
                    snapshots.data()!['value']! as int,
                toFirestore: (value, _) => {'value': value},
              );

          await collection.add({'value': 42});
          await collection.add({'value': -1});

          final snapshot = query.snapshots();

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ]),
            ),
          );

          await collection.add({'value': 21});

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having(
                (e) => e.docs,
                'docs',
                unorderedEquals(
                  [
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 42),
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 21),
                  ],
                ),
              ),
            ),
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'from a Filter query instead of collection',
        () async {
          final collection = await initializeTest('foo');

          final query = collection
              .where(Filter('value', isGreaterThan: 0))
              .withConverter<int>(
                fromFirestore: (snapshots, _) =>
                    snapshots.data()!['value']! as int,
                toFirestore: (value, _) => {'value': value},
              );

          await collection.add({'value': 42});
          await collection.add({'value': -1});

          final snapshot = query.snapshots();

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ]),
            ),
          );

          await collection.add({'value': 21});

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having(
                (e) => e.docs,
                'docs',
                unorderedEquals(
                  [
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 42),
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 21),
                  ],
                ),
              ),
            ),
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'snapshots',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(-1);

          final snapshot =
              converted.where('value', isGreaterThan: 0).snapshots();

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ]),
            ),
          );

          await converted.add(21);

          await expectLater(
            snapshot,
            emits(
              isA<QuerySnapshot<int>>().having(
                (e) => e.docs,
                'docs',
                unorderedEquals([
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 21),
                ]),
              ),
            ),
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'get',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(-1);

          expect(
            await converted
                .where('value', isGreaterThan: 0)
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42)],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'orderBy',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(21);

          expect(
            await converted.orderBy('value').get().then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 21),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'limit',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(21);

          expect(
            await converted.orderBy('value').limit(1).get().then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 21),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'limitToLast',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(42);
          await converted.add(21);

          expect(
            await converted
                .orderBy('value')
                .limitToLast(1)
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 42),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test('endAt', () async {
        final collection = await initializeTest('foo');

        final converted = collection.withConverter<int>(
          fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
          toFirestore: (value, _) => {'value': value},
        );

        await converted.add(1);
        await converted.add(2);
        await converted.add(3);

        expect(
          await converted.orderBy('value').endAt([2]).get().then((d) => d.docs),
          [
            isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
            isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
          ],
        );
      });

      test('endAt with Iterable', () async {
        final collection = await initializeTest('foo');

        final converted = collection.withConverter<int>(
          fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
          toFirestore: (value, _) => {'value': value},
        );

        await converted.add(1);
        await converted.add(2);
        await converted.add(3);

        expect(
          await converted.orderBy('value').endAt({2}).get().then((d) => d.docs),
          [
            isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
            isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
          ],
        );
      });

      test(
        'endAtDocument',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          final doc2 = await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endAtDocument(await doc2.get())
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test('endBefore', () async {
        final collection = await initializeTest('foo');

        final converted = collection.withConverter<int>(
          fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
          toFirestore: (value, _) => {'value': value},
        );

        await converted.add(1);
        await converted.add(2);
        await converted.add(3);

        expect(
          await converted
              .orderBy('value')
              .endBefore([2])
              .get()
              .then((d) => d.docs),
          [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
        );
      });

      test('endBefore with Iterable', () async {
        final collection = await initializeTest('foo');

        final converted = collection.withConverter<int>(
          fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
          toFirestore: (value, _) => {'value': value},
        );

        await converted.add(1);
        await converted.add(2);
        await converted.add(3);

        expect(
          await converted
              .orderBy('value')
              .endBefore({2})
              .get()
              .then((d) => d.docs),
          [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
        );
      });

      test(
        'endBeforeDocument',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          final doc2 = await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endBeforeDocument(await doc2.get())
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAt',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAt([2])
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAt with Iterable',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAt({2})
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAtDocument',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          final doc2 = await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAtDocument(await doc2.get())
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
            ],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAfter',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAfter([2])
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAfter with Iterable',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAfter({2})
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
          );
        },
        timeout: const Timeout.factor(3),
      );

      test(
        'startAfterDocument',
        () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          final doc2 = await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .startAfterDocument(await doc2.get())
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
          );
        },
        timeout: const Timeout.factor(3),
      );
    });

    group('Aggregate Queries', () {
      test(
        'count()',
        () async {
          final collection = await initializeTest('count');

          await Future.wait([
            collection.add({'foo': 'bar'}),
            collection.add({'bar': 'baz'}),
          ]);

          AggregateQuery query = collection.count();

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.count,
            2,
          );
        },
      );

      test(
        'count() with query',
        () async {
          final collection = await initializeTest('count');

          await Future.wait([
            collection.add({'foo': 'bar'}),
            collection.add({'foo': 'baz'}),
          ]);

          AggregateQuery query =
              collection.where('foo', isEqualTo: 'bar').count();

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.count,
            1,
          );
        },
      );

      test(
        'sum()',
        () async {
          final collection = await initializeTest('sum');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query = collection.aggregate(sum('foo'));

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.getSum('foo'),
            3,
          );
        },
      );

      test(
        'sum() with query',
        () async {
          final collection = await initializeTest('sum');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query =
              collection.where('foo', isEqualTo: 1).aggregate(sum('foo'));

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.getSum('foo'),
            1,
          );
        },
      );

      test(
        'average()',
        () async {
          final collection = await initializeTest('avg');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query = collection.aggregate(average('foo'));

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.getAverage('foo'),
            1.5,
          );
        },
      );

      test(
        'average() with query',
        () async {
          final collection = await initializeTest('avg');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query =
              collection.where('foo', isEqualTo: 1).aggregate(average('foo'));

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.getAverage('foo'),
            1,
          );
        },
      );

      test(
        'chaining aggregate queries',
        () async {
          final collection = await initializeTest('chaining');

          await Future.wait([
            collection.add({'foo': 1}),
            collection.add({'foo': 2}),
          ]);

          AggregateQuery query =
              collection.aggregate(count(), sum('foo'), average('foo'));
          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.count,
            2,
          );

          expect(
            snapshot.getSum('foo'),
            3,
          );

          expect(
            snapshot.getAverage('foo'),
            1.5,
          );
        },
      );

      test('chaining multiples aggregate queries', () async {
        final collection = await initializeTest('chaining');

        await Future.wait([
          collection.add({'foo': 1}),
          collection.add({'foo': 2}),
        ]);

        AggregateQuery query = collection
            .where('foo', isEqualTo: 1)
            .aggregate(count(), sum('foo'), average('foo'));

        AggregateQuerySnapshot snapshot = await query.get();

        expect(
          snapshot.count,
          1,
        );

        expect(
          snapshot.getSum('foo'),
          1,
        );

        expect(
          snapshot.getAverage('foo'),
          1,
        );
      });

      test(
        'count() with collectionGroup',
        () async {
          const subCollection = 'aggregate-group-count';
          final doc1 = FirebaseFirestore.instance
              .collection('flutter-tests')
              .doc('agg1');
          final doc2 = FirebaseFirestore.instance
              .collection('flutter-tests')
              .doc('agg2');
          await Future.wait([
            doc1.set({'foo': 'bar'}),
            doc2.set({'foo': 'baz'}),
          ]);

          final collection = doc1.collection(subCollection);
          final collection2 = doc2.collection(subCollection);

          await Future.wait([
            // 6 sub-documents
            collection.doc('agg1').set({'foo': 'bar'}),
            collection.doc('agg2').set({'foo': 'bar'}),
            collection.doc('agg3').set({'foo': 'bar'}),
            collection2.doc('agg4').set({'foo': 'bar'}),
            collection2.doc('agg5').set({'foo': 'bar'}),
            collection2.doc('agg6').set({'foo': 'bar'}),
          ]);

          AggregateQuery query =
              FirebaseFirestore.instance.collectionGroup(subCollection).count();

          AggregateQuerySnapshot snapshot = await query.get();

          expect(
            snapshot.count,
            6,
          );
        },
      );

      test('count(), average() & sum() on empty collection', () async {
        final collection = await initializeTest('empty-collection');

        final snapshot = await collection
            .aggregate(count(), sum('foo'), average('foo'))
            .get();
        expect(snapshot.count, 0);
        expect(snapshot.getSum('foo'), 0);
        expect(snapshot.getAverage('foo'), null);
      });
    });

    group('startAfterDocument', () {
      test('startAfterDocument() accept DocumentReference in query parameters',
          () async {
        final collection = await initializeTest('start-after-document');

        final doc1 = collection.doc('1');
        final doc2 = collection.doc('2');
        final doc3 = collection.doc('3');
        final doc4 = collection.doc('4');
        await doc1.set({'ref': doc1});
        await doc2.set({'ref': doc2});
        await doc3.set({'ref': doc3});
        await doc4.set({'ref': null});

        final q = collection
            .where('ref', isNull: false)
            .orderBy('ref')
            .startAfterDocument(await doc1.get());

        final res = await q.get();
        expect(res.docs.map((e) => e.reference), [doc2, doc3]);
      });
    });

    group('WhereIn Filter', () {
      test('Multiple whereIn filters should not trigger an assertion',
          () async {
        try {
          final collection = await initializeTest('multipe-whereIn-clause');

          Map<String, String> data = {};

          for (int i = 1; i <= 10; i++) {
            data['field$i'] = 'value$i';
          }

          await collection.doc().set(data);

          Query<Map<String, dynamic>> query = collection;
          data.forEach((field, values) {
            query = query.where(field, whereIn: [values]);
          });

          await query.get();
        } on AssertionError catch (e) {
          fail('Test failed due to AssertionError: $e');
        }
      });

      test(
          'Multiple whereIn filters exceeding DNF 30 clause limit should trigger an assertion',
          () async {
        try {
          final collection = await initializeTest('multipe-whereIn-clause');

          await collection.doc().set({'genre': 'fiction'});
          await collection.doc().set({'author': 'Author A'});

          // DNF for this query = 36 (6 genres * 6 authors) exceeding the 30 clause limit
          await collection.where(
            'genre',
            whereIn: [
              'fiction',
              'non-fiction',
              'fantasy',
              'science-fiction',
              'mystery',
              'thriller',
            ],
          ).where(
            'author',
            whereIn: [
              'Author A',
              'Author B',
              'Author C',
              'Author D',
              'Author E',
              'Author F',
            ],
          ).get();
        } catch (error) {
          expect(error, isA<FirebaseException>());
        }
      });
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\second_database.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
import 'dart:async';
import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

// ignore: do_not_use_environment
const bool skipTestsOnCI = bool.fromEnvironment('CI');

String getCurrentPlatform() {
  if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
    return 'android';
  } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.iOS) {
    return 'ios';
  } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.macOS) {
    return 'macos';
  } else if (!kIsWeb && defaultTargetPlatform == TargetPlatform.windows) {
    return 'windows';
  } else if (kIsWeb) {
    return 'web';
  } else {
    return 'unknown';
  }
}

void runSecondDatabaseTests() {
  group(
    'Second Database',
    () {
      late FirebaseFirestore firestore;
      String collectionForSecondDatabase = 'flutterfire-2';

      setUpAll(() async {
        firestore = FirebaseFirestore.instanceFor(
          app: Firebase.app(),
          databaseId: 'flutterfire-2',
        );

        firestore.useFirestoreEmulator('localhost', 8080);
      });

      Future<CollectionReference<Map<String, dynamic>>> initializeTest(
        String id,
      ) async {
        // Pushed rules which only allow database "flutterfire-2" to have "flutterfire-2" collection writes

        CollectionReference<Map<String, dynamic>> collection =
            firestore.collection(
          '$collectionForSecondDatabase/${getCurrentPlatform()}/$id',
        );
        QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

        List<Future> deleteFutures = snapshot.docs.map((documentSnapshot) {
          return documentSnapshot.reference.delete();
        }).toList();

        await Future.wait(deleteFutures);
        return collection;
      }

      group(
          'queries for default database are banned for this collection: "$collectionForSecondDatabase"',
          () {
        test('barred query', () async {
          final defaultFirestore = FirebaseFirestore.instance;
          try {
            await defaultFirestore
                .collection(collectionForSecondDatabase)
                .add({'foo': 'bar'});
            fail('Should have thrown a [FirebaseException]');
          } catch (e) {
            expect(e, isA<FirebaseException>());
            expect((e as FirebaseException).code, equals('permission-denied'));
          }
        });
      });

      group('equality', () {
        // testing == override using e2e tests as it is dependent on the platform
        test('handles deeply compares query parameters', () async {
          final movies = firestore.collection('/movies');
          final starWarsComments =
              firestore.collection('/movies/star-wars/comments');

          expect(
            movies.where('genre', arrayContains: ['Flutter']),
            movies.where('genre', arrayContains: ['Flutter']),
          );
          expect(
            movies.where('genre', arrayContains: ['Flutter']),
            isNot(movies.where('genre', arrayContains: ['React'])),
          );
          expect(
            movies.where('genre', arrayContains: ['Flutter']),
            isNot(starWarsComments.where('genre', arrayContains: ['Flutter'])),
          );
        });

        test('differentiate queries from a different app instance', () async {
          final fooApp = await Firebase.initializeApp(
            name: 'foo',
            options: Firebase.app().options,
          );

          expect(
            FirebaseFirestore.instanceFor(app: fooApp)
                .collection('movies')
                .limit(42),
            FirebaseFirestore.instanceFor(app: fooApp)
                .collection('movies')
                .limit(42),
          );

          expect(
            firestore.collection('movies').limit(42),
            isNot(
              FirebaseFirestore.instanceFor(app: fooApp)
                  .collection('movies')
                  .limit(42),
            ),
          );
        });

        test('differentiate collection group', () async {
          expect(
            firestore.collectionGroup('comments').limit(42),
            firestore.collectionGroup('comments').limit(42),
          );
          expect(
            firestore.collectionGroup('comments').limit(42),
            isNot(firestore.collection('comments').limit(42)),
          );
        });
      });
      /**
       * get
       */
      group('Query.get()', () {
        test('returns a [QuerySnapshot]', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs = await collection.get();
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        });

        test('uses [GetOptions] cache', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs =
              await collection.get(const GetOptions(source: Source.cache));
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
          expect(qs.metadata.isFromCache, isTrue);
        });

        test('uses [GetOptions] server', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs =
              await collection.get(const GetOptions(source: Source.server));
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
          expect(qs.metadata.isFromCache, isFalse);
        });

        test('uses [GetOptions] serverTimestampBehavior previous', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs = await collection.get(
            const GetOptions(
              serverTimestampBehavior: ServerTimestampBehavior.previous,
            ),
          );
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        });

        test('uses [GetOptions] serverTimestampBehavior estimate', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          QuerySnapshot<Map<String, dynamic>> qs = await collection.get(
            const GetOptions(
              serverTimestampBehavior: ServerTimestampBehavior.estimate,
            ),
          );
          expect(qs, isA<QuerySnapshot<Map<String, dynamic>>>());
        });

        test(
          'throws a [FirebaseException]',
          () async {
            CollectionReference<Map<String, dynamic>> collection =
                firestore.collection('not-allowed');

            try {
              await collection.get();
            } catch (error) {
              expect(error, isA<FirebaseException>());
              expect(
                (error as FirebaseException).code,
                equals('permission-denied'),
              );
              return;
            }
            fail('Should have thrown a [FirebaseException]');
          },
          // Emulator for 2nd database allows this request, the live project correctly throws a "permission-denied" error
          skip: true,
        );
      });

      /**
       * snapshots
       */
      group('Query.snapshots()', () {
        test('returns a [Stream]', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get');
          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots();
          expect(stream, isA<Stream<QuerySnapshot<Map<String, dynamic>>>>());
        });

        test('listens to a single response', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get-single');
          await collection.add({'foo': 'bar'});
          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots();

          StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? subscription;

          subscription = stream.listen(
            expectAsync1(
              (QuerySnapshot<Map<String, dynamic>> snapshot) {
                expect(snapshot.docs.length, equals(1));

                expect(snapshot.docs[0], isA<QueryDocumentSnapshot>());
                QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                    snapshot.docs[0];
                expect(documentSnapshot.data()['foo'], equals('bar'));
              },
              reason: 'Stream should only have been called once.',
            ),
          );

          addTearDown(() async {
            await subscription?.cancel();
          });
        });

        test('listens to multiple queries', () async {
          CollectionReference<Map<String, dynamic>> collection1 =
              await initializeTest('document-snapshot-1');
          CollectionReference<Map<String, dynamic>> collection2 =
              await initializeTest('document-snapshot-2');

          await collection1.add({'test': 'value1'});
          await collection2.add({'test': 'value2'});

          final value1 = collection1
              .snapshots()
              .first
              .then((s) => s.docs.first.data()['test']);
          final value2 = collection2
              .snapshots()
              .first
              .then((s) => s.docs.first.data()['test']);

          await expectLater(value1, completion('value1'));
          await expectLater(value2, completion('value2'));
        });

        test('listens to a multiple changes response', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('get-multiple');
          await collection.add({'foo': 'bar'});

          Stream<QuerySnapshot<Map<String, dynamic>>> stream =
              collection.snapshots();
          int call = 0;

          StreamSubscription subscription = stream.listen(
            expectAsync1(
              (QuerySnapshot<Map<String, dynamic>> snapshot) {
                call++;
                if (call == 1) {
                  expect(snapshot.docs.length, equals(1));
                  QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                      snapshot.docs[0];
                  expect(documentSnapshot.data()['foo'], equals('bar'));
                } else if (call == 2) {
                  expect(snapshot.docs.length, equals(2));
                  QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                      snapshot.docs.firstWhere((doc) => doc.id == 'doc1');
                  expect(documentSnapshot.data()['bar'], equals('baz'));
                } else if (call == 3) {
                  expect(snapshot.docs.length, equals(1));
                  expect(
                    snapshot.docs.where((doc) => doc.id == 'doc1').isEmpty,
                    isTrue,
                  );
                } else if (call == 4) {
                  expect(snapshot.docs.length, equals(2));
                  QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                      snapshot.docs.firstWhere((doc) => doc.id == 'doc2');
                  expect(documentSnapshot.data()['foo'], equals('bar'));
                } else if (call == 5) {
                  expect(snapshot.docs.length, equals(2));
                  QueryDocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                      snapshot.docs.firstWhere((doc) => doc.id == 'doc2');
                  expect(documentSnapshot.data()['foo'], equals('baz'));
                } else {
                  fail('Should not have been called');
                }
              },
              count: 5,
              reason: 'Stream should only have been called five times.',
            ),
          );

          await Future.delayed(const Duration(milliseconds: 500));
          await collection.doc('doc1').set({'bar': 'baz'});
          await collection.doc('doc1').delete();
          await collection.doc('doc2').set({'foo': 'bar'});
          await collection.doc('doc2').update({'foo': 'baz'});

          await subscription.cancel();
        });

        test(
          'listeners throws a [FirebaseException]',
          () async {
            CollectionReference<Map<String, dynamic>> collection =
                firestore.collection('not-allowed');
            Stream<QuerySnapshot<Map<String, dynamic>>> stream =
                collection.snapshots();

            try {
              await stream.first;
            } catch (error) {
              expect(error, isA<FirebaseException>());
              expect(
                (error as FirebaseException).code,
                equals(
                  'permission-denied',
                ),
              );
              return;
            }

            fail('Should have thrown a [FirebaseException]');
          },
          // Emulator for 2nd database allows this request, the live project correctly throws a "permission-denied" error
          skip: true,
        );
      });

      /**
       * End At
       */

      group('Query.endAt{Document}()', () {
        test('ends at string field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .endAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').endAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('ends at string field paths with Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .endAt({2}).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').endAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('ends at field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy(FieldPath(const ['bar', 'value']), descending: true)
              .endAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy(FieldPath(const ['foo']))
              .endAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('endAtDocument() ends at a document field value', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 1},
            }),
          ]);

          DocumentSnapshot endAtSnapshot = await collection.doc('doc2').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value')
              .endAtDocument(endAtSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));
        });

        test('endAtDocument() ends at a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endAt-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 4},
            }),
          ]);

          DocumentSnapshot endAtSnapshot = await collection.doc('doc3').get();

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.endAtDocument(endAtSnapshot).get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc3'));
        });
      });

      /**
       * Start At
       */

      group('Query.startAt{Document}()', () {
        test('starts at string field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .startAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').startAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('starts at string field paths with Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .startAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').startAt({2}).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('starts at field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy(FieldPath(const ['bar', 'value']), descending: true)
              .startAt([2]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy(FieldPath(const ['foo']))
              .startAt([2]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('startAtDocument() starts at a document field value', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-document-field-value');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 1},
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value')
              .startAtDocument(startAtSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));
        });

        test('startAtDocument() starts at a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAt-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 4},
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc3').get();

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.startAtDocument(startAtSnapshot).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc4'));
        });
      });

      /**
       * End Before
       */

      group('Query.endBefore{Document}()', () {
        test('ends before string field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .endBefore([1]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').endBefore([3]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('ends before string field paths with Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .endBefore({1}).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').endBefore([3]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('ends before field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy(FieldPath(const ['bar', 'value']), descending: true)
              .endBefore([1]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy(FieldPath(const ['foo']))
              .endBefore([3]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc1'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('endbeforeDocument() ends before a document field value',
            () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-document-field-value');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 1},
            }),
          ]);

          DocumentSnapshot endAtSnapshot = await collection.doc('doc1').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value')
              .endBeforeDocument(endAtSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));
        });

        test('endBeforeDocument() ends before a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endBefore-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 4},
            }),
          ]);

          DocumentSnapshot endAtSnapshot = await collection.doc('doc4').get();

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.endBeforeDocument(endAtSnapshot).get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc3'));
        });
      });

      /**
       * Start after
       */
      group('Query.startAfter{Document}()', () {
        test('starts after string field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfter-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value', descending: true)
              .startAfter([3]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo').startAfter([1]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('starts after field paths', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfter-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'foo': 2,
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'foo': 3,
              'bar': {'value': 3},
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy(FieldPath(const ['bar', 'value']), descending: true)
              .startAfter([3]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy(FieldPath(const ['foo']))
              .startAfter([1]).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc3'));
        });

        test('startAfterDocument() starts after a document field value',
            () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfter-document-field-value');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 1},
            }),
          ]);

          DocumentSnapshot startAfterSnapshot =
              await collection.doc('doc3').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('bar.value')
              .startAfterDocument(startAfterSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc1'));
        });

        test('startAfterDocument() starts after a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startAfter-document');
          await Future.wait([
            collection.doc('doc1').set({
              'bar': {'value': 1},
            }),
            collection.doc('doc2').set({
              'bar': {'value': 2},
            }),
            collection.doc('doc3').set({
              'bar': {'value': 3},
            }),
            collection.doc('doc4').set({
              'bar': {'value': 4},
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.startAfterDocument(startAtSnapshot).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc4'));
        });
      });

      /**
       * Start & End
       */

      group('Query.startAt/endAt', () {
        test('starts at & ends at a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('start-end-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
            collection.doc('doc4').set({
              'foo': 4,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').startAt([2]).endAt([3]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));
        });

        test('starts at & ends before a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('start-end-string');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
            collection.doc('doc4').set({
              'foo': 4,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').startAt([2]).endBefore([4]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));
        });

        test('starts after & ends at a document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('start-end-field-path');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
            collection.doc('doc4').set({
              'foo': 4,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').startAfter([1]).endAt([3]).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));
        });

        test('starts a document and ends before document', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('start-end-document');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
            collection.doc('doc4').set({
              'foo': 4,
            }),
          ]);

          DocumentSnapshot startAtSnapshot = await collection.doc('doc2').get();
          DocumentSnapshot endBeforeSnapshot =
              await collection.doc('doc4').get();

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .startAtDocument(startAtSnapshot)
              .endBeforeDocument(endBeforeSnapshot)
              .get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));
        });
      });

      /**
       * Limit
       */

      group('Query.limit{toLast}()', () {
        test('limits documents', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('limit');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.limit(2).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 =
              await collection.orderBy('foo', descending: true).limit(2).get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc3'));
          expect(snapshot2.docs[1].id, equals('doc2'));
        });

        test('limits to last documents', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('limitToLast');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').limitToLast(2).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc2'));
          expect(snapshot.docs[1].id, equals('doc3'));

          QuerySnapshot<Map<String, dynamic>> snapshot2 = await collection
              .orderBy('foo', descending: true)
              .limitToLast(2)
              .get();

          expect(snapshot2.docs.length, equals(2));
          expect(snapshot2.docs[0].id, equals('doc2'));
          expect(snapshot2.docs[1].id, equals('doc1'));
        });
      });

      /**
       * Order
       */
      group('Query.orderBy()', () {
        test('allows ordering by documentId', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('order-document-id');

          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 1,
            }),
            collection.doc('doc3').set({
              'foo': 1,
            }),
            collection.doc('doc4').set({
              'bar': 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .orderBy('foo')
              .orderBy(FieldPath.documentId)
              .get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc3'));
        });

        test('orders async by default', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('order-asc');

          await Future.wait([
            collection.doc('doc1').set({
              'foo': 3,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo').get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc1'));
        });

        test('orders descending', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('order-desc');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 1,
            }),
            collection.doc('doc2').set({
              'foo': 2,
            }),
            collection.doc('doc3').set({
              'foo': 3,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.orderBy('foo', descending: true).get();

          expect(snapshot.docs.length, equals(3));
          expect(snapshot.docs[0].id, equals('doc3'));
          expect(snapshot.docs[1].id, equals('doc2'));
          expect(snapshot.docs[2].id, equals('doc1'));
        });
      });

      /**
       * Where filters
       */

      group('Query.where()', () {
        test('returns documents when querying for properties that are not null',
            () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('not-null');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 'bar',
            }),
            collection.doc('doc2').set({
              'foo': 'bar',
            }),
            collection.doc('doc3').set({
              'foo': null,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isNull: false).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].id, equals('doc1'));
          expect(snapshot.docs[1].id, equals('doc2'));
        });

        test(
            'returns documents when querying properties that are equal to null',
            () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('not-null');
          await Future.wait([
            collection.doc('doc1').set({
              'foo': 'bar',
            }),
            collection.doc('doc2').set({
              'foo': 'bar',
            }),
            collection.doc('doc3').set({
              'foo': null,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isNull: true).get();

          expect(snapshot.docs.length, equals(1));
          expect(snapshot.docs[0].id, equals('doc3'));
        });

        test('returns with equal checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-equal');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': rand,
            }),
            collection.doc('doc2').set({
              'foo': rand,
            }),
            collection.doc('doc3').set({
              'foo': rand + 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isEqualTo: rand).get();

          expect(snapshot.docs.length, equals(2));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'], equals(rand));
          });
        });

        test('returns with not equal checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-not-equal');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': rand,
            }),
            collection.doc('doc2').set({
              'foo': rand,
            }),
            collection.doc('doc3').set({
              'foo': rand + 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isNotEqualTo: rand).get();

          expect(snapshot.docs.length, equals(1));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'], equals(rand + 1));
          });
        });

        test('returns with greater than checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-greater-than');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': rand - 1,
            }),
            collection.doc('doc2').set({
              'foo': rand,
            }),
            collection.doc('doc3').set({
              'foo': rand + 1,
            }),
            collection.doc('doc4').set({
              'foo': rand + 2,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isGreaterThan: rand).get();

          expect(snapshot.docs.length, equals(2));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'] > rand, isTrue);
          });
        });

        test('returns with greater than or equal to checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-greater-than-equal');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': rand - 1,
            }),
            collection.doc('doc2').set({
              'foo': rand,
            }),
            collection.doc('doc3').set({
              'foo': rand + 1,
            }),
            collection.doc('doc4').set({
              'foo': rand + 2,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isGreaterThanOrEqualTo: rand).get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'] >= rand, isTrue);
          });
        });

        test('returns with less than checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-less-than');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': -rand + 1,
            }),
            collection.doc('doc2').set({
              'foo': -rand + 2,
            }),
            collection.doc('doc3').set({
              'foo': rand,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isLessThan: rand).get();

          expect(snapshot.docs.length, equals(2));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'] < rand, isTrue);
          });
        });

        test('returns with less than equal checks', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-less-than');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': -rand + 1,
            }),
            collection.doc('doc2').set({
              'foo': -rand + 2,
            }),
            collection.doc('doc3').set({
              'foo': rand,
            }),
            collection.doc('doc4').set({
              'foo': rand + 1,
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', isLessThanOrEqualTo: rand).get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'] <= rand, isTrue);
          });
        });

        test('returns with array-contains filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-array-contains');
          int rand = Random().nextInt(9999);

          await Future.wait([
            collection.doc('doc1').set({
              'foo': [1, '2', rand],
            }),
            collection.doc('doc2').set({
              'foo': [1, '2', '$rand'],
            }),
            collection.doc('doc3').set({
              'foo': [1, '2', '$rand'],
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where('foo', arrayContains: '$rand').get();

          expect(snapshot.docs.length, equals(2));
          snapshot.docs.forEach((doc) {
            expect(doc.data()['foo'], equals([1, '2', '$rand']));
          });
        });

        test('returns with in filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-in');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('status', whereIn: ['Ready to Ship', 'Ordered']).get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
          });
        });

        test('returns with in filter using Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-in-iterable');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where(
                'status',
                // To force the list to be an iterable
                whereIn: ['Ready to Ship', 'Ordered'].map((e) => e),
              )
              .get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
          });
        });

        test('returns with in filter using Set', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-in');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('status', whereIn: {'Ready to Ship', 'Ordered'}).get();

          expect(snapshot.docs.length, equals(3));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Ready to Ship' || status == 'Ordered', isTrue);
          });
        });

        test('returns with not-in filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-not-in');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('status', whereNotIn: ['Ready to Ship', 'Ordered']).get();

          expect(snapshot.docs.length, equals(1));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Incomplete', isTrue);
          });
        });

        test('returns with not-in filter with Iterable', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-not-in');

          await Future.wait([
            collection.doc('doc1').set({
              'status': 'Ordered',
            }),
            collection.doc('doc2').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc3').set({
              'status': 'Ready to Ship',
            }),
            collection.doc('doc4').set({
              'status': 'Incomplete',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('status', whereNotIn: {'Ready to Ship', 'Ordered'}).get();

          expect(snapshot.docs.length, equals(1));
          snapshot.docs.forEach((doc) {
            String status = doc.data()['status'];
            expect(status == 'Incomplete', isTrue);
          });
        });

        test('returns with array-contains-any filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-array-contains-any');

          await Future.wait([
            collection.doc('doc1').set({
              'category': ['Appliances', 'Housewares', 'Cooking'],
            }),
            collection.doc('doc2').set({
              'category': ['Appliances', 'Electronics', 'Nursery'],
            }),
            collection.doc('doc3').set({
              'category': ['Audio/Video', 'Electronics'],
            }),
            collection.doc('doc4').set({
              'category': ['Beauty'],
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection.where(
            'category',
            arrayContainsAny: ['Appliances', 'Electronics'],
          ).get();

          // 2nd record should only be returned once
          expect(snapshot.docs.length, equals(3));
        });

        test('returns with array-contains-any filter using Set', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-array-contains-any');

          await Future.wait([
            collection.doc('doc1').set({
              'category': ['Appliances', 'Housewares', 'Cooking'],
            }),
            collection.doc('doc2').set({
              'category': ['Appliances', 'Electronics', 'Nursery'],
            }),
            collection.doc('doc3').set({
              'category': ['Audio/Video', 'Electronics'],
            }),
            collection.doc('doc4').set({
              'category': ['Beauty'],
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection.where(
            'category',
            arrayContainsAny: {'Appliances', 'Electronics'},
          ).get();

          // 2nd record should only be returned once
          expect(snapshot.docs.length, equals(3));
        });

        // When documents have a key with a '.' in them, only a [FieldPath]
        // can access the value, rather than a raw string
        test('returns where FieldPath', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-field-path');

          FieldPath fieldPath =
              FieldPath(const ['nested', 'foo.bar@gmail.com']);

          await Future.wait([
            collection.doc('doc1').set({
              'nested': {
                'foo.bar@gmail.com': true,
              },
            }),
            collection.doc('doc2').set({
              'nested': {
                'foo.bar@gmail.com': true,
              },
              'foo': 'bar',
            }),
            collection.doc('doc3').set({
              'nested': {
                'foo.bar@gmail.com': false,
              },
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot =
              await collection.where(fieldPath, isEqualTo: true).get();

          expect(snapshot.docs.length, equals(2));
          expect(snapshot.docs[0].get(fieldPath), isTrue);
          expect(snapshot.docs[1].get(fieldPath), isTrue);
          expect(snapshot.docs[1].get('foo'), equals('bar'));
        });

        test('returns results using FieldPath.documentId', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-field-path-document-id');

          DocumentReference<Map<String, dynamic>> docRef =
              await collection.add({
            'foo': 'bar',
          });

          // Add secondary document for sanity check
          await collection.add({
            'bar': 'baz',
          });

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where(FieldPath.documentId, isEqualTo: docRef.id)
              .get();

          expect(snapshot.docs.length, equals(1));
          expect(snapshot.docs[0].get('foo'), equals('bar'));
        });

        test('returns an encoded DocumentReference', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-document-reference');

          DocumentReference<Map<String, dynamic>> ref =
              firestore.doc('foo/bar');

          await Future.wait([
            collection.add({
              'foo': ref,
            }),
            collection.add({
              'foo': firestore.doc('bar/baz'),
            }),
            collection.add({
              'foo': 'foo/bar',
            }),
          ]);

          QuerySnapshot<Map<String, dynamic>> snapshot = await collection
              .where('foo', isEqualTo: firestore.doc('foo/bar'))
              .get();

          expect(snapshot.docs.length, equals(1));
          expect(snapshot.docs[0].get('foo'), equals(ref));
        });
      });

      group('Query.where() with Filter class', () {
        test(
          'Can combine `arrayContainsAny` & `isNotEqualTo` in multiple disjunctive queries',
          () async {
            CollectionReference<Map<String, dynamic>> collection =
                await initializeTest('multiple-disjunctive-queries');

            await Future.wait([
              collection.add({
                'genre': 'sci-fi',
                'mainCharacter': 'Tim',
                'rating': 1,
              }),
              collection.add({
                'mainCharacter': 'MainCharacter2',
                'genre': 'action',
                'rating': 1,
              }),
              collection.add({
                'mainCharacter': 'MainCharacter2',
                'genre': 'action',
                'rating': 1,
              }),
            ]);
            final result = await collection
                .where(
                  Filter.or(
                    Filter('genre', arrayContainsAny: ['sci-fi']),
                    Filter('mainCharacter', isNotEqualTo: 'MainCharacter2'),
                  ),
                )
                .orderBy('rating', descending: true)
                .get();

            expect(result.docs.length, equals(1));
            expect(result.docs[0].data()['genre'], equals('sci-fi'));
          },
          // Emulator for 2nd database allows this request, the live project correctly throws a "permission-denied" error
          skip: true,
        );

        test(
          'Can combine `arrayContainsAny` & `isNotEqualTo` in multiple conjunctive queries',
          () async {
            CollectionReference<Map<String, dynamic>> collection =
                await initializeTest(
              'array-contain-not-equal-conjunctive-queries',
            );

            await Future.wait([
              collection.doc('doc1').set({
                'genre': ['fantasy', 'sci-fi'],
                'screenplay2': 'bar',
              }),
              collection.doc('doc2').set({
                'genre': ['fantasy', 'sci-fi'],
                'screenplay2': 'bar',
              }),
              collection.doc('doc3').set({
                'genre': ['fantasy', 'sci-fi'],
                'screenplay2': 'foo',
              }),
            ]);

            final results = await collection
                .where(
                  Filter.and(
                    Filter('genre', arrayContainsAny: ['sci-fi']),
                    Filter('screenplay2', isNotEqualTo: 'foo'),
                  ),
                )
                .orderBy('screenplay2', descending: true)
                .get();

            expect(results.docs.length, equals(2));
            expect(results.docs[0].id, equals('doc2'));
            expect(results.docs[1].id, equals('doc1'));
          },
          // Emulator for 2nd database allows this request, the live project correctly throws a "permission-denied" error
          skip: true,
        );

        test('isEqualTo filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isequalto');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 5}),
            collection.doc('doc3').set({'value': 7}),
          ]);

          final results = await collection
              .where(
                Filter('value', isEqualTo: 5),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc1'));
          expect(results.docs[1].id, equals('doc2'));
        });

        test('isNotEqualTo filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isnotequalto');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 5}),
            collection.doc('doc3').set({'value': 7}),
          ]);

          final results = await collection
              .where(
                Filter('value', isNotEqualTo: 5),
              )
              .get();

          expect(results.docs.length, equals(1));
          expect(results.docs[0].id, equals('doc3'));
        });

        test('isLessThan filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-islessthan');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 7}),
            collection.doc('doc3').set({'value': 9}),
          ]);

          final results = await collection
              .where(
                Filter('value', isLessThan: 7),
              )
              .get();

          expect(results.docs.length, equals(1));
          expect(results.docs[0].id, equals('doc1'));
        });

        test('isLessThanOrEqualTo filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-islessthanequalto');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 7}),
            collection.doc('doc3').set({'value': 9}),
          ]);

          final results = await collection
              .where(
                Filter('value', isLessThanOrEqualTo: 7),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc1'));
          expect(results.docs[1].id, equals('doc2'));
        });

        test('isGreaterThan filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isgreaterthan');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 7}),
            collection.doc('doc3').set({'value': 9}),
          ]);

          final results = await collection
              .where(
                Filter('value', isGreaterThan: 5),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc2'));
          expect(results.docs[1].id, equals('doc3'));
        });

        test('isGreaterThanOrEqualTo filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isgreaterthanequalto');
          await Future.wait([
            collection.doc('doc1').set({'value': 5}),
            collection.doc('doc2').set({'value': 7}),
            collection.doc('doc3').set({'value': 9}),
          ]);

          final results = await collection
              .where(
                Filter('value', isGreaterThanOrEqualTo: 7),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc2'));
          expect(results.docs[1].id, equals('doc3'));
        });

        test('arrayContains filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-arraycontains');
          await Future.wait([
            collection.doc('doc1').set({
              'value': [1, 2, 3],
            }),
            collection.doc('doc2').set({
              'value': [1, 4, 5],
            }),
            collection.doc('doc3').set({
              'value': [6, 7, 8],
            }),
          ]);

          final results = await collection
              .where(
                Filter('value', arrayContains: 1),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc1'));
          expect(results.docs[1].id, equals('doc2'));
        });

        test('arrayContainsAny filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-arraycontainsany');
          await Future.wait([
            collection.doc('doc1').set({
              'value': [1, 2, 3],
            }),
            collection.doc('doc2').set({
              'value': [1, 4, 5],
            }),
            collection.doc('doc3').set({
              'value': [6, 7, 8],
            }),
          ]);

          final results = await collection
              .where(
                Filter('value', arrayContainsAny: [1, 7]),
              )
              .get();

          expect(results.docs.length, equals(3));
        });

        test('whereIn filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-wherein');
          await Future.wait([
            collection.doc('doc1').set({'value': 'A'}),
            collection.doc('doc2').set({'value': 'B'}),
            collection.doc('doc3').set({'value': 'C'}),
          ]);

          final results = await collection
              .where(
                Filter('value', whereIn: ['A', 'C']),
              )
              .get();

          expect(results.docs.length, equals(2));
          expect(results.docs[0].id, equals('doc1'));
          expect(results.docs[1].id, equals('doc3'));
        });

        test('whereNotIn filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-wherenotin');
          await Future.wait([
            collection.doc('doc1').set({'value': 'A'}),
            collection.doc('doc2').set({'value': 'B'}),
            collection.doc('doc3').set({'value': 'C'}),
          ]);

          final results = await collection
              .where(
                Filter('value', whereNotIn: ['A', 'C']),
              )
              .get();

          expect(results.docs.length, equals(1));
          expect(results.docs[0].id, equals('doc2'));
        });

        test('isNull filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('where-filter-isnull');
          await Future.wait([
            collection.doc('doc1').set({'value': 'A'}),
            collection.doc('doc2').set({'value': null}),
            collection.doc('doc3').set({'value': 'C'}),
          ]);

          final results = await collection
              .where(
                Filter('value', isNull: true),
              )
              .get();

          expect(results.docs.length, equals(1));
          expect(results.docs[0].id, equals('doc2'));
        });

        test('endAt filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endat-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .endAt([3]).get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
        });

        test('endBefore filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endbefore-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // endBefore
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .endBefore([4]).get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
        });

        test('endBeforeDocument filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('endbeforedocument-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          final documentSnapshot = await collection.doc('doc4').get();

          // endBeforeDocument
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .endBeforeDocument(documentSnapshot)
              .get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
        });

        test('limit filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('limit-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // limit
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .limit(2)
              .get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
        });

        test('limitToLast filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('limittolast-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // limitToLast
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .limitToLast(2)
              .get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('D'));
          expect(results.docs[1].data()['title'], equals('E'));
        });

        test('orderBy filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('orderby-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // orderBy
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: true)
              .get();
          expect(results.docs.length, equals(4));
          expect(results.docs[0].data()['title'], equals('E'));
          expect(results.docs[1].data()['title'], equals('D'));
          expect(results.docs[2].data()['title'], equals('C'));
          expect(results.docs[3].data()['title'], equals('B'));
        });

        test('startAfter filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startafter-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          // startAfter
          results = await collection
              .where(Filter('value', isGreaterThan: 3))
              .orderBy('value', descending: false)
              .startAfter([2]).get();
          expect(results.docs.length, equals(2));
          expect(results.docs[0].data()['title'], equals('D'));
          expect(results.docs[1].data()['title'], equals('E'));
        });

        test('startAfterDocument filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startafterdocument-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          final documentSnapshot = await collection.doc('doc2').get();

// startAfterDocument
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .startAfterDocument(documentSnapshot)
              .get();
          expect(results.docs.length, equals(3));
          expect(results.docs[0].data()['title'], equals('C'));
          expect(results.docs[1].data()['title'], equals('D'));
          expect(results.docs[2].data()['title'], equals('E'));
        });

        test('startAt filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startat-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

// startAt
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .startAt([2]).get();
          expect(results.docs.length, equals(4));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
          expect(results.docs[2].data()['title'], equals('D'));
          expect(results.docs[3].data()['title'], equals('E'));
        });

        test('startAtDocument filter', () async {
          CollectionReference<Map<String, dynamic>> collection =
              await initializeTest('startatdocument-filter');
          await Future.wait([
            collection.doc('doc1').set({'value': 1, 'title': 'A'}),
            collection.doc('doc2').set({'value': 2, 'title': 'B'}),
            collection.doc('doc3').set({'value': 3, 'title': 'C'}),
            collection.doc('doc4').set({'value': 4, 'title': 'D'}),
            collection.doc('doc5').set({'value': 5, 'title': 'E'}),
          ]);

          QuerySnapshot<Map<String, dynamic>> results;

          final documentSnapshot = await collection.doc('doc2').get();

// startAtDocument
          results = await collection
              .where(Filter('value', isGreaterThan: 1))
              .orderBy('value', descending: false)
              .startAtDocument(documentSnapshot)
              .get();
          expect(results.docs.length, equals(4));
          expect(results.docs[0].data()['title'], equals('B'));
          expect(results.docs[1].data()['title'], equals('C'));
          expect(results.docs[2].data()['title'], equals('D'));
          expect(results.docs[3].data()['title'], equals('E'));
        });
      });

      group('withConverter', () {
        test(
          'from a query instead of collection',
          () async {
            final collection = await initializeTest('foo');

            final query = collection //
                .where('value', isGreaterThan: 0)
                .withConverter<int>(
                  fromFirestore: (snapshots, _) =>
                      snapshots.data()!['value']! as int,
                  toFirestore: (value, _) => {'value': value},
                );

            await collection.add({'value': 42});
            await collection.add({'value': -1});

            final snapshot = query.snapshots();

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                ]),
              ),
            );

            await collection.add({'value': 21});

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals(
                    [
                      isA<DocumentSnapshot<int>>()
                          .having((e) => e.data(), 'data', 42),
                      isA<DocumentSnapshot<int>>()
                          .having((e) => e.data(), 'data', 21),
                    ],
                  ),
                ),
              ),
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'from a Filter query instead of collection',
          () async {
            final collection = await initializeTest('foo');

            final query = collection //
                .where(Filter('value', isGreaterThan: 0))
                .withConverter<int>(
                  fromFirestore: (snapshots, _) =>
                      snapshots.data()!['value']! as int,
                  toFirestore: (value, _) => {'value': value},
                );

            await collection.add({'value': 42});
            await collection.add({'value': -1});

            final snapshot = query.snapshots();

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                ]),
              ),
            );

            await collection.add({'value': 21});

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals(
                    [
                      isA<DocumentSnapshot<int>>()
                          .having((e) => e.data(), 'data', 42),
                      isA<DocumentSnapshot<int>>()
                          .having((e) => e.data(), 'data', 21),
                    ],
                  ),
                ),
              ),
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'snapshots',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(-1);

            final snapshot =
                converted.where('value', isGreaterThan: 0).snapshots();

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having((e) => e.docs, 'docs', [
                  isA<DocumentSnapshot<int>>()
                      .having((e) => e.data(), 'data', 42),
                ]),
              ),
            );

            await converted.add(21);

            await expectLater(
              snapshot,
              emits(
                isA<QuerySnapshot<int>>().having(
                  (e) => e.docs,
                  'docs',
                  unorderedEquals([
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 42),
                    isA<DocumentSnapshot<int>>()
                        .having((e) => e.data(), 'data', 21),
                  ]),
                ),
              ),
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'get',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(-1);

            expect(
              await converted
                  .where('value', isGreaterThan: 0)
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'orderBy',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(21);

            expect(
              await converted.orderBy('value').get().then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 21),
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'limit',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(21);

            expect(
              await converted
                  .orderBy('value')
                  .limit(1)
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 21),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'limitToLast',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(42);
            await converted.add(21);

            expect(
              await converted
                  .orderBy('value')
                  .limitToLast(1)
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>()
                    .having((e) => e.data(), 'data', 42),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test('endAt', () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endAt([2])
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
            ],
          );
        });

        test('endAt with Iterable', () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endAt({2})
                .get()
                .then((d) => d.docs),
            [
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
              isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
            ],
          );
        });

        test(
          'endAtDocument',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            final doc2 = await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .endAtDocument(await doc2.get())
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1),
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test('endBefore', () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endBefore([2])
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
          );
        });

        test('endBefore with Iterable', () async {
          final collection = await initializeTest('foo');

          final converted = collection.withConverter<int>(
            fromFirestore: (snapshots, _) => snapshots.data()!['value']! as int,
            toFirestore: (value, _) => {'value': value},
          );

          await converted.add(1);
          await converted.add(2);
          await converted.add(3);

          expect(
            await converted
                .orderBy('value')
                .endBefore({2})
                .get()
                .then((d) => d.docs),
            [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
          );
        });

        test(
          'endBeforeDocument',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            final doc2 = await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .endBeforeDocument(await doc2.get())
                  .get()
                  .then((d) => d.docs),
              [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 1)],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAt',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAt([2])
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAt with Iterable',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAt({2})
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAtDocument',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            final doc2 = await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAtDocument(await doc2.get())
                  .get()
                  .then((d) => d.docs),
              [
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 2),
                isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3),
              ],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAfter',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAfter([2])
                  .get()
                  .then((d) => d.docs),
              [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAfter with Iterable',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAfter({2})
                  .get()
                  .then((d) => d.docs),
              [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'startAfterDocument',
          () async {
            final collection = await initializeTest('foo');

            final converted = collection.withConverter<int>(
              fromFirestore: (snapshots, _) =>
                  snapshots.data()!['value']! as int,
              toFirestore: (value, _) => {'value': value},
            );

            await converted.add(1);
            final doc2 = await converted.add(2);
            await converted.add(3);

            expect(
              await converted
                  .orderBy('value')
                  .startAfterDocument(await doc2.get())
                  .get()
                  .then((d) => d.docs),
              [isA<DocumentSnapshot<int>>().having((e) => e.data(), 'data', 3)],
            );
          },
          timeout: const Timeout.factor(3),
        );

        test(
          'count()',
          () async {
            final collection = await initializeTest('count');

            await Future.wait([
              collection.add({'foo': 'bar'}),
              collection.add({'bar': 'baz'}),
            ]);

            AggregateQuery query = collection.count();

            AggregateQuerySnapshot snapshot = await query.get();

            expect(
              snapshot.count,
              2,
            );
          },
        );

        test(
          'count() with query',
          () async {
            final collection = await initializeTest('count');

            await Future.wait([
              collection.add({'foo': 'bar'}),
              collection.add({'foo': 'baz'}),
            ]);

            AggregateQuery query =
                collection.where('foo', isEqualTo: 'bar').count();

            AggregateQuerySnapshot snapshot = await query.get();

            expect(
              snapshot.count,
              1,
            );
          },
        );
      });

      group('startAfterDocument', () {
        test(
            'startAfterDocument() accept DocumentReference in query parameters',
            () async {
          final collection = await initializeTest('start-after-document');

          final doc1 = collection.doc('1');
          final doc2 = collection.doc('2');
          final doc3 = collection.doc('3');
          final doc4 = collection.doc('4');
          await doc1.set({'ref': doc1});
          await doc2.set({'ref': doc2});
          await doc3.set({'ref': doc3});
          await doc4.set({'ref': null});

          final q = collection
              .where('ref', isNull: false)
              .orderBy('ref')
              .startAfterDocument(await doc1.get());

          final res = await q.get();
          expect(res.docs.map((e) => e.reference), [doc2, doc3]);
        });
      });
    },
    // Skipped on CI for web as the data is live and it clashes with other tests running in CI
    skip: kIsWeb && skipTestsOnCI,
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\settings_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runSettingsTest() {
  group(
    '$Settings',
    () {
      late FirebaseFirestore firestore;

      setUpAll(() async {
        firestore = FirebaseFirestore.instance;
      });

      Future<Settings> initializeTest() async {
        Settings firestoreSettings = const Settings(
          persistenceEnabled: false,
          webExperimentalForceLongPolling: true,
          webExperimentalAutoDetectLongPolling: true,
          webExperimentalLongPollingOptions: WebExperimentalLongPollingOptions(
            timeoutDuration: Duration(seconds: 15),
          ),
        );

        return firestore.settings = firestoreSettings;
      }

      test('checks if long polling settings were applied', () async {
        Settings settings = await initializeTest();

        expect(settings.webExperimentalForceLongPolling, true);

        expect(settings.webExperimentalAutoDetectLongPolling, true);

        expect(
          settings.webExperimentalLongPollingOptions,
          settings.webExperimentalLongPollingOptions,
        );
      });
    },
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\snapshot_metadata_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runSnapshotMetadataTests() {
  group(
    '$SnapshotMetadata',
    () {
      late FirebaseFirestore /*?*/ firestore;

      setUpAll(() async {
        firestore = FirebaseFirestore.instance;
      });

      Future<CollectionReference> initializeTest(String id) async {
        CollectionReference collection =
            firestore.collection('flutter-tests/$id/query-tests');
        QuerySnapshot snapshot = await collection.get();
        await Future.forEach(snapshot.docs,
            (DocumentSnapshot documentSnapshot) {
          return documentSnapshot.reference.delete();
        });
        return collection;
      }

      test('a snapshot returns the correct [isFromCache] value', () async {
        CollectionReference collection =
            await initializeTest('snapshot-metadata-is-from-cache');
        QuerySnapshot qs =
            await collection.get(const GetOptions(source: Source.cache));
        expect(qs.metadata.isFromCache, isTrue);

        QuerySnapshot qs2 =
            await collection.get(const GetOptions(source: Source.server));
        expect(qs2.metadata.isFromCache, isFalse);
      });
    },
    skip: kIsWeb,
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\timestamp_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runTimestampTests() {
  group('$Timestamp', () {
    late FirebaseFirestore /*?*/ firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    test('sets a $Timestamp & returns one', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('timestamp');
      DateTime date = DateTime.utc(3000);

      await doc.set({'foo': Timestamp.fromDate(date)});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
      Timestamp timestamp = snapshot.data()!['foo'];
      expect(timestamp, isA<Timestamp>());
      expect(
        timestamp.millisecondsSinceEpoch,
        equals(date.millisecondsSinceEpoch),
      );
    });

    test('updates a $Timestamp & returns', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('geo-point-update');
      DateTime date = DateTime.utc(3000, 01, 02);

      await doc.set({'foo': DateTime.utc(3000)});
      await doc.update({'foo': date});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
      Timestamp timestamp = snapshot.data()!['foo'];
      expect(timestamp, isA<Timestamp>());
      expect(
        timestamp.millisecondsSinceEpoch,
        equals(date.millisecondsSinceEpoch),
      );
    });

    test('set pre-1970 $Timestamp and return', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('timestamp');
      final date = DateTime(1969, 06, 22, 0, 0, 0, 123);
      final localTimestamp = Timestamp.fromDate(date);

      await doc.set({'foo': localTimestamp});

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();
      Timestamp retievedTimestamp = snapshot.data()!['foo'];
      expect(retievedTimestamp, isA<Timestamp>());
      expect(
        retievedTimestamp,
        equals(localTimestamp),
      );
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\transaction_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:math';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

void runTransactionTests() {
  group(
    '$Transaction',
    () {
      late FirebaseFirestore firestore;

      setUpAll(() async {
        firestore = FirebaseFirestore.instance;
      });

      Future<DocumentReference<Map<String, dynamic>>> initializeTest(
        String path,
      ) async {
        String prefixedPath = 'flutter-tests/$path';
        await firestore.doc(prefixedPath).delete();
        return firestore.doc(prefixedPath);
      }

      test('works with withConverter', () async {
        DocumentReference<Map<String, dynamic>> rawDoc =
            await initializeTest('with-converter-batch');

        DocumentReference<int> doc = rawDoc.withConverter(
          fromFirestore: (snapshot, options) {
            return snapshot.data()!['value'] as int;
          },
          toFirestore: (value, options) => {'value': value},
        );

        await doc.set(42);

        expect(
          await firestore.runTransaction<int?>((transaction) async {
            final snapshot = await transaction.get<int>(doc);
            return snapshot.data();
          }),
          42,
        );

        await firestore.runTransaction((transaction) async {
          transaction.set(doc, 21);
        });

        expect(await doc.get().then((s) => s.data()), 21);

        await firestore.runTransaction((transaction) async {
          transaction.update(doc, {'value': 0});
        });

        expect(await doc.get().then((s) => s.data()), 0);
      });

      test('should resolve with user value', () async {
        int randomValue = Random().nextInt(9999);
        int response = await firestore
            .runTransaction<int>((Transaction transaction) async {
          return randomValue;
        });
        expect(response, equals(randomValue));
      });

      test('should abort if thrown and not continue', () async {
        DocumentReference<Map<String, dynamic>> documentReference =
            await initializeTest('transaction-abort');

        await documentReference.set({'foo': 'bar'});

        try {
          await firestore.runTransaction((Transaction transaction) async {
            transaction.set(documentReference, {
              'foo': 'baz',
            });
            throw 'Stop';
          });
          // ignore: dead_code
          fail('Should have thrown');
        } catch (e) {
          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.data()!['foo'], equals('bar'));
        }
      });

      test(
        'should not collide if number of maxAttempts is enough',
        () async {
          DocumentReference<Map<String, dynamic>> doc1 =
              await initializeTest('transaction-maxAttempts-1');

          await doc1.set({'test': 0});

          await Future.wait([
            firestore.runTransaction(
              (Transaction transaction) async {
                final value = await transaction.get(doc1);
                transaction.set(doc1, {
                  'test': value['test'] + 1,
                });
              },
              maxAttempts: 2,
            ),
            firestore.runTransaction(
              (Transaction transaction) async {
                final value = await transaction.get(doc1);
                transaction.set(doc1, {
                  'test': value['test'] + 1,
                });
              },
              maxAttempts: 2,
            ),
          ]);

          DocumentSnapshot<Map<String, dynamic>> snapshot1 = await doc1.get();
          expect(snapshot1.data()!['test'], equals(2));
        },
        retry: 2,
      );

      test('should collide if number of maxAttempts is too low', () async {
        DocumentReference<Map<String, dynamic>> doc1 =
            await initializeTest('transaction-maxAttempts-2');

        await doc1.set({'test': 0});

        await expectLater(
          Future.wait([
            firestore.runTransaction(
              (Transaction transaction) async {
                final value = await transaction.get(doc1);
                transaction.set(doc1, {
                  'test': value['test'] + 1,
                });
              },
              maxAttempts: 1,
            ),
            firestore.runTransaction(
              (Transaction transaction) async {
                final value = await transaction.get(doc1);
                transaction.set(doc1, {
                  'test': value['test'] + 1,
                });
              },
              maxAttempts: 1,
            ),
          ]),
          throwsA(
            isA<FirebaseException>()
                .having((e) => e.code, 'code', 'failed-precondition'),
          ),
        );
      });

      test('runs multiple transactions in parallel', () async {
        DocumentReference<Map<String, dynamic>> doc1 =
            await initializeTest('transaction-multi-1');
        DocumentReference<Map<String, dynamic>> doc2 =
            await initializeTest('transaction-multi-2');

        await doc1.set({'test': 'value1'});
        await doc2.set({'test': 'value2'});

        await Future.wait([
          firestore.runTransaction((Transaction transaction) async {
            transaction.set(doc1, {
              'test': 'value3',
            });
          }),
          firestore.runTransaction((Transaction transaction) async {
            transaction.set(doc2, {
              'test': 'value4',
            });
          }),
        ]);

        DocumentSnapshot<Map<String, dynamic>> snapshot1 = await doc1.get();
        expect(snapshot1.data()!['test'], equals('value3'));
        DocumentSnapshot<Map<String, dynamic>> snapshot2 = await doc2.get();
        expect(snapshot2.data()!['test'], equals('value4'));
      });

      test('should abort if timeout is exceeded', () async {
        await expectLater(
          firestore.runTransaction(
            (Transaction transaction) =>
                Future.delayed(const Duration(seconds: 2)),
            timeout: const Duration(seconds: 1),
          ),
          throwsA(
            isA<FirebaseException>()
                .having((e) => e.code, 'code', 'deadline-exceeded'),
          ),
        );
      });

      test('should throw with exception', () async {
        try {
          await firestore.runTransaction((Transaction transaction) async {
            throw StateError('foo');
          });
          // ignore: dead_code
          fail('Transaction should not have resolved');
        } on StateError catch (e) {
          expect(e.message, equals('foo'));
          return;
        } catch (e) {
          fail('Transaction threw invalid exeption');
        }
      });

      test('should throw a native error, and convert to a [FirebaseException]',
          () async {
        DocumentReference<Map<String, dynamic>> documentReference =
            firestore.doc('not-allowed/document');

        try {
          await firestore.runTransaction((Transaction transaction) async {
            transaction.set(documentReference, {'foo': 'bar'});
          });
          fail('Transaction should not have resolved');
        } on FirebaseException catch (e) {
          expect(e.code, equals('permission-denied'));
          return;
        } catch (e) {
          fail('Transaction threw invalid exception');
        }
      });

      group('Transaction.get()', () {
        test('should throw if get is called after a command', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('flutter-tests/foo');

          expect(
            () => firestore.runTransaction((Transaction transaction) async {
              await transaction.get(documentReference);
              transaction.set(documentReference, {'foo': 'bar'});
              await transaction.get(documentReference);
            }),
            throwsAssertionError,
          );
        });

        test(
            'should throw a native error, and convert to a [FirebaseException]',
            () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              firestore.doc('not-allowed/document');

          try {
            await firestore.runTransaction((Transaction transaction) async {
              await transaction.get(documentReference);
            });
            fail('Transaction should not have resolved');
          } on FirebaseException catch (e) {
            expect(e.code, equals('permission-denied'));
            return;
          } catch (e) {
            fail('Transaction threw invalid exception');
          }
        });

        // ignore: todo
        // TODO(Salakar): Test seems to fail sometimes. Will look at in a future PR.
        // test('support returning any value, e.g. a [DocumentSnapshot]', () async {
        //   DocumentReference<Map<String, dynamic>> documentReference =
        //       await initializeTest('transaction-get');

        //   DocumentSnapshot<Map<String, dynamic>> snapshot =
        //       await firestore.runTransaction((Transaction transaction) async {
        //     DocumentSnapshot<Map<String, dynamic>> returned = await transaction.get(documentReference);
        //     // required:
        //     transaction.set(documentReference, {'foo': 'bar'});
        //     return returned;
        //   });

        //   expect(snapshot, isA<DocumentSnapshot>());
        //   expect(snapshot.reference.path, equals(documentReference.path));
        // }, skip: kUseFirestoreEmulator);
      });

      group('Transaction.delete()', () {
        test('should delete a document', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-delete');

          await documentReference.set({'foo': 'bar'});

          await firestore.runTransaction((Transaction transaction) async {
            transaction.delete(documentReference);
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isFalse);
        });
      });

      group('Transaction.update()', () {
        test('should update a document', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-update');

          await documentReference.set({'foo': 'bar', 'bar': 1});

          await firestore.runTransaction((Transaction transaction) async {
            DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                await transaction.get(documentReference);
            transaction.update(documentReference, {
              'bar': documentSnapshot.data()!['bar'] + 1,
            });
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isTrue);
          expect(snapshot.data()!['bar'], equals(2));
          expect(snapshot.data()!['foo'], equals('bar'));
        });
      });

      group('Transaction.set()', () {
        test('sets a document', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-set');

          await documentReference.set({'foo': 'bar', 'bar': 1});

          await firestore.runTransaction((Transaction transaction) async {
            DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                await transaction.get(documentReference);
            transaction.set(documentReference, {
              'bar': documentSnapshot.data()!['bar'] + 1,
            });
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isTrue);
          expect(
            snapshot.data(),
            equals(<String, dynamic>{'bar': 2}),
          );
        });

        test('merges a document with set', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-set-merge');

          await documentReference.set({'foo': 'bar', 'bar': 1});

          await firestore.runTransaction((Transaction transaction) async {
            DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                await transaction.get(documentReference);
            transaction.set(
              documentReference,
              {'bar': documentSnapshot.data()!['bar'] + 1},
              SetOptions(merge: true),
            );
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isTrue);
          expect(snapshot.data()!['bar'], equals(2));
          expect(snapshot.data()!['foo'], equals('bar'));
        });

        test('merges fields a document with set', () async {
          DocumentReference<Map<String, dynamic>> documentReference =
              await initializeTest('transaction-set-merge-fields');

          await documentReference.set({'foo': 'bar', 'bar': 1, 'baz': 1});

          await firestore.runTransaction((Transaction transaction) async {
            DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
                await transaction.get(documentReference);
            transaction.set(
              documentReference,
              {
                'bar': documentSnapshot.data()!['bar'] + 1,
                'baz': 'ben',
              },
              SetOptions(mergeFields: ['bar']),
            );
          });

          DocumentSnapshot<Map<String, dynamic>> snapshot =
              await documentReference.get();
          expect(snapshot.exists, isTrue);
          expect(
            snapshot.data(),
            equals(<String, dynamic>{'foo': 'bar', 'bar': 2, 'baz': 1}),
          );
        });
      });

      test('runs all commands in a single transaction', () async {
        DocumentReference<Map<String, dynamic>> documentReference =
            await initializeTest('transaction-all');

        DocumentReference<Map<String, dynamic>> documentReference2 =
            firestore.doc('flutter-tests/delete');

        await documentReference2.set({'foo': 'bar'});
        await documentReference.set({'foo': 1});

        String result = await firestore
            .runTransaction<String>((Transaction transaction) async {
          DocumentSnapshot<Map<String, dynamic>> documentSnapshot =
              await transaction.get(documentReference);

          transaction.set(documentReference, {
            'foo': documentSnapshot.data()!['foo'] + 1,
          });

          transaction.update(documentReference, {'bar': 'baz'});

          transaction.delete(documentReference2);

          return 'done';
        });

        expect(result, equals('done'));

        DocumentSnapshot<Map<String, dynamic>> snapshot =
            await documentReference.get();
        expect(snapshot.exists, isTrue);
        expect(
          snapshot.data(),
          equals(<String, dynamic>{'foo': 2, 'bar': 'baz'}),
        );

        DocumentSnapshot<Map<String, dynamic>> snapshot2 =
            await documentReference2.get();
        expect(snapshot2.exists, isFalse);
      });

      // TODO(Lyokone): adding auth make some tests fails in macOS
      // test(
      //     'should not fail to complete transaction if user is authenticated',
      //     () async {
      //   DocumentReference<Map<String, dynamic>> doc1 =
      //       await initializeTest('transaction-authentified-1');

      //   try {
      //     await FirebaseAuth.instance.createUserWithEmailAndPassword(
      //       email: 'firestore@mail.com',
      //       password: 'this-is-a-password',
      //     );
      //   } catch (e) {
      //     await FirebaseAuth.instance.signInWithEmailAndPassword(
      //       email: 'firestore@mail.com',
      //       password: 'this-is-a-password',
      //     );
      //   }

      //   await doc1.set({'test': 0});

      //   final value = await firestore.runTransaction(
      //     (Transaction transaction) async {
      //       final value = await transaction.get(doc1);
      //       final newValue = value['test'] + 1;
      //       transaction.set(doc1, {
      //         'test': newValue,
      //       });

      //       return newValue;
      //     },
      //     maxAttempts: 1,
      //   );

      //   expect(value, equals(1));

      //   await FirebaseAuth.instance.signOut();
      // });
    },
    skip: kIsWeb,
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\vector_value_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runVectorValueTests() {
  group('$VectorValue', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<DocumentReference<Map<String, dynamic>>> initializeTest(
      String path,
    ) async {
      String prefixedPath = 'flutter-tests/$path';
      await firestore.doc(prefixedPath).delete();
      return firestore.doc(prefixedPath);
    }

    test('sets a $VectorValue & returns one', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value');

      await doc.set({
        'foo': const VectorValue([10.0, -10.0]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([10.0, -10.0]));
    });

    test('updates a $VectorValue & returns', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-update');

      await doc.set({
        'foo': const VectorValue([10.0, -10.0]),
      });

      await doc.update({
        'foo': const VectorValue([-10.0, 10.0]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([-10.0, 10.0]));
    });

    test('handles empty vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-empty');

      try {
        await doc.set({
          'foo': const VectorValue([]),
        });
        fail('Should have thrown an exception');
      } catch (e) {
        expect(e, isA<FirebaseException>());
        expect(
          (e as FirebaseException).code.contains('invalid-argument'),
          isTrue,
        );
      }
    });

    test('handles single dimension vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-single');

      await doc.set({
        'foo': const VectorValue([42.0]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([42.0]));
    });

    test('handles maximum dimensions vector', () async {
      List<double> maxDimensions = List.filled(2048, 1);
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-max-dimensions');

      await doc.set({
        'foo': VectorValue(maxDimensions),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals(maxDimensions));
    });

    test('handles maximum dimensions + 1 vector', () async {
      List<double> maxPlusOneDimensions = List.filled(2049, 1);
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-max-plus-one');

      try {
        await doc.set({
          'foo': VectorValue(maxPlusOneDimensions),
        });

        fail('Should have thrown an exception');
      } catch (e) {
        expect(e, isA<FirebaseException>());
        expect(
          (e as FirebaseException).code.contains('invalid-argument'),
          isTrue,
        );
      }
    });

    test('handles very large values in vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-large-values');

      await doc.set({
        'foo': const VectorValue([1e10, -1e10]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([1e10, -1e10]));
    });

    test('handles floats in vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-floats');

      await doc.set({
        'foo': const VectorValue([3.14, 2.718]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([3.14, 2.718]));
    });

    test('handles negative values in vector', () async {
      DocumentReference<Map<String, dynamic>> doc =
          await initializeTest('vector-value-negative');

      await doc.set({
        'foo': const VectorValue([-42.0, -100.0]),
      });

      DocumentSnapshot<Map<String, dynamic>> snapshot = await doc.get();

      VectorValue vectorValue = snapshot.data()!['foo'];
      expect(vectorValue, isA<VectorValue>());
      expect(vectorValue.toArray(), equals([-42.0, -100.0]));
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\web_snapshot_listeners.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';

// Run only on web for demonstrating snapshot listener clean up in debug mode does not clean up the listeners incorrectly.
// See: https://github.com/firebase/flutterfire/issues/13019
void runWebSnapshotListenersTests() {
  group('Web snapshot listeners', () {
    late FirebaseFirestore firestore;
    late CollectionReference<Map<String, dynamic>> collection;
    late DocumentReference<Map<String, dynamic>> document;
    late DocumentReference<Map<String, dynamic>> document2;
    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
      collection = firestore
          .collection('flutter-tests/web-snapshot-listeners/query-tests');
      document = collection.doc('doc1');
      document2 = collection.doc('doc1');

      await Future.wait([
        document.set({'foo': 1}),
        collection.add({'foo': 2}),
        collection.add({'foo': 3}),
      ]);
    });

    test(
      'document snapshot listeners in debug',
      () async {
        Completer<bool> completer = Completer<bool>();
        Completer<bool> completer2 = Completer<bool>();
        Completer<bool> completer3 = Completer<bool>();
        document.snapshots().listen((snapshot) {
          if (completer.isCompleted) {
            return;
          }
          completer.complete(true);
        });

        document.snapshots().listen((snapshot) {
          if (completer2.isCompleted) {
            return;
          }
          completer2.complete(true);
        });

        document.snapshots().listen((snapshot) {
          if (completer3.isCompleted) {
            return;
          }
          completer3.complete(true);
        });

        final one = await completer.future;
        final two = await completer2.future;
        final three = await completer3.future;

        expect(one, true);
        expect(two, true);
        expect(three, true);
      },
      skip: !kIsWeb,
    );

    test(
      'document snapshot listeners with different doc refs in debug',
      () async {
        Completer<bool> completer = Completer<bool>();
        Completer<bool> completer2 = Completer<bool>();
        Completer<bool> completer3 = Completer<bool>();
        Completer<bool> completer4 = Completer<bool>();
        document.snapshots().listen((snapshot) {
          if (completer.isCompleted) {
            return;
          }
          completer.complete(true);
        });

        document.snapshots().listen((snapshot) {
          if (completer2.isCompleted) {
            return;
          }
          completer2.complete(true);
        });

        document2.snapshots().listen((snapshot) {
          if (completer3.isCompleted) {
            return;
          }
          completer3.complete(true);
        });

        document2.snapshots().listen((snapshot) {
          if (completer4.isCompleted) {
            return;
          }
          completer4.complete(true);
        });

        final one = await completer.future;
        final two = await completer2.future;
        final three = await completer3.future;
        final four = await completer4.future;

        expect(one, true);
        expect(two, true);
        expect(three, true);
        expect(four, true);
      },
      skip: !kIsWeb,
    );

    test(
      'query snapshot listeners in debug',
      () async {
        Completer<bool> completer = Completer<bool>();
        Completer<bool> completer2 = Completer<bool>();
        Completer<bool> completer3 = Completer<bool>();
        collection.snapshots().listen((snapshot) {
          if (completer.isCompleted) {
            return;
          }
          completer.complete(true);
        });

        collection.snapshots().listen((snapshot) {
          if (completer2.isCompleted) {
            return;
          }
          completer2.complete(true);
        });

        collection.snapshots().listen((snapshot) {
          if (completer3.isCompleted) {
            return;
          }
          completer3.complete(true);
        });
        final one = await completer.future;
        final two = await completer2.future;
        final three = await completer3.future;

        expect(one, true);
        expect(two, true);
        expect(three, true);
      },
      skip: !kIsWeb,
    );

    test(
      'snapshot in sync listeners in debug',
      () async {
        Completer<bool> completer = Completer<bool>();
        Completer<bool> completer2 = Completer<bool>();
        Completer<bool> completer3 = Completer<bool>();
        firestore.snapshotsInSync().listen((snapshot) {
          if (completer.isCompleted) {
            return;
          }
          completer.complete(true);
        });

        firestore.snapshotsInSync().listen((snapshot) {
          if (completer2.isCompleted) {
            return;
          }
          completer2.complete(true);
        });

        firestore.snapshotsInSync().listen((snapshot) {
          if (completer3.isCompleted) {
            return;
          }
          completer3.complete(true);
        });

        final one = await completer.future;
        final two = await completer2.future;
        final three = await completer3.future;

        expect(one, true);
        expect(two, true);
        expect(three, true);
      },
      skip: !kIsWeb,
    );
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\integration_test\write_batch_e2e.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void runWriteBatchTests() {
  group('$WriteBatch', () {
    late FirebaseFirestore firestore;

    setUpAll(() async {
      firestore = FirebaseFirestore.instance;
    });

    Future<CollectionReference<Map<String, dynamic>>> initializeTest(
      String id,
    ) async {
      CollectionReference<Map<String, dynamic>> collection =
          firestore.collection('flutter-tests/$id/query-tests');
      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      await Future.forEach(snapshot.docs, (
        DocumentSnapshot<Map<String, dynamic>> documentSnapshot,
      ) {
        return documentSnapshot.reference.delete();
      });
      return collection;
    }

    test('works with withConverter', () async {
      CollectionReference<Map<String, dynamic>> collection =
          await initializeTest('with-converter-batch');
      WriteBatch batch = firestore.batch();

      DocumentReference<int> doc = collection.doc('doc1').withConverter(
            fromFirestore: (snapshot, options) {
              return snapshot.data()!['value'] as int;
            },
            toFirestore: (value, options) => {'value': value},
          );

      var snapshot = await doc.get();

      expect(snapshot.exists, false);

      batch.set<int>(doc, 42);

      await batch.commit();
      snapshot = await doc.get();

      expect(snapshot.exists, true);
      expect(snapshot.data(), 42);

      batch = firestore.batch();
      batch.update(doc, {'value': 21});

      await batch.commit();
      snapshot = await doc.get();

      expect(snapshot.exists, true);
      expect(snapshot.data(), 21);

      batch = firestore.batch();
      batch.delete(doc);

      await batch.commit();
      snapshot = await doc.get();

      expect(snapshot.exists, false);
    });

    test('performs batch operations', () async {
      CollectionReference<Map<String, dynamic>> collection =
          await initializeTest('write-batch-ops');
      WriteBatch batch = firestore.batch();

      DocumentReference<Map<String, dynamic>> doc1 =
          collection.doc('doc1'); // delete
      DocumentReference<Map<String, dynamic>> doc2 =
          collection.doc('doc2'); // set
      DocumentReference<Map<String, dynamic>> doc3 =
          collection.doc('doc3'); // update
      DocumentReference<Map<String, dynamic>> doc4 =
          collection.doc('doc4'); // update w/ merge
      DocumentReference<Map<String, dynamic>> doc5 =
          collection.doc('doc5'); // update w/ mergeFields

      await Future.wait([
        doc1.set({'foo': 'bar'}),
        doc2.set({'foo': 'bar'}),
        doc3.set({'foo': 'bar', 'bar': 'baz'}),
        doc4.set({'foo': 'bar'}),
        doc5.set({'foo': 'bar', 'bar': 'baz'}),
      ]);

      batch.delete(doc1);
      batch.set(doc2, <String, dynamic>{'bar': 'baz'});
      batch.update(doc3, <String, dynamic>{'bar': 'ben'});
      batch.set(doc4, <String, dynamic>{'bar': 'ben'}, SetOptions(merge: true));

      batch.set(
        doc5,
        <String, dynamic>{'bar': 'ben'},
        SetOptions(mergeFields: ['bar']),
      );

      await batch.commit();

      QuerySnapshot<Map<String, dynamic>> snapshot = await collection.get();

      expect(snapshot.docs.length, equals(4));
      expect(snapshot.docs.where((doc) => doc.id == 'doc1').isEmpty, isTrue);
      expect(
        snapshot.docs.firstWhere((doc) => doc.id == 'doc2').data(),
        equals(<String, dynamic>{'bar': 'baz'}),
      );
      expect(
        snapshot.docs.firstWhere((doc) => doc.id == 'doc3').data(),
        equals(<String, dynamic>{'foo': 'bar', 'bar': 'ben'}),
      );
      expect(
        snapshot.docs.firstWhere((doc) => doc.id == 'doc4').data(),
        equals(<String, dynamic>{'foo': 'bar', 'bar': 'ben'}),
      );

      expect(
        snapshot.docs.firstWhere((doc) => doc.id == 'doc5').data(),
        equals(<String, dynamic>{'foo': 'bar', 'bar': 'ben'}),
      );
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\ios\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json =====
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\ios\Runner\Assets.xcassets\LaunchImage.imageset\Contents.json =====
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\ios\firebase_app_id_file.json =====
{
  "file_generated_by": "FlutterFire CLI",
  "purpose": "FirebaseAppID & ProjectID for this Firebase app in this directory",
  "GOOGLE_APP_ID": "1:406099696497:ios:0670bc5fe8574a9c3574d0",
  "FIREBASE_PROJECT_ID": "flutterfire-e2e-tests",
  "GCM_SENDER_ID": "406099696497"
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\lib\firebase_options.dart =====
// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    return switch (defaultTargetPlatform) {
      TargetPlatform.android => android,
      TargetPlatform.iOS => ios,
      TargetPlatform.macOS => macos,
      TargetPlatform.windows => android,
      TargetPlatform.linux => throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        ),
      _ => throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        )
    };
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:175ea7a64b2faf5e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:0670bc5fe8574a9c3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-l9gojfp6b3h1cgie1se28a9ol9fmsvvk.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:0670bc5fe8574a9c3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-l9gojfp6b3h1cgie1se28a9ol9fmsvvk.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.firestore.example',
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\lib\main.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;

import 'firebase_options.dart';

/// Requires that a Firestore emulator is running locally.
/// See https://firebase.google.com/docs/firestore/quickstart#optional_prototype_and_test_with
bool shouldUseFirestoreEmulator = true;

Future<Uint8List> loadBundleSetup(int number) async {
  // endpoint serves a bundle with 3 documents each containing
  // a 'number' property that increments in value 1-3.
  final url =
      Uri.https('api.rnfirebase.io', '/firestore/e2e-tests/bundle-$number');
  final response = await http.get(url);
  String string = response.body;
  return Uint8List.fromList(string.codeUnits);
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  FirebaseFirestore.instance.settings = const Settings(
    persistenceEnabled: true,
  );
  if (shouldUseFirestoreEmulator) {
    FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);
  }

  runApp(FirestoreExampleApp());
}

/// A reference to the list of movies.
/// We are using `withConverter` to ensure that interactions with the collection
/// are type-safe.
final moviesRef = FirebaseFirestore.instance
    .collection('firestore-example-app')
    .withConverter<Movie>(
      fromFirestore: (snapshots, _) => Movie.fromJson(snapshots.data()!),
      toFirestore: (movie, _) => movie.toJson(),
    );

/// The different ways that we can filter/sort movies.
enum MovieQuery {
  year,
  likesAsc,
  likesDesc,
  rated,
  sciFi,
  fantasy,
}

extension on Query<Movie> {
  /// Create a firebase query from a [MovieQuery]
  Query<Movie> queryBy(MovieQuery query) {
    return switch (query) {
      MovieQuery.fantasy => where('genre', arrayContainsAny: ['fantasy']),
      MovieQuery.sciFi => where('genre', arrayContainsAny: ['sci-fi']),
      MovieQuery.likesAsc ||
      MovieQuery.likesDesc =>
        orderBy('likes', descending: query == MovieQuery.likesDesc),
      MovieQuery.year => orderBy('year', descending: true),
      MovieQuery.rated => orderBy('rated', descending: true)
    };
  }
}

/// The entry point of the application.
///
/// Returns a [MaterialApp].
class FirestoreExampleApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Firestore Example App',
      theme: ThemeData.dark(),
      home: const Scaffold(
        body: Center(child: FilmList()),
      ),
    );
  }
}

/// Holds all example app films
class FilmList extends StatefulWidget {
  const FilmList({Key? key}) : super(key: key);

  @override
  _FilmListState createState() => _FilmListState();
}

class _FilmListState extends State<FilmList> {
  MovieQuery query = MovieQuery.year;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text('Firestore Example: Movies'),

            // This is a example use for 'snapshots in sync'.
            // The view reflects the time of the last Firestore sync; which happens any time a field is updated.
            StreamBuilder(
              stream: FirebaseFirestore.instance.snapshotsInSync(),
              builder: (context, _) {
                return Text(
                  'Latest Snapshot: ${DateTime.now()}',
                  style: Theme.of(context).textTheme.bodySmall,
                );
              },
            ),
          ],
        ),
        actions: <Widget>[
          PopupMenuButton<MovieQuery>(
            onSelected: (value) => setState(() => query = value),
            icon: const Icon(Icons.sort),
            itemBuilder: (BuildContext context) {
              return [
                const PopupMenuItem(
                  value: MovieQuery.year,
                  child: Text('Sort by Year'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.rated,
                  child: Text('Sort by Rated'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.likesAsc,
                  child: Text('Sort by Likes ascending'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.likesDesc,
                  child: Text('Sort by Likes descending'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.fantasy,
                  child: Text('Filter genre fantasy'),
                ),
                const PopupMenuItem(
                  value: MovieQuery.sciFi,
                  child: Text('Filter genre sci-fi'),
                ),
              ];
            },
          ),
          PopupMenuButton<String>(
            onSelected: (value) async {
              switch (value) {
                case 'reset_likes':
                  return _resetLikes();
                case 'aggregate':
                  // Count the number of movies
                  final _count = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .count()
                      .get();

                  print('Count: ${_count.count}');

                  // Average the number of likes
                  final _average = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .aggregate(average('likes'))
                      .get();

                  print('Average: ${_average.getAverage('likes')}');

                  // Sum the number of likes
                  final _sum = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .aggregate(sum('likes'))
                      .get();

                  print('Sum: ${_sum.getSum('likes')}');

                  // In one query
                  final _all = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .aggregate(
                        average('likes'),
                        sum('likes'),
                        count(),
                      )
                      .get();

                  print('Average: ${_all.getAverage('likes')} '
                      'Sum: ${_all.getSum('likes')} '
                      'Count: ${_all.count}');

                  return;
                case 'load_bundle':
                  Uint8List buffer = await loadBundleSetup(2);
                  LoadBundleTask task =
                      FirebaseFirestore.instance.loadBundle(buffer);

                  final list = await task.stream.toList();

                  print(
                    list.map((e) => e.totalDocuments),
                  );
                  print(
                    list.map((e) => e.bytesLoaded),
                  );
                  print(
                    list.map((e) => e.documentsLoaded),
                  );
                  print(
                    list.map((e) => e.totalBytes),
                  );
                  print(
                    list,
                  );

                  LoadBundleTaskSnapshot lastSnapshot = list.removeLast();
                  print(lastSnapshot.taskState);

                  print(
                    list.map((e) => e.taskState),
                  );
                  return;
                case 'vectorValue':
                  const vectorValue = VectorValue([1.0, 2.0, 3.0]);
                  final vectorValueDoc = await FirebaseFirestore.instance
                      .collection('firestore-example-app')
                      .add({'vectorValue': vectorValue});

                  final snapshot = await vectorValueDoc.get();
                  print(snapshot.data());
                  return;
                default:
                  return;
              }
            },
            itemBuilder: (BuildContext context) {
              return [
                const PopupMenuItem(
                  value: 'reset_likes',
                  child: Text('Reset like counts (WriteBatch)'),
                ),
                const PopupMenuItem(
                  value: 'aggregate',
                  child: Text('Get aggregate data'),
                ),
                const PopupMenuItem(
                  value: 'load_bundle',
                  child: Text('Load bundle'),
                ),
                const PopupMenuItem(
                  value: 'vectorValue',
                  child: Text('Test Vector Value'),
                ),
              ];
            },
          ),
        ],
      ),
      body: StreamBuilder<QuerySnapshot<Movie>>(
        stream: moviesRef.queryBy(query).snapshots(),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(
              child: Text(snapshot.error.toString()),
            );
          }

          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          final data = snapshot.requireData;

          return ListView.builder(
            itemCount: data.size,
            itemBuilder: (context, index) {
              return _MovieItem(
                data.docs[index].data(),
                data.docs[index].reference,
              );
            },
          );
        },
      ),
    );
  }

  Future<void> _resetLikes() async {
    final movies = await moviesRef.get(
      const GetOptions(
        serverTimestampBehavior: ServerTimestampBehavior.previous,
      ),
    );

    WriteBatch batch = FirebaseFirestore.instance.batch();

    for (final movie in movies.docs) {
      batch.update(movie.reference, {'likes': 0});
    }
    await batch.commit();
  }
}

/// A single movie row.
class _MovieItem extends StatelessWidget {
  _MovieItem(this.movie, this.reference);

  final Movie movie;
  final DocumentReference<Movie> reference;

  /// Returns the movie poster.
  Widget get poster {
    return SizedBox(
      width: 100,
      child: Image.network(movie.poster),
    );
  }

  /// Returns movie details.
  Widget get details {
    return Padding(
      padding: const EdgeInsets.only(left: 8, right: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          title,
          metadata,
          genres,
          Likes(
            reference: reference,
            currentLikes: movie.likes,
          ),
        ],
      ),
    );
  }

  /// Return the movie title.
  Widget get title {
    return Text(
      '${movie.title} (${movie.year})',
      style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
    );
  }

  /// Returns metadata about the movie.
  Widget get metadata {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(right: 8),
            child: Text('Rated: ${movie.rated}'),
          ),
          Text('Runtime: ${movie.runtime}'),
        ],
      ),
    );
  }

  /// Returns a list of genre movie tags.
  List<Widget> get genreItems {
    return [
      for (final genre in movie.genre)
        Padding(
          padding: const EdgeInsets.only(right: 2),
          child: Chip(
            backgroundColor: Colors.lightBlue,
            label: Text(
              genre,
              style: const TextStyle(color: Colors.white),
            ),
          ),
        ),
    ];
  }

  /// Returns all genres.
  Widget get genres {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Wrap(
        children: genreItems,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4, top: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          poster,
          Flexible(child: details),
        ],
      ),
    );
  }
}

/// Displays and manages the movie 'like' count.
class Likes extends StatefulWidget {
  /// Constructs a new [Likes] instance with a given [DocumentReference] and
  /// current like count.
  Likes({
    Key? key,
    required this.reference,
    required this.currentLikes,
  }) : super(key: key);

  /// The reference relating to the counter.
  final DocumentReference<Movie> reference;

  /// The number of current likes (before manipulation).
  final int currentLikes;

  @override
  _LikesState createState() => _LikesState();
}

class _LikesState extends State<Likes> {
  /// A local cache of the current likes, used to immediately render the updated
  /// likes count after an update, even while the request isn't completed yet.
  late int _likes = widget.currentLikes;

  Future<void> _onLike() async {
    final currentLikes = _likes;

    // Increment the 'like' count straight away to show feedback to the user.
    setState(() {
      _likes = currentLikes + 1;
    });

    try {
      // Update the likes using a transaction.
      // We use a transaction because multiple users could update the likes count
      // simultaneously. As such, our likes count may be different from the likes
      // count on the server.
      int newLikes = await FirebaseFirestore.instance
          .runTransaction<int>((transaction) async {
        DocumentSnapshot<Movie> movie =
            await transaction.get<Movie>(widget.reference);

        if (!movie.exists) {
          throw Exception('Document does not exist!');
        }

        int updatedLikes = movie.data()!.likes + 1;
        transaction.update(widget.reference, {'likes': updatedLikes});
        return updatedLikes;
      });

      // Update with the real count once the transaction has completed.
      setState(() => _likes = newLikes);
    } catch (e, s) {
      print(s);
      print('Failed to update likes for document! $e');

      // If the transaction fails, revert back to the old count
      setState(() => _likes = currentLikes);
    }
  }

  @override
  void didUpdateWidget(Likes oldWidget) {
    super.didUpdateWidget(oldWidget);
    // The likes on the server changed, so we need to update our local cache to
    // keep things in sync. Otherwise if another user updates the likes,
    // we won't see the update.
    if (widget.currentLikes != oldWidget.currentLikes) {
      _likes = widget.currentLikes;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        IconButton(
          iconSize: 20,
          onPressed: _onLike,
          icon: const Icon(Icons.favorite),
        ),
        Text('$_likes likes'),
      ],
    );
  }
}

@immutable
class Movie {
  Movie({
    required this.genre,
    required this.likes,
    required this.poster,
    required this.rated,
    required this.runtime,
    required this.title,
    required this.year,
  });

  Movie.fromJson(Map<String, Object?> json)
      : this(
          genre: (json['genre']! as List).cast<String>(),
          likes: json['likes']! as int,
          poster: json['poster']! as String,
          rated: json['rated']! as String,
          runtime: json['runtime']! as String,
          title: json['title']! as String,
          year: json['year']! as int,
        );

  final String poster;
  final int likes;
  final String title;
  final int year;
  final String runtime;
  final String rated;
  final List<String> genre;

  Map<String, Object?> toJson() {
    return {
      'genre': genre,
      'likes': likes,
      'poster': poster,
      'rated': rated,
      'runtime': runtime,
      'title': title,
      'year': year,
    };
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\macos\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json =====
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\macos\firebase_app_id_file.json =====
{
  "file_generated_by": "FlutterFire CLI",
  "purpose": "FirebaseAppID & ProjectID for this Firebase app in this directory",
  "GOOGLE_APP_ID": "1:406099696497:ios:0670bc5fe8574a9c3574d0",
  "FIREBASE_PROJECT_ID": "flutterfire-e2e-tests",
  "GCM_SENDER_ID": "406099696497"
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\test_driver\integration_test.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\web\manifest.json =====
{
    "name": "Firestore Example",
    "short_name": "Firestore Example",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\analysis_options.yaml =====
# Copyright 2021 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# in the LICENSE file.

include: ../../../../analysis_options.yaml
linter:
  rules:
    avoid_print: false
    depend_on_referenced_packages: false
    library_private_types_in_public_api: false
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\firebase.json =====
{"flutter":{"platforms":{"android":{"default":{"projectId":"flutterfire-e2e-tests","appId":"1:406099696497:android:175ea7a64b2faf5e3574d0","fileOutput":"android/app/google-services.json"}}}}}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\example\pubspec.yaml =====
name: cloud_firestore_example
description: Demonstrates how to use the firestore plugin.

environment:
  sdk: '>=3.2.0 <4.0.0'

dependencies:
  cloud_firestore: ^6.0.3
  firebase_core: ^4.2.0
  flutter:
    sdk: flutter
  http: ^1.0.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\utils\codec_utility.dart =====
// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../../cloud_firestore.dart';

// ignore: do_not_use_environment
const kIsWasm = bool.fromEnvironment('dart.library.js_interop') &&
    // html package is not available in wasm
    // ignore: do_not_use_environment
    !bool.fromEnvironment('dart.library.html');

class _CodecUtility {
  static Map<String, dynamic>? replaceValueWithDelegatesInMap(
    Map<dynamic, dynamic>? data,
  ) {
    if (data == null) {
      return null;
    }
    Map<String, dynamic> output = Map.from(data);
    output.updateAll((_, value) => valueEncode(value));
    return output;
  }

  static Map<FieldPath, dynamic>? replaceValueWithDelegatesInMapFieldPath(
    Map<Object, dynamic>? data,
  ) {
    if (data == null) {
      return null;
    }
    Map<FieldPath, dynamic> output = <FieldPath, dynamic>{};
    data.forEach((key, value) {
      if (key is FieldPath) {
        output[key] = valueEncode(value);
      } else if (key is String) {
        output[FieldPath.fromString(key)] = valueEncode(value);
      } else {
        throw StateError(
          'Invalid key type for map. Expected String or FieldPath, but got $key: ${key.runtimeType}.',
        );
      }
    });
    return output;
  }

  static List<dynamic>? replaceValueWithDelegatesInArray(
    Iterable<dynamic>? data,
  ) {
    if (data == null) {
      return null;
    }
    return List.from(data).map(valueEncode).toList();
  }

  static Map<String, dynamic>? replaceDelegatesWithValueInMap(
    Map<dynamic, dynamic>? data,
    FirebaseFirestore firestore,
  ) {
    if (data == null) {
      return null;
    }
    Map<String, dynamic> output = Map.from(data);
    output.updateAll((_, value) => valueDecode(value, firestore));
    return output;
  }

  static List<dynamic>? replaceDelegatesWithValueInArray(
    List<dynamic>? data,
    FirebaseFirestore firestore,
  ) {
    if (data == null) {
      return null;
    }
    return List.from(data)
        .map((value) => valueDecode(value, firestore))
        .toList();
  }

  static dynamic valueEncode(dynamic value) {
    if (value is DocumentReference) {
      return value._delegate;
    } else if (value is Iterable) {
      return replaceValueWithDelegatesInArray(value);
    } else if (value is Map<dynamic, dynamic>) {
      return replaceValueWithDelegatesInMap(value);
    }
    return value;
  }

  static dynamic valueDecode(dynamic value, FirebaseFirestore firestore) {
    if (value is DocumentReferencePlatform) {
      return _JsonDocumentReference(firestore, value);
    } else if (value is List) {
      return replaceDelegatesWithValueInArray(value, firestore);
    } else if (value is Map<dynamic, dynamic>) {
      return replaceDelegatesWithValueInMap(value, firestore);
    } else if (value is num) {
      return convertNum(value);
    }
    return value;
  }
}

num convertNum(num input) {
  // This workaround is only needed for WASM
  if (!kIsWasm) {
    return input;
  }
  // Can fail for NaN, Infinity, etc.
  try {
    if (input is int) {
      return input; // It's already an int
    } else if (input is double) {
      if (input == input.toInt()) {
        return input.toInt(); // Convert to int if no fractional part
      }
    }

    return input; // Return as double if fractional part exists
  } catch (_) {
    return input;
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\aggregate_query.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// [AggregateQuery] represents the data at a particular location for retrieving metadata
/// without retrieving the actual documents.
class AggregateQuery {
  AggregateQuery._(this._delegate, this.query) {
    AggregateQueryPlatform.verify(_delegate);
  }

  /// [Query] represents the query over the data at a particular location used by the [AggregateQuery] to
  /// retrieve the metadata.
  final Query query;

  final AggregateQueryPlatform _delegate;

  /// Returns an [AggregateQuerySnapshot] with the count of the documents that match the query.
  Future<AggregateQuerySnapshot> get({
    AggregateSource source = AggregateSource.server,
  }) async {
    return AggregateQuerySnapshot._(await _delegate.get(source: source), query);
  }

  /// Represents an [AggregateQuery] over the data at a particular location for retrieving metadata
  /// without retrieving the actual documents.
  AggregateQuery count() {
    return AggregateQuery._(_delegate.count(), query);
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\aggregate_query_snapshot.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// [AggregateQuerySnapshot] represents a response to an [AggregateQuery] request.
class AggregateQuerySnapshot {
  AggregateQuerySnapshot._(this._delegate, this.query) {
    AggregateQuerySnapshotPlatform.verifyExtends(_delegate);
  }
  final AggregateQuerySnapshotPlatform _delegate;

  /// [Query] represents the query over the data at a particular location used by the [AggregateQuery] to
  /// retrieve the metadata.
  final Query query;

  /// Returns the count of the documents that match the query.
  int? get count => _delegate.count;

  /// Returns the sum of the values of the documents that match the query.
  double? getSum(String field) => _delegate.getSum(field);

  /// Returns the average of the values of the documents that match the query.
  double? getAverage(String field) => _delegate.getAverage(field);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\collection_reference.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

@immutable
// `extends Object?` so that type inference defaults to `Object?` instead of `dynamic`
abstract class CollectionReference<T extends Object?> implements Query<T> {
  /// Returns the ID of the referenced collection.
  String get id;

  /// Returns the parent [DocumentReference] of this collection or `null`.
  ///
  /// If this collection is a root collection, `null` is returned.
  // This always returns a DocumentReference even when using withConverter
  // because we do not know what is the correct type for the parent doc. @override
  DocumentReference<Map<String, dynamic>>? get parent;

  /// A string containing the slash-separated path to this  CollectionReference
  /// (relative to the root of the database).
  String get path;

  /// Returns a `DocumentReference` with an auto-generated ID, after
  /// populating it with provided [data].
  ///
  /// The unique key generated is prefixed with a client-generated timestamp
  /// so that the resulting list will be chronologically-sorted.
  Future<DocumentReference<T>> add(T data);

  /// {@template cloud_firestore.collection_reference.doc}
  /// Returns a `DocumentReference` with the provided path.
  ///
  /// If no [path] is provided, an auto-generated ID is used.
  ///
  /// The unique key generated is prefixed with a client-generated timestamp
  /// so that the resulting list will be chronologically-sorted.
  /// {@endtemplate}
  DocumentReference<T> doc([String? path]);

  /// Transforms a [CollectionReference] to manipulate a custom object instead
  /// of a `Map<String, dynamic>`.
  ///
  /// This makes both read and write operations type-safe.
  ///
  /// ```dart
  /// final modelsRef = FirebaseFirestore
  ///     .instance
  ///     .collection('models')
  ///     .withConverter<Model>(
  ///       fromFirestore: (snapshot, _) => Model.fromJson(snapshot.data()!),
  ///       toFirestore: (model, _) => model.toJson(),
  ///     );
  ///
  /// Future<void> main() async {
  ///   // Writes now take a Model as parameter instead of a Map
  ///   await modelsRef.add(Model());
  ///
  ///   // Reads now return a Model instead of a Map
  ///   final Model model = await modelsRef.doc('123').get().then((s) => s.data());
  /// }
  /// ```
  // `extends Object?` so that type inference defaults to `Object?` instead of `dynamic`
  @override
  CollectionReference<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  });
}

/// A [CollectionReference] object can be used for adding documents, getting
/// [DocumentReference]s, and querying for documents (using the methods
/// inherited from [Query]).
@immutable
class _JsonCollectionReference extends _JsonQuery
    implements CollectionReference<Map<String, dynamic>> {
  _JsonCollectionReference(
    FirebaseFirestore firestore,
    CollectionReferencePlatform _delegate,
  ) : super(firestore, _delegate);

  @override
  CollectionReferencePlatform get _delegate =>
      super._delegate as CollectionReferencePlatform;

  @override
  String get id => _delegate.id;

  @override
  DocumentReference<Map<String, dynamic>>? get parent {
    DocumentReferencePlatform? _documentReferencePlatform = _delegate.parent;

    // Only subcollections have a parent
    if (_documentReferencePlatform == null) {
      return null;
    }

    return _JsonDocumentReference(firestore, _documentReferencePlatform);
  }

  @override
  String get path => _delegate.path;

  @override
  Future<DocumentReference<Map<String, dynamic>>> add(
    Map<String, dynamic> data,
  ) async {
    final newDocument = doc();
    await newDocument.set(data);
    return newDocument;
  }

  @override
  DocumentReference<Map<String, dynamic>> doc([String? path]) {
    if (path != null) {
      if (path.isEmpty) {
        throw ArgumentError('A document path must be a non-empty string');
      } else if (path.contains('//')) {
        throw ArgumentError('A document path must not contain "//"');
      } else if (path == '/') {
        throw ArgumentError('A document path must point to a valid document');
      }
    }

    return _JsonDocumentReference(firestore, _delegate.doc(path));
  }

  @override
  CollectionReference<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterCollectionReference(
      this,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) =>
      other is _JsonCollectionReference &&
      other.runtimeType == runtimeType &&
      other.firestore == firestore &&
      other.path == path;

  @override
  int get hashCode => Object.hash(firestore, path);

  @override
  String toString() => 'CollectionReference<Map<String, dynamic>>($path)';
}

/// A [CollectionReference] object can be used for adding documents, getting
/// [DocumentReference]s, and querying for documents (using the methods
/// inherited from [Query]).
@immutable
class _WithConverterCollectionReference<T extends Object?>
    extends _WithConverterQuery<T> implements CollectionReference<T> {
  _WithConverterCollectionReference(
    CollectionReference<Map<String, dynamic>> collectionReference,
    FromFirestore<T> fromFirestore,
    ToFirestore<T> toFirestore,
  ) : super(collectionReference, fromFirestore, toFirestore);

  CollectionReference<Map<String, dynamic>>
      get _originalCollectionReferenceQuery {
    return super._originalQuery as CollectionReference<Map<String, dynamic>>;
  }

  @override
  String get id => _originalCollectionReferenceQuery.id;

  @override
  DocumentReference<Map<String, dynamic>>? get parent {
    return _originalCollectionReferenceQuery.parent;
  }

  @override
  String get path => _originalCollectionReferenceQuery.path;

  @override
  Future<DocumentReference<T>> add(T data) async {
    final snapshot = await _originalCollectionReferenceQuery.add(
      _toFirestore(data, null),
    );

    return _WithConverterDocumentReference<T>(
      snapshot,
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  DocumentReference<T> doc([String? path]) {
    return _WithConverterDocumentReference<T>(
      _originalCollectionReferenceQuery.doc(path),
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  CollectionReference<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterCollectionReference(
      _originalCollectionReferenceQuery,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) =>
      other is _WithConverterCollectionReference<T> &&
      other.runtimeType == runtimeType &&
      other._originalCollectionReferenceQuery ==
          _originalCollectionReferenceQuery &&
      other._fromFirestore == _fromFirestore &&
      other._toFirestore == _toFirestore;

  @override
  int get hashCode => Object.hash(
        runtimeType,
        _originalCollectionReferenceQuery,
        _fromFirestore,
        _toFirestore,
      );

  @override
  String toString() => 'CollectionReference<$T>($path)';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\document_change.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [DocumentChange] represents a change to the documents matching a query.
///
/// It contains the document affected and the type of change that occurred
/// (added, modified, or removed).
abstract class DocumentChange<T extends Object?> {
  /// The type of change that occurred (added, modified, or removed).
  DocumentChangeType get type;

  /// The index of the changed document in the result set immediately prior to
  /// this [DocumentChange] (i.e. supposing that all prior [DocumentChange] objects
  /// have been applied).
  ///
  /// -1 is returned for [DocumentChangeType.added] events.
  int get oldIndex;

  /// The index of the changed document in the result set immediately after this
  /// [DocumentChange] (i.e. supposing that all prior [DocumentChange] objects
  /// and the current [DocumentChange] object have been applied).
  ///
  /// -1 is returned for [DocumentChangeType.removed] events.
  int get newIndex;

  /// Returns the [DocumentSnapshot] for this instance.
  DocumentSnapshot<T> get doc;
}

class _JsonDocumentChange implements DocumentChange<Map<String, dynamic>> {
  _JsonDocumentChange(this._firestore, this._delegate) {
    DocumentChangePlatform.verify(_delegate);
  }

  final DocumentChangePlatform _delegate;
  final FirebaseFirestore _firestore;

  @override
  DocumentChangeType get type => _delegate.type;

  @override
  int get oldIndex => _delegate.oldIndex;

  @override
  int get newIndex => _delegate.newIndex;

  @override
  DocumentSnapshot<Map<String, dynamic>> get doc {
    return _JsonDocumentSnapshot(_firestore, _delegate.document);
  }
}

class _WithConverterDocumentChange<T extends Object?>
    implements DocumentChange<T> {
  _WithConverterDocumentChange(
    this._originalDocumentChange,
    this._fromFirestore,
    this._toFirestore,
  );

  final DocumentChange<Map<String, dynamic>> _originalDocumentChange;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  DocumentChangeType get type => _originalDocumentChange.type;

  @override
  int get oldIndex => _originalDocumentChange.oldIndex;

  @override
  int get newIndex => _originalDocumentChange.newIndex;

  @override
  DocumentSnapshot<T> get doc {
    return _WithConverterDocumentSnapshot<T>(
      _originalDocumentChange.doc,
      _fromFirestore,
      _toFirestore,
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\document_reference.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [DocumentReference] refers to a document location in a [FirebaseFirestore] database
/// and can be used to write, read, or listen to the location.
///
/// The document at the referenced location may or may not exist.
/// A [DocumentReference] can also be used to create a [CollectionReference]
/// to a subcollection.
@sealed
@immutable
abstract class DocumentReference<T extends Object?> {
  DocumentReferencePlatform get _delegate;

  /// The Firestore instance associated with this document reference.
  FirebaseFirestore get firestore;

  /// This document's given ID within the collection.
  String get id;

  /// The parent [CollectionReference] of this document.
  CollectionReference<T> get parent;

  /// A string representing the path of the referenced document (relative to the
  /// root of the database).
  String get path;

  /// Gets a [CollectionReference] instance that refers to the collection at the
  /// specified path, relative from this [DocumentReference].
  CollectionReference<Map<String, dynamic>> collection(String collectionPath);

  /// Deletes the current document from the collection.
  Future<void> delete();

  /// Updates data on the document. Data will be merged with any existing
  /// document data.
  ///
  /// Objects key can be a String or a FieldPath.
  ///
  /// If no document exists yet, the update will fail.
  Future<void> update(Map<Object, Object?> data);

  /// Reads the document referenced by this [DocumentReference].
  ///
  /// By providing [options], this method can be configured to fetch results only
  /// from the server, only from the local cache or attempt to fetch results
  /// from the server and fall back to the cache (which is the default).
  Future<DocumentSnapshot<T>> get([GetOptions? options]);

  /// Notifies of document updates at this location.
  ///
  /// An initial event is immediately sent, and further events will be
  /// sent whenever the document is modified.
  Stream<DocumentSnapshot<T>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  });

  /// Sets data on the document, overwriting any existing data. If the document
  /// does not yet exist, it will be created.
  ///
  /// If [SetOptions] are provided, the data can be merged into an existing
  /// document instead of overwriting.
  Future<void> set(T data, [SetOptions? options]);

  /// Transforms a [DocumentReference] to manipulate a custom object instead
  /// of a `Map<String, dynamic>`.
  ///
  /// This makes both read and write operations type-safe.
  ///
  /// ```dart
  /// final modelRef = FirebaseFirestore
  ///     .instance
  ///     .collection('models')
  ///     .doc('123')
  ///     .withConverter<Model>(
  ///       fromFirestore: (snapshot, _) => Model.fromJson(snapshot.data()!),
  ///       toFirestore: (model, _) => model.toJson(),
  ///     );
  ///
  /// Future<void> main() async {
  ///   // Writes now take a Model as parameter instead of a Map
  ///   await modelRef.set(Model());
  ///
  ///   // Reads now return a Model instead of a Map
  ///   final Model model = await modelRef.get().then((s) => s.data());
  /// }
  /// ```
  DocumentReference<R> withConverter<R>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  });
}

@immutable
class _JsonDocumentReference
    implements DocumentReference<Map<String, dynamic>> {
  _JsonDocumentReference(this.firestore, this._delegate) {
    DocumentReferencePlatform.verify(_delegate);
  }

  @override
  final DocumentReferencePlatform _delegate;

  @override
  final FirebaseFirestore firestore;

  @override
  String get id => _delegate.id;

  @override
  CollectionReference<Map<String, dynamic>> get parent =>
      _JsonCollectionReference(firestore, _delegate.parent);

  @override
  String get path => _delegate.path;

  @override
  CollectionReference<Map<String, dynamic>> collection(String collectionPath) {
    if (collectionPath.isEmpty) {
      throw ArgumentError('A collectionPath must be a non-empty string.');
    } else if (collectionPath.contains('//')) {
      throw ArgumentError('A collection path must not contain "//".');
    } else if (!isValidCollectionPath(collectionPath)) {
      throw ArgumentError(
        'A collection path must point to a valid collection.',
      );
    }

    return _JsonCollectionReference(
      firestore,
      _delegate.collection(collectionPath),
    );
  }

  @override
  Future<void> delete() => _delegate.delete();

  @override
  Future<DocumentSnapshot<Map<String, dynamic>>> get([
    GetOptions? options,
  ]) async {
    return _JsonDocumentSnapshot(
      firestore,
      await _delegate.get(
        options ?? const GetOptions(),
      ),
    );
  }

  @override
  Stream<DocumentSnapshot<Map<String, dynamic>>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  }) {
    if (source == ListenSource.cache &&
        defaultTargetPlatform == TargetPlatform.windows) {
      throw UnimplementedError(
        'Listening from cache is not supported on Windows',
      );
    }

    return _delegate
        .snapshots(
          includeMetadataChanges: includeMetadataChanges,
          listenSource: source,
        )
        .map(
          (delegateSnapshot) =>
              _JsonDocumentSnapshot(firestore, delegateSnapshot),
        );
  }

  @override
  Future<void> set(Map<String, dynamic> data, [SetOptions? options]) {
    return _delegate.set(
      _CodecUtility.replaceValueWithDelegatesInMap(data)!,
      options,
    );
  }

  @override
  Future<void> update(Map<Object, Object?> data) {
    return _delegate
        .update(_CodecUtility.replaceValueWithDelegatesInMapFieldPath(data)!);
  }

  @override
  DocumentReference<T> withConverter<T>({
    required FromFirestore<T> fromFirestore,
    required ToFirestore<T> toFirestore,
  }) {
    return _WithConverterDocumentReference(this, fromFirestore, toFirestore);
  }

  @override
  bool operator ==(Object other) =>
      other is DocumentReference &&
      other.firestore == firestore &&
      other.path == path;

  @override
  int get hashCode => Object.hash(firestore, path);

  @override
  String toString() => 'DocumentReference<Map<String, dynamic>>($path)';
}

/// A [DocumentReference] refers to a document location in a [FirebaseFirestore] database
/// and can be used to write, read, or listen to the location.
///
/// The document at the referenced location may or may not exist.
/// A [DocumentReference] can also be used to create a [CollectionReference]
/// to a subcollection.
@immutable
class _WithConverterDocumentReference<T extends Object?>
    implements DocumentReference<T> {
  _WithConverterDocumentReference(
    this._originalDocumentReference,
    this._fromFirestore,
    this._toFirestore,
  );

  final DocumentReference<Map<String, dynamic>> _originalDocumentReference;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  CollectionReference<Map<String, dynamic>> collection(String collectionPath) {
    return _originalDocumentReference.collection(collectionPath);
  }

  @override
  Future<void> delete() {
    return _originalDocumentReference.delete();
  }

  @override
  Future<_WithConverterDocumentSnapshot<T>> get([GetOptions? options]) {
    return _originalDocumentReference.get(options).then((snapshot) {
      return _WithConverterDocumentSnapshot<T>(
        snapshot,
        _fromFirestore,
        _toFirestore,
      );
    });
  }

  @override
  DocumentReferencePlatform get _delegate =>
      _originalDocumentReference._delegate;

  @override
  FirebaseFirestore get firestore => _originalDocumentReference.firestore;

  @override
  String get id => _originalDocumentReference.id;

  @override
  CollectionReference<T> get parent {
    return _WithConverterCollectionReference<T>(
      _originalDocumentReference.parent,
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  String get path => _originalDocumentReference.path;

  @override
  Future<void> set(T data, [SetOptions? options]) {
    return _originalDocumentReference.set(
      _toFirestore(data, options),
      options,
    );
  }

  @override
  Stream<_WithConverterDocumentSnapshot<T>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  }) {
    return _originalDocumentReference
        .snapshots(
      includeMetadataChanges: includeMetadataChanges,
      source: source,
    )
        .map((snapshot) {
      return _WithConverterDocumentSnapshot<T>(
        snapshot,
        _fromFirestore,
        _toFirestore,
      );
    });
  }

  @override
  Future<void> update(Map<Object, Object?> data) {
    return _originalDocumentReference.update(data);
  }

  @override
  DocumentReference<R> withConverter<R>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterDocumentReference(
      _originalDocumentReference,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) =>
      other is _WithConverterDocumentReference<T> &&
      other.runtimeType == runtimeType &&
      other._originalDocumentReference == _originalDocumentReference &&
      other._fromFirestore == _fromFirestore &&
      other._toFirestore == _toFirestore;

  @override
  int get hashCode => Object.hash(
        runtimeType,
        _originalDocumentReference,
        _fromFirestore,
        _toFirestore,
      );

  @override
  String toString() => 'DocumentReference<$T>($path)';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\document_snapshot.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

typedef FromFirestore<T> = T Function(
  DocumentSnapshot<Map<String, dynamic>> snapshot,
  SnapshotOptions? options,
);
typedef ToFirestore<T> = Map<String, Object?> Function(
  T value,
  SetOptions? options,
);

/// Options that configure how data is retrieved from a DocumentSnapshot
/// (e.g. the desired behavior for server timestamps that have not yet been set to their final value).
///
/// Currently unsupported by FlutterFire, but exposed to avoid breaking changes
/// in the future once this class is supported.
@sealed
class SnapshotOptions {}

/// A [DocumentSnapshot] contains data read from a document in your [FirebaseFirestore]
/// database.
///
/// The data can be extracted with the data property or by using subscript
/// syntax to access a specific field.
@sealed
abstract class DocumentSnapshot<T extends Object?> {
  /// This document's given ID for this snapshot.
  String get id;

  /// Returns the reference of this snapshot.
  DocumentReference<T> get reference;

  /// Metadata about this document concerning its source and if it has local
  /// modifications.
  SnapshotMetadata get metadata;

  /// Returns `true` if the document exists.
  bool get exists;

  /// Contains all the data of this document snapshot.
  T? data();

  /// {@template firestore.documentsnapshot.get}
  /// Gets a nested field by [String] or [FieldPath] from this [DocumentSnapshot].
  ///
  /// Data can be accessed by providing a dot-notated path or [FieldPath]
  /// which recursively finds the specified data. If no data could be found
  /// at the specified path, a [StateError] will be thrown.
  /// {@endtemplate}
  dynamic get(Object field);

  /// {@macro firestore.documentsnapshot.get}
  dynamic operator [](Object field);
}

class _JsonDocumentSnapshot implements DocumentSnapshot<Map<String, dynamic>> {
  _JsonDocumentSnapshot(this._firestore, this._delegate) {
    DocumentSnapshotPlatform.verify(_delegate);
  }

  final FirebaseFirestore _firestore;
  final DocumentSnapshotPlatform _delegate;

  @override
  String get id => _delegate.id;

  @override
  late final DocumentReference<Map<String, dynamic>> reference =
      _firestore.doc(_delegate.reference.path);

  @override
  late final SnapshotMetadata metadata = SnapshotMetadata._(_delegate.metadata);

  @override
  bool get exists => _delegate.exists;

  @override
  Map<String, dynamic>? data() {
    // TODO(rrousselGit): can we cache the result, to avoid deserializing it on every read?
    return _CodecUtility.replaceDelegatesWithValueInMap(
      _delegate.data(),
      _firestore,
    );
  }

  @override
  dynamic get(Object field) {
    return _CodecUtility.valueDecode(_delegate.get(field), _firestore);
  }

  @override
  dynamic operator [](Object field) => get(field);
}

/// A [DocumentSnapshot] contains data read from a document in your [FirebaseFirestore]
/// database.
///
/// The data can be extracted with the data property or by using subscript
/// syntax to access a specific field.
class _WithConverterDocumentSnapshot<T> implements DocumentSnapshot<T> {
  _WithConverterDocumentSnapshot(
    this._originalDocumentSnapshot,
    this._fromFirestore,
    this._toFirestore,
  );

  final DocumentSnapshot<Map<String, dynamic>> _originalDocumentSnapshot;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  T? data() {
    if (!_originalDocumentSnapshot.exists) return null;

    return _fromFirestore(_originalDocumentSnapshot, null);
  }

  @override
  bool get exists => _originalDocumentSnapshot.exists;

  @override
  String get id => _originalDocumentSnapshot.id;

  @override
  SnapshotMetadata get metadata => _originalDocumentSnapshot.metadata;

  @override
  DocumentReference<T> get reference => _WithConverterDocumentReference<T>(
        _originalDocumentSnapshot.reference,
        _fromFirestore,
        _toFirestore,
      );

  @override
  dynamic get(Object field) => _originalDocumentSnapshot.get(field);

  @override
  dynamic operator [](Object field) => _originalDocumentSnapshot[field];
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\field_value.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// Sentinel values that can be used when writing document fields with set() or
/// update().
///
/// This class serves as a static factory for [FieldValuePlatform] instances, but also
/// as a facade for the [FieldValue] type, so plugin users don't need to worry about
/// the actual internal implementation of their [FieldValue]s after they're created.
@immutable
// ignore: must_be_immutable
class FieldValue extends FieldValuePlatform {
  static final FieldValueFactoryPlatform _factory =
      FieldValueFactoryPlatform.instance;

  FieldValue._(this._delegate) : super(_delegate);

  /// Returns a [FieldValue] that tells the server to union the given elements
  /// with any array value that already exists on the server.
  ///
  /// Each specified element that doesn't already exist in the array will be
  /// added to the end. If the field being modified is not already an array it
  /// will be overwritten with an array containing exactly the specified
  /// elements.
  static FieldValue arrayUnion(List<dynamic> elements) =>
      FieldValue._(_factory.arrayUnion(_CodecUtility.valueEncode(elements)));

  /// Returns a [FieldValue] that tells the server to remove the given
  /// elements from any array value that already exists on the server.
  ///
  /// All instances of each element specified will be removed from the array.
  /// If the field being modified is not already an array it will be overwritten
  /// with an empty array.
  static FieldValue arrayRemove(List<dynamic> elements) =>
      FieldValue._(_factory.arrayRemove(_CodecUtility.valueEncode(elements)));

  /// Returns a sentinel for use with update() to mark a field for deletion.
  static FieldValue delete() => FieldValue._(_factory.delete());

  /// Returns a sentinel for use with set() or update() to include a
  /// server-generated timestamp in the written data.
  static FieldValue serverTimestamp() =>
      FieldValue._(_factory.serverTimestamp());

  /// Returns a special value for use with set() or update() that tells the
  /// server to increment the fieldâ€™s current value by the given value.
  static FieldValue increment(num value) =>
      FieldValue._(_factory.increment(value));

  dynamic _delegate;

  @override
  String toString() => '$FieldValue($_delegate)';

  @override
  bool operator ==(Object other) {
    return other is FieldValue && other._delegate == _delegate;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => _delegate.hashCode;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\filters.dart =====
// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

class _FilterObject {
  Map<String, Object?> build() {
    throw UnimplementedError();
  }
}

class _FilterQuery extends _FilterObject {
  _FilterQuery(this._field, this._operator, this._value)
      : assert(_field is FieldPathType || _field is FieldPath);

  final Object _field;
  final String _operator;
  final Object? _value;

  @override
  Map<String, Object?> build() {
    return <String, Object?>{
      'fieldPath': _field,
      'op': _operator,
      'value': _value,
    };
  }
}

class _FilterOperator extends _FilterObject {
  _FilterOperator(this._operator, this._queries);

  final String _operator;
  final List<_FilterObject> _queries;

  @override
  Map<String, Object> build() {
    return <String, Object>{
      'op': _operator,
      'queries': _queries.map((e) => e.build()).toList(),
    };
  }
}

/// A [Filter] represents a restriction on one or more field values and can be used to refine
/// the results of a [Query].
class Filter extends FilterPlatformInterface {
  late final _FilterQuery? _filterQuery;
  late final _FilterOperator? _filterOperator;

  Filter._(this._filterQuery, this._filterOperator)
      : assert(
          (_filterQuery != null && _filterOperator == null) ||
              (_filterQuery == null && _filterOperator != null),
          'Exactly one operator must be specified',
        );

  /// A [Filter] represents a restriction on one or more field values and can be used to refine
  /// the results of a [Query].
  ///
  /// Only one operator can be specified at a time.
  Filter(
    /// The field or [FieldPath] to filter on.
    Object field, {
    /// Creates a new filter for checking that the given field is equal to the given value.
    Object? isEqualTo,

    /// Creates a new filter for checking that the given field is not equal to the given value.
    Object? isNotEqualTo,

    /// Creates a new filter for checking that the given field is less than the given value.
    Object? isLessThan,

    /// Creates a new filter for checking that the given field is less than or equal to the given value.
    Object? isLessThanOrEqualTo,

    /// Creates a new filter for checking that the given field is greater than the given value.
    Object? isGreaterThan,

    /// Creates a new filter for checking that the given field is greater than or equal to the given value.
    Object? isGreaterThanOrEqualTo,

    /// Creates a new filter for checking that the given array field contains the given value.
    Object? arrayContains,

    /// Creates a new filter for checking that the given array field contains any of the given values.
    Iterable<Object?>? arrayContainsAny,

    /// Creates a new filter for checking that the given field equals any of the given values.
    Iterable<Object?>? whereIn,

    /// Creates a new filter for checking that the given field does not equal any of the given values.
    Iterable<Object?>? whereNotIn,

    /// Creates a new filter for checking that the given field is null.
    bool? isNull,
  })  : assert(
          () {
            final operators = [
              isEqualTo,
              isNotEqualTo,
              isLessThan,
              isLessThanOrEqualTo,
              isGreaterThan,
              isGreaterThanOrEqualTo,
              arrayContains,
              arrayContainsAny,
              whereIn,
              whereNotIn,
              isNull,
            ];
            final operatorsUsed = operators.where((e) => e != null).length;
            return operatorsUsed == 1;
          }(),
          'Exactly one operator must be specified',
        ),
        assert(
          field is String || field is FieldPath || field is FieldPathType,
        ) {
    final _field = (field is String ? FieldPath.fromString(field) : field);

    _filterQuery = _FilterQuery(
      _field,
      _getOperator(
        isEqualTo,
        isNotEqualTo,
        isLessThan,
        isLessThanOrEqualTo,
        isGreaterThan,
        isGreaterThanOrEqualTo,
        arrayContains,
        arrayContainsAny,
        whereIn,
        whereNotIn,
        isNull,
      ),
      _CodecUtility.valueEncode(
        _getValue(
          isEqualTo,
          isNotEqualTo,
          isLessThan,
          isLessThanOrEqualTo,
          isGreaterThan,
          isGreaterThanOrEqualTo,
          arrayContains,
          arrayContainsAny,
          whereIn,
          whereNotIn,
          isNull,
        ),
      ),
    );
    _filterOperator = null;
  }

  String _getOperator(
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  ) {
    if (isEqualTo != null) return '==';
    if (isNotEqualTo != null) return '!=';
    if (isLessThan != null) return '<';
    if (isLessThanOrEqualTo != null) return '<=';
    if (isGreaterThan != null) return '>';
    if (isGreaterThanOrEqualTo != null) return '>=';
    if (arrayContains != null) return 'array-contains';
    if (arrayContainsAny != null) return 'array-contains-any';
    if (whereIn != null) return 'in';
    if (whereNotIn != null) return 'not-in';
    if (isNull != null) {
      if (isNull) {
        return '==';
      } else {
        return '!=';
      }
    }
    throw Exception('Exactly one operator must be specified');
  }

  Object? _getValue(
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  ) {
    if (isEqualTo != null) return isEqualTo;
    if (isNotEqualTo != null) return isNotEqualTo;
    if (isLessThan != null) return isLessThan;
    if (isLessThanOrEqualTo != null) return isLessThanOrEqualTo;
    if (isGreaterThan != null) return isGreaterThan;
    if (isGreaterThanOrEqualTo != null) return isGreaterThanOrEqualTo;
    if (arrayContains != null) return arrayContains;
    if (arrayContainsAny != null) return arrayContainsAny;
    if (whereIn != null) return whereIn;
    if (whereNotIn != null) return whereNotIn;
    if (isNull != null) {
      if (isNull == true) {
        return null;
      } else {
        return null;
      }
    }
    throw Exception('Exactly one operator must be specified');
  }

  /// Creates a new filter that is a disjunction of the given filters.
  ///
  /// A disjunction filter includes a document if it satisfies any of the given filters.
  static Filter or(
    Filter filter1,
    Filter filter2,
    // Number of OR operation is limited on the server side
    // We let here 30 as a limit
    [
    Filter? filter3,
    Filter? filter4,
    Filter? filter5,
    Filter? filter6,
    Filter? filter7,
    Filter? filter8,
    Filter? filter9,
    Filter? filter10,
    Filter? filter11,
    Filter? filter12,
    Filter? filter13,
    Filter? filter14,
    Filter? filter15,
    Filter? filter16,
    Filter? filter17,
    Filter? filter18,
    Filter? filter19,
    Filter? filter20,
    Filter? filter21,
    Filter? filter22,
    Filter? filter23,
    Filter? filter24,
    Filter? filter25,
    Filter? filter26,
    Filter? filter27,
    Filter? filter28,
    Filter? filter29,
    Filter? filter30,
  ]) {
    return _generateFilter(
      'OR',
      [
        filter1,
        filter2,
        filter3,
        filter4,
        filter5,
        filter6,
        filter7,
        filter8,
        filter9,
        filter10,
        filter11,
        filter12,
        filter13,
        filter14,
        filter15,
        filter16,
        filter17,
        filter18,
        filter19,
        filter20,
        filter21,
        filter22,
        filter23,
        filter24,
        filter25,
        filter26,
        filter27,
        filter28,
        filter29,
        filter30,
      ],
    );
  }

  /// Creates a new filter that is a conjunction of the given filters.
  ///
  /// A conjunction filter includes document if it satisfies all of the given filters.
  static Filter and(
    Filter filter1,
    Filter filter2, [
    Filter? filter3,
    Filter? filter4,
    Filter? filter5,
    Filter? filter6,
    Filter? filter7,
    Filter? filter8,
    Filter? filter9,
    Filter? filter10,
    Filter? filter11,
    Filter? filter12,
    Filter? filter13,
    Filter? filter14,
    Filter? filter15,
    Filter? filter16,
    Filter? filter17,
    Filter? filter18,
    Filter? filter19,
    Filter? filter20,
    Filter? filter21,
    Filter? filter22,
    Filter? filter23,
    Filter? filter24,
    Filter? filter25,
    Filter? filter26,
    Filter? filter27,
    Filter? filter28,
    Filter? filter29,
    Filter? filter30,
  ]) {
    return _generateFilter(
      'AND',
      [
        filter1,
        filter2,
        filter3,
        filter4,
        filter5,
        filter6,
        filter7,
        filter8,
        filter9,
        filter10,
        filter11,
        filter12,
        filter13,
        filter14,
        filter15,
        filter16,
        filter17,
        filter18,
        filter19,
        filter20,
        filter21,
        filter22,
        filter23,
        filter24,
        filter25,
        filter26,
        filter27,
        filter28,
        filter29,
        filter30,
      ],
    );
  }

  static Filter _generateFilter(
    String operator,
    List<Filter?> filters,
  ) {
    assert(
      () {
        final filtersUsed = filters.where((e) => e != null).length;
        return filtersUsed >= 2;
      }(),
      'At least two filters must be specified',
    );
    return Filter._(
      null,
      _FilterOperator(
        operator,
        [
          for (final filter in filters)
            if (filter != null && filter._filterQuery != null)
              filter._filterQuery
            else if (filter != null && filter._filterOperator != null)
              filter._filterOperator,
        ],
      ),
    );
  }

  /// Returns a map representation of this filter.
  @override
  Map<String, Object?> toJson() {
    if (_filterOperator != null) {
      return _filterOperator.build();
    } else if (_filterQuery != null) {
      return _filterQuery.build();
    }
    throw Exception('Exactly one operator must be specified');
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\firestore.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// The entry point for accessing a [FirebaseFirestore].
///
/// You can get an instance by calling [FirebaseFirestore.instance]. The instance
/// can also be created with a secondary [Firebase] app by calling
/// [FirebaseFirestore.instanceFor], for example:
///
/// ```dart
/// FirebaseApp secondaryApp = Firebase.app('SecondaryApp');
///
/// FirebaseFirestore firestore = FirebaseFirestore.instanceFor(app: secondaryApp);
/// ```
class FirebaseFirestore extends FirebasePluginPlatform {
  FirebaseFirestore._({
    required this.app,
    required this.databaseId,
  }) : super(app.name, 'plugins.flutter.io/firebase_firestore');

  static final Map<String, FirebaseFirestore> _cachedInstances = {};

  /// Returns an instance using the default [FirebaseApp].
  static FirebaseFirestore get instance {
    return FirebaseFirestore.instanceFor(
      app: Firebase.app(),
    );
  }

  /// Returns an instance using a specified [FirebaseApp].
  static FirebaseFirestore instanceFor({
    required FirebaseApp app,
    String? databaseId,
  }) {
    String firestoreDatabaseId = databaseId ?? '(default)';
    String cacheKey = '${app.name}|$firestoreDatabaseId';
    if (_cachedInstances.containsKey(cacheKey)) {
      return _cachedInstances[cacheKey]!;
    }

    FirebaseFirestore newInstance = FirebaseFirestore._(
      app: app,
      databaseId: firestoreDatabaseId,
    );
    _cachedInstances[cacheKey] = newInstance;

    return newInstance;
  }

  // Cached and lazily loaded instance of [FirestorePlatform] to avoid
  // creating a [MethodChannelFirestore] when not needed or creating an
  // instance with the default app before a user specifies an app.
  FirebaseFirestorePlatform? _delegatePackingProperty;

  FirebaseFirestorePlatform get _delegate {
    return _delegatePackingProperty ??= FirebaseFirestorePlatform.instanceFor(
      app: app,
      databaseId: databaseId,
    );
  }

  /// The [FirebaseApp] for this current [FirebaseFirestore] instance.
  FirebaseApp app;

  /// Firestore Database ID for this instance. Falls back to default database: "(default)"
  String databaseId;

  /// Gets a [CollectionReference] for the specified Firestore path.
  CollectionReference<Map<String, dynamic>> collection(String collectionPath) {
    if (collectionPath.isEmpty) {
      throw ArgumentError('A collection path must be a non-empty string.');
    } else if (collectionPath.contains('//')) {
      throw ArgumentError('A collection path must not contain "//".');
    } else if (!isValidCollectionPath(collectionPath)) {
      throw ArgumentError(
        'A collection path must point to a valid collection.',
      );
    }

    return _JsonCollectionReference(this, _delegate.collection(collectionPath));
  }

  /// Returns a [WriteBatch], used for performing multiple writes as a single
  /// atomic operation.
  ///
  /// Unlike [Transaction]s, [WriteBatch]es are persisted offline and therefore are
  /// preferable when you donâ€™t need to condition your writes on read data.
  WriteBatch batch() {
    return WriteBatch._(this, _delegate.batch());
  }

  /// Clears the persistent storage, including pending writes and cached documents.
  ///
  /// Must be called while the FirebaseFirestore instance is not started (after the app is shutdown or when the app is first initialized).
  /// On startup, this method must be called before other methods (other than [FirebaseFirestore.instance.settings]).
  /// If the FirebaseFirestore instance is still running, the Future will fail.
  ///
  /// Note: clearPersistence() is primarily intended to help write reliable tests that use Cloud Firestore.
  /// It uses an efficient mechanism for dropping existing data but does not attempt to securely
  /// overwrite or otherwise make cached data unrecoverable. For applications that are sensitive to
  /// the disclosure of cached data in between user sessions, we strongly recommend not enabling persistence at all.
  Future<void> clearPersistence() {
    return _delegate.clearPersistence();
  }

  LoadBundleTask loadBundle(Uint8List bundle) {
    return LoadBundleTask._(_delegate.loadBundle(bundle));
  }

  /// Changes this instance to point to a FirebaseFirestore emulator running locally.
  ///
  /// Set the [host] of the local emulator, such as "localhost"
  /// Set the [port] of the local emulator, such as "8080" (port 8080 is default)
  ///
  /// Note: Must be called immediately, prior to accessing FirebaseFirestore methods.
  /// Do not use with production credentials as emulator traffic is not encrypted.
  void useFirestoreEmulator(
    String host,
    int port, {
    bool sslEnabled = false,
    bool automaticHostMapping = true,
  }) {
    if (kIsWeb) {
      // use useEmulator() API for web as settings are set immediately unlike native platforms
      try {
        _delegate.useEmulator(host, port);
      } catch (e) {
        // We convert to string to be compatible with Flutter <= 3.7 and Flutter >= 3.10
        // .code is only available in Flutter <= 3.7
        String strError = e.toString();

        // this catches FirebaseError from web that occurs after hot reloading & hot restarting
        if (!strError.contains('failed-precondition')) {
          rethrow;
        }
      }
    } else {
      String mappedHost = host;
      // Android considers localhost as 10.0.2.2 - automatically handle this for users.
      if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
        if ((mappedHost == 'localhost' || mappedHost == '127.0.0.1') &&
            automaticHostMapping) {
          // ignore: avoid_print
          print('Mapping Firestore Emulator host "$mappedHost" to "10.0.2.2".');
          mappedHost = '10.0.2.2';
        }
      }

      _delegate.settings = _delegate.settings.copyWith(
        // "sslEnabled" has to be set to false for android to work
        sslEnabled: sslEnabled,
        host: '$mappedHost:$port',
      );
    }
  }

  /// Performs a [namedQueryGet] and decode the result using [Query.withConverter].
  Future<QuerySnapshot<T>> namedQueryWithConverterGet<T>(
    String name, {
    GetOptions options = const GetOptions(),
    required FromFirestore<T> fromFirestore,
    required ToFirestore<T> toFirestore,
  }) async {
    final snapshot = await namedQueryGet(name, options: options);

    return _WithConverterQuerySnapshot<T>(snapshot, fromFirestore, toFirestore);
  }

  /// Reads a [QuerySnapshot] if a namedQuery has been retrieved and passed as a [Buffer] to [loadBundle()]. To read from cache, pass [GetOptions.source] value as [Source.cache].
  /// To read from the Firestore backend, use [GetOptions.source] as [Source.server].
  Future<QuerySnapshot<Map<String, dynamic>>> namedQueryGet(
    String name, {
    GetOptions options = const GetOptions(),
  }) async {
    QuerySnapshotPlatform snapshotDelegate =
        await _delegate.namedQueryGet(name, options: options);
    return _JsonQuerySnapshot(FirebaseFirestore.instance, snapshotDelegate);
  }

  /// Gets a [Query] for the specified collection group.
  Query<Map<String, dynamic>> collectionGroup(String collectionPath) {
    if (collectionPath.isEmpty) {
      throw ArgumentError('A collection path must be a non-empty string.');
    } else if (collectionPath.contains('/')) {
      throw ArgumentError(
        'A collection path passed to collectionGroup() cannot contain "/".',
      );
    }

    return _JsonQuery(this, _delegate.collectionGroup(collectionPath));
  }

  /// Instructs [FirebaseFirestore] to disable the network for the instance.
  ///
  /// Once disabled, any writes will only resolve once connection has been
  /// restored. However, the local database will still be updated and any
  /// listeners will still trigger.
  Future<void> disableNetwork() {
    return _delegate.disableNetwork();
  }

  /// Gets a [DocumentReference] for the specified Firestore path.
  DocumentReference<Map<String, dynamic>> doc(String documentPath) {
    if (documentPath.isEmpty) {
      throw ArgumentError('A document path must be a non-empty string.');
    } else if (documentPath.contains('//')) {
      throw ArgumentError('A document path must not contain "//".');
    } else if (!isValidDocumentPath(documentPath)) {
      throw ArgumentError('A document path must point to a valid document.');
    }

    return _JsonDocumentReference(this, _delegate.doc(documentPath));
  }

  /// Enables the network for this instance. Any pending local-only writes
  /// will be written to the remote servers.
  Future<void> enableNetwork() {
    return _delegate.enableNetwork();
  }

  /// Returns a [Stream] which is called each time all of the active listeners
  /// have been synchronized.
  Stream<void> snapshotsInSync() {
    return _delegate.snapshotsInSync();
  }

  /// Executes the given [TransactionHandler] and then attempts to commit the
  /// changes applied within an atomic transaction.
  ///
  /// In the [TransactionHandler], a set of reads and writes can be performed
  /// atomically using the [Transaction] object passed to the [TransactionHandler].
  /// After the [TransactionHandler] is run, [FirebaseFirestore] will attempt to apply the
  /// changes to the server. If any of the data read has been modified outside
  /// of this [Transaction] since being read, then the transaction will be
  /// retried by executing the provided [TransactionHandler] again. If the transaction still
  /// fails after 5 retries, then the transaction will fail.s
  ///
  /// The [TransactionHandler] may be executed multiple times, it should be able
  /// to handle multiple executions.
  ///
  /// Data accessed with the transaction will not reflect local changes that
  /// have not been committed. For this reason, it is required that all
  /// reads are performed before any writes. Transactions must be performed
  /// while online. Otherwise, reads will fail, and the final commit will fail.
  ///
  /// By default transactions are limited to 30 seconds of execution time. This
  /// timeout can be adjusted by setting the timeout parameter.
  ///
  /// By default transactions will retry 5 times. You can change the number of attempts
  /// with [maxAttempts]. Attempts should be at least 1.
  Future<T> runTransaction<T>(
    TransactionHandler<T> transactionHandler, {
    Duration timeout = const Duration(seconds: 30),
    int maxAttempts = 5,
  }) async {
    late T output;
    await _delegate.runTransaction(
      (transaction) async {
        output = await transactionHandler(Transaction._(this, transaction));
      },
      timeout: timeout,
      maxAttempts: maxAttempts,
    );

    return output;
  }

  /// Specifies custom settings to be used to configure this [FirebaseFirestore] instance.
  ///
  /// You must set these before invoking any other methods on this [FirebaseFirestore] instance.
  set settings(Settings settings) {
    _delegate.settings = _delegate.settings.copyWith(
      sslEnabled: settings.sslEnabled,
      persistenceEnabled: settings.persistenceEnabled,
      host: settings.host,
      cacheSizeBytes: settings.cacheSizeBytes,
      webExperimentalForceLongPolling: settings.webExperimentalForceLongPolling,
      webExperimentalAutoDetectLongPolling:
          settings.webExperimentalAutoDetectLongPolling,
      webExperimentalLongPollingOptions:
          settings.webExperimentalLongPollingOptions,
    );
  }

  /// The current [Settings] for this [FirebaseFirestore] instance.
  Settings get settings {
    return _delegate.settings;
  }

  /// Terminates this [FirebaseFirestore] instance.
  ///
  /// After calling [terminate()] only the [clearPersistence()] method may be used.
  /// Any other method will throw a [FirebaseException].
  ///
  /// Termination does not cancel any pending writes, and any promises that are
  /// awaiting a response from the server will not be resolved. If you have
  /// persistence enabled, the next time you start this instance, it will resume
  ///  sending these writes to the server.
  ///
  /// Note: Under normal circumstances, calling [terminate()] is not required.
  /// This method is useful only when you want to force this instance to release
  ///  all of its resources or in combination with [clearPersistence()] to ensure
  ///  that all local state is destroyed between test runs.
  Future<void> terminate() {
    return _delegate.terminate();
  }

  /// Waits until all currently pending writes for the active user have been
  /// acknowledged by the backend.
  ///
  /// The returned Future resolves immediately if there are no outstanding writes.
  /// Otherwise, the Promise waits for all previously issued writes (including
  /// those written in a previous app session), but it does not wait for writes
  /// that were added after the method is called. If you want to wait for
  /// additional writes, call [waitForPendingWrites] again.
  ///
  /// Any outstanding [waitForPendingWrites] calls are rejected during user changes.
  Future<void> waitForPendingWrites() {
    return _delegate.waitForPendingWrites();
  }

  PersistentCacheIndexManager? persistentCacheIndexManager() {
    if (defaultTargetPlatform == TargetPlatform.windows) {
      throw UnimplementedError(
        '`PersistentCacheIndexManager` is not available on Windows platform',
      );
    }

    PersistentCacheIndexManagerPlatform? indexManager =
        _delegate.persistentCacheIndexManager();
    if (indexManager != null) {
      return PersistentCacheIndexManager._(
        indexManager,
      );
    }
    return null;
  }

  /// Configures indexing for local query execution. Any previous index configuration is overridden.
  ///
  /// The index entries themselves are created asynchronously. You can continue to use queries that
  /// require indexing even if the indices are not yet available. Query execution will automatically
  /// start using the index once the index entries have been written.
  /// See Firebase documentation to learn how to configure your index configuration JSON file:
  /// https://firebase.google.com/docs/reference/firestore/indexes
  ///
  /// This API is in preview mode and is subject to change.
  @experimental
  Future<void> setIndexConfigurationFromJSON(String json) async {
    return _delegate.setIndexConfiguration(json);
  }

  /// Globally enables / disables Cloud Firestore logging for the SDK.
  static Future<void> setLoggingEnabled(bool enabled) {
    return FirebaseFirestorePlatform.instance.setLoggingEnabled(enabled);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) =>
      other is FirebaseFirestore && other.app.name == app.name;

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hash(app.name, app.options);

  @override
  String toString() => '$FirebaseFirestore(app: ${app.name})';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\load_bundle_task.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

class LoadBundleTask {
  LoadBundleTask._(this._delegate) {
    LoadBundleTaskPlatform.verify(_delegate);
  }

  final LoadBundleTaskPlatform _delegate;

  late final Stream<LoadBundleTaskSnapshot> stream =
      // ignore: unnecessary_lambdas, false positive, event is dynamic
      _delegate.stream.map((event) => LoadBundleTaskSnapshot._(event));
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\load_bundle_task_snapshot.dart =====
// Copyright 2021, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [LoadBundleTaskSnapshot] is returned as the result or on-going process of a [LoadBundleTask].
class LoadBundleTaskSnapshot {
  LoadBundleTaskSnapshot._(this._delegate) {
    LoadBundleTaskSnapshotPlatform.verify(_delegate);
  }
  LoadBundleTaskSnapshotPlatform _delegate;

  /// How many bytes have been loaded.
  int get bytesLoaded => _delegate.bytesLoaded;

  /// How many documents have been loaded.
  int get documentsLoaded => _delegate.documentsLoaded;

  /// The current load bundle task snapshot state.
  ///
  /// The state indicates the current progress of the task, such as whether it
  /// is running, paused or completed.
  LoadBundleTaskState get taskState => _delegate.taskState;

  /// The total bytes of the load bundle task.
  int get totalBytes => _delegate.totalBytes;

  /// How many documents are in the bundle being loaded.
  int get totalDocuments => _delegate.totalDocuments;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\persistent_cache_index_manager.dart =====
// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

class PersistentCacheIndexManager {
  PersistentCacheIndexManager._(this._delegate) {
    PersistentCacheIndexManagerPlatform.verify(_delegate);
  }

  /// The platform delegate that interacts with the platform code.
  final PersistentCacheIndexManagerPlatform _delegate;

  /// Enables the SDK to create persistent cache indexes automatically for local query
  /// execution when the SDK believes cache indexes can help improves performance.
  /// This feature is disabled by default.
  Future<void> enableIndexAutoCreation() {
    return _delegate.enableIndexAutoCreation();
  }

  /// Stops creating persistent cache indexes automatically for local query execution.
  /// The indexes which have been created by calling `enableIndexAutoCreation()` still take effect.
  Future<void> disableIndexAutoCreation() {
    return _delegate.disableIndexAutoCreation();
  }

  /// Removes all persistent cache indexes. Note this function also deletes indexes
  /// generated by `setIndexConfiguration()`, which is deprecated.
  Future<void> deleteAllIndexes() {
    return _delegate.deleteAllIndexes();
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\query.dart =====
// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// Represents a [Query] over the data at a particular location.
///
/// Can construct refined [Query] objects by adding filters and ordering.
// `extends Object?` so that type inference defaults to `Object?` instead of `dynamic`
@sealed
@immutable
abstract class Query<T extends Object?> {
  /// The [FirebaseFirestore] instance of this query.
  FirebaseFirestore get firestore;

  /// Exposes the [parameters] on the query delegate.
  ///
  /// This should only be used for testing to ensure that all
  /// query modifiers are correctly set on the underlying delegate
  /// when being tested from a different package.
  Map<String, dynamic> get parameters;

  /// Creates and returns a new [Query] that ends at the provided document
  /// (inclusive). The end position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Cannot be used in combination with [endBefore], [endBeforeDocument], or
  /// [endAt], but can be used in combination with [startAt],
  /// [startAfter], [startAtDocument] and [startAfterDocument].
  ///
  /// See also:
  ///
  ///  * [startAfterDocument] for a query that starts after a document.
  ///  * [startAtDocument] for a query that starts at a document.
  ///  * [endBeforeDocument] for a query that ends before a document.
  Query<T> endAtDocument(
    // Voluntarily accepts any DocumentSnapshot<T>
    DocumentSnapshot documentSnapshot,
  );

  /// Takes a list of [values], creates and returns a new [Query] that ends at the
  /// provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  Query<T> endAt(Iterable<Object?> values);

  /// Creates and returns a new [Query] that ends before the provided document
  /// snapshot (exclusive). The end position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  Query<T> endBeforeDocument(
    // Voluntarily accepts any DocumentSnapshot<T>
    DocumentSnapshot documentSnapshot,
  );

  /// Takes a list of [values], creates and returns a new [Query] that ends before
  /// the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  Query<T> endBefore(Iterable<Object?> values);

  /// Fetch the documents for this query.
  ///
  /// To modify how the query is fetched, the [options] parameter can be provided
  /// with a [GetOptions] instance.
  Future<QuerySnapshot<T>> get([GetOptions? options]);

  /// Creates and returns a new Query that's additionally limited to only return up
  /// to the specified number of documents.
  Query<T> limit(int limit);

  /// Creates and returns a new Query that only returns the last matching documents.
  ///
  /// You must specify at least one orderBy clause for limitToLast queries,
  /// otherwise an exception will be thrown during execution.
  Query<T> limitToLast(int limit);

  /// Notifies of query results at this location.
  Stream<QuerySnapshot<T>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  });

  /// Creates and returns a new [Query] that's additionally sorted by the specified
  /// [field].
  /// The field may be a [String] representing a single field name or a [FieldPath].
  ///
  /// After a [FieldPath.documentId] order by call, you cannot add any more [orderBy]
  /// calls.
  ///
  /// Furthermore, you may not use [orderBy] on the [FieldPath.documentId] [field] when
  /// using [startAfterDocument], [startAtDocument], [endBeforeDocument],
  /// or [endAtDocument] because the order by clause on the document id
  /// is added by these methods implicitly.
  Query<T> orderBy(Object field, {bool descending = false});

  /// Creates and returns a new [Query] that starts after the provided document
  /// (exclusive). The starting position is relative to the order of the query.
  /// The [documentSnapshot] must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  Query<T> startAfterDocument(
    // Voluntarily accepts any DocumentSnapshot<T>
    DocumentSnapshot documentSnapshot,
  );

  /// Takes a list of [values], creates and returns a new [Query] that starts
  /// after the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  Query<T> startAfter(Iterable<Object?> values);

  /// Creates and returns a new [Query] that starts at the provided document
  /// (inclusive). The starting position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  Query<T> startAtDocument(
    // Voluntarily accepts any DocumentSnapshot<T>
    DocumentSnapshot documentSnapshot,
  );

  /// Takes a list of [values], creates and returns a new [Query] that starts at
  /// the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  Query<T> startAt(Iterable<Object?> values);

  /// Creates and returns a new [Query] with additional filter on specified
  /// [field]. [field] refers to a field in a document.
  ///
  /// The [field] may be a [String] consisting of a single field name
  /// (referring to a top level field in the document),
  /// or a series of field names separated by dots '.'
  /// (referring to a nested field in the document).
  /// Alternatively, the [field] can also be a [FieldPath].
  ///
  /// Only documents satisfying provided condition are included in the result
  /// set.
  Query<T> where(
    Object field, {
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  });

  /// Transforms a [Query] to manipulate a custom object instead
  /// of a `Map<String, dynamic>`.
  ///
  /// This makes both read and write operations type-safe.
  ///
  /// ```dart
  /// final personsRef = FirebaseFirestore
  ///     .instance
  ///     .collection('persons')
  ///     .where('age', isGreaterThan: 0)
  ///     .withConverter<Person>(
  ///       fromFirestore: (snapshot, _) => Person.fromJson(snapshot.data()!),
  ///       toFirestore: (person, _) => person.toJson(),
  ///     );
  ///
  /// Future<void> main() async {
  ///   List<QuerySnapshot<Person>> persons = await personsRef.get().then((s) => s.docs);
  /// }
  /// ```
  Query<R> withConverter<R>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  });

  AggregateQuery count();

  /// Calculates the specified aggregations over the documents in the
  /// result set of the given query, without actually downloading the documents.
  AggregateQuery aggregate(
    AggregateField aggregateField1, [
    AggregateField? aggregateField2,
    AggregateField? aggregateField3,
    AggregateField? aggregateField4,
    AggregateField? aggregateField5,
    AggregateField? aggregateField6,
    AggregateField? aggregateField7,
    AggregateField? aggregateField8,
    AggregateField? aggregateField9,
    AggregateField? aggregateField10,
    AggregateField? aggregateField11,
    AggregateField? aggregateField12,
    AggregateField? aggregateField13,
    AggregateField? aggregateField14,
    AggregateField? aggregateField15,
    AggregateField? aggregateField16,
    AggregateField? aggregateField17,
    AggregateField? aggregateField18,
    AggregateField? aggregateField19,
    AggregateField? aggregateField20,
    AggregateField? aggregateField21,
    AggregateField? aggregateField22,
    AggregateField? aggregateField23,
    AggregateField? aggregateField24,
    AggregateField? aggregateField25,
    AggregateField? aggregateField26,
    AggregateField? aggregateField27,
    AggregateField? aggregateField28,
    AggregateField? aggregateField29,
    AggregateField? aggregateField30,
  ]);
}

/// Represents a [Query] over the data at a particular location.
///
/// Can construct refined [Query] objects by adding filters and ordering.
class _JsonQuery implements Query<Map<String, dynamic>> {
  _JsonQuery(
    this.firestore,
    this._delegate,
  ) {
    QueryPlatform.verify(_delegate);
  }

  @override
  final FirebaseFirestore firestore;

  final QueryPlatform _delegate;

  /// Exposes the [parameters] on the query delegate.
  ///
  /// This should only be used for testing to ensure that all
  /// query modifiers are correctly set on the underlying delegate
  /// when being tested from a different package.
  @override
  Map<String, dynamic> get parameters {
    return _delegate.parameters;
  }

  /// Returns whether the current query has a "start" cursor query.
  bool _hasStartCursor() {
    return parameters['startAt'] != null || parameters['startAfter'] != null;
  }

  /// Returns whether the current query has a "end" cursor query.
  bool _hasEndCursor() {
    return parameters['endAt'] != null || parameters['endBefore'] != null;
  }

  bool isNotIn(String operator) {
    return operator == 'not-in';
  }

  /// Asserts that a [DocumentSnapshot] can be used within the current
  /// query.
  ///
  /// Since a native DocumentSnapshot cannot be created without additional
  /// database calls, any ordered values are extracted from the document and
  /// passed to the query.
  Map<String, dynamic> _assertQueryCursorSnapshot(
    DocumentSnapshot documentSnapshot,
  ) {
    assert(
      documentSnapshot.exists,
      'a document snapshot must exist to be used within a query',
    );

    List<List<dynamic>> orders = List.from(parameters['orderBy']);
    List<dynamic> values = [];

    for (final List<dynamic> order in orders) {
      dynamic field = order[0];

      // All order by fields must exist within the snapshot
      if (field != FieldPath.documentId) {
        try {
          final codecValue =
              _CodecUtility.valueEncode(documentSnapshot.get(field));
          values.add(codecValue);
        } on StateError {
          throw "You are trying to start or end a query using a document for which the field '$field' (used as the orderBy) does not exist.";
        }
      }
    }

    // Any time you construct a query and don't include 'name' in the orderBys,
    // Firestore will implicitly assume an additional .orderBy('__name__', DIRECTION)
    // where DIRECTION will match the last orderBy direction of your query (or 'asc' if you have no orderBys).
    if (orders.isNotEmpty) {
      List<dynamic> lastOrder = orders.last;

      if (lastOrder[0] != FieldPath.documentId) {
        orders.add([FieldPath.documentId, lastOrder[1]]);
      }
    } else {
      orders.add([FieldPath.documentId, false]);
    }

    if (_delegate.isCollectionGroupQuery) {
      values.add(documentSnapshot.reference.path);
    } else {
      values.add(documentSnapshot.id);
    }

    return <String, dynamic>{
      'orders': orders,
      'values': values,
    };
  }

  /// Common handler for all non-document based cursor queries.
  Iterable<dynamic> _assertQueryCursorValues(Iterable<Object?> fields) {
    List<List<Object?>> orders = List.from(parameters['orderBy']);

    assert(
      fields.length <= orders.length,
      'Too many arguments provided. '
      'The number of arguments must be less than or equal to the number of orderBy() clauses.',
    );

    return fields;
  }

  /// Asserts that the query [field] is either a String or a [FieldPath].
  void _assertValidFieldType(Object field) {
    assert(
      field is String ||
          field is FieldPath ||
          field == FieldPath.documentId ||
          field is Filter,
      'Supported [field] types are [String], [FieldPath], and [Filter].',
    );
  }

  /// Creates and returns a new [Query] that ends at the provided document
  /// (inclusive). The end position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Cannot be used in combination with [endBefore], [endBeforeDocument], or
  /// [endAt], but can be used in combination with [startAt],
  /// [startAfter], [startAtDocument] and [startAfterDocument].
  ///
  /// See also:
  ///
  ///  * [startAfterDocument] for a query that starts after a document.
  ///  * [startAtDocument] for a query that starts at a document.
  ///  * [endBeforeDocument] for a query that ends before a document.
  @override
  Query<Map<String, dynamic>> endAtDocument(DocumentSnapshot documentSnapshot) {
    Map<String, dynamic> results = _assertQueryCursorSnapshot(documentSnapshot);
    return _JsonQuery(
      firestore,
      _delegate.endAtDocument(results['orders'], results['values']),
    );
  }

  /// Takes a list of [values], creates and returns a new [Query] that ends at the
  /// provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  @override
  Query<Map<String, dynamic>> endAt(Iterable<Object?> values) {
    _assertQueryCursorValues(values);
    return _JsonQuery(firestore, _delegate.endAt(values.toList()));
  }

  /// Creates and returns a new [Query] that ends before the provided document
  /// snapshot (exclusive). The end position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  @override
  Query<Map<String, dynamic>> endBeforeDocument(
    DocumentSnapshot documentSnapshot,
  ) {
    Map<String, dynamic> results = _assertQueryCursorSnapshot(documentSnapshot);
    return _JsonQuery(
      firestore,
      _delegate.endBeforeDocument(results['orders'], results['values']),
    );
  }

  /// Takes a list of [values], creates and returns a new [Query] that ends before
  /// the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "end" query modifiers.
  @override
  Query<Map<String, dynamic>> endBefore(Iterable<Object?> values) {
    _assertQueryCursorValues(values);
    return _JsonQuery(
      firestore,
      _delegate.endBefore(values.toList()),
    );
  }

  /// Fetch the documents for this query.
  ///
  /// To modify how the query is fetched, the [options] parameter can be provided
  /// with a [GetOptions] instance.
  @override
  Future<QuerySnapshot<Map<String, dynamic>>> get([GetOptions? options]) async {
    QuerySnapshotPlatform snapshotDelegate =
        await _delegate.get(options ?? const GetOptions());
    return _JsonQuerySnapshot(firestore, snapshotDelegate);
  }

  /// Creates and returns a new Query that's additionally limited to only return up
  /// to the specified number of documents.
  @override
  Query<Map<String, dynamic>> limit(int limit) {
    assert(limit > 0, 'limit must be a positive number greater than 0');
    return _JsonQuery(firestore, _delegate.limit(limit));
  }

  /// Creates and returns a new Query that only returns the last matching documents.
  ///
  /// You must specify at least one orderBy clause for limitToLast queries,
  /// otherwise an exception will be thrown during execution.
  @override
  Query<Map<String, dynamic>> limitToLast(int limit) {
    assert(limit > 0, 'limit must be a positive number greater than 0');
    List<List<dynamic>> orders = List.from(parameters['orderBy']);
    assert(
      orders.isNotEmpty,
      'limitToLast() queries require specifying at least one orderBy() clause',
    );
    return _JsonQuery(firestore, _delegate.limitToLast(limit));
  }

  /// Notifies of query results at this location.
  @override
  Stream<QuerySnapshot<Map<String, dynamic>>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  }) {
    if (source == ListenSource.cache &&
        defaultTargetPlatform == TargetPlatform.windows) {
      throw UnimplementedError(
        'Listening from cache is not supported on Windows',
      );
    }

    return _delegate
        .snapshots(
          includeMetadataChanges: includeMetadataChanges,
          listenSource: source,
        )
        .map((item) => _JsonQuerySnapshot(firestore, item));
  }

  /// Creates and returns a new [Query] that's additionally sorted by the specified
  /// [field].
  /// The field may be a [String] representing a single field name or a [FieldPath].
  ///
  /// After a [FieldPath.documentId] order by call, you cannot add any more [orderBy]
  /// calls.
  ///
  /// Furthermore, you may not use [orderBy] on the [FieldPath.documentId] [field] when
  /// using [startAfterDocument], [startAtDocument], [endBeforeDocument],
  /// or [endAtDocument] because the order by clause on the document id
  /// is added by these methods implicitly.
  @override
  Query<Map<String, dynamic>> orderBy(
    Object field, {
    bool descending = false,
  }) {
    _assertValidFieldType(field);
    assert(
      !_hasStartCursor(),
      'Invalid query. '
      'You must not call startAt(), startAtDocument(), '
      'startAfter() or startAfterDocument() before calling orderBy()',
    );
    assert(
      !_hasEndCursor(),
      'Invalid query. '
      'You must not call endAt(), endAtDocument(), '
      'endBefore() or endBeforeDocument() before calling orderBy()',
    );

    final List<List<dynamic>> orders =
        List<List<dynamic>>.from(parameters['orderBy']);

    assert(
      orders.where((List<dynamic> item) => field == item[0]).isEmpty,
      'OrderBy field "$field" already exists in this query',
    );

    if (field == FieldPath.documentId) {
      orders.add([field, descending]);
    } else {
      FieldPath fieldPath =
          field is String ? FieldPath.fromString(field) : field as FieldPath;
      orders.add([fieldPath, descending]);
    }

    return _JsonQuery(firestore, _delegate.orderBy(orders));
  }

  /// Creates and returns a new [Query] that starts after the provided document
  /// (exclusive). The starting position is relative to the order of the query.
  /// The [documentSnapshot] must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  @override
  Query<Map<String, dynamic>> startAfterDocument(
    DocumentSnapshot documentSnapshot,
  ) {
    Map<String, dynamic> results = _assertQueryCursorSnapshot(documentSnapshot);

    return _JsonQuery(
      firestore,
      _delegate.startAfterDocument(results['orders'], results['values']),
    );
  }

  /// Takes a list of [values], creates and returns a new [Query] that starts
  /// after the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  @override
  Query<Map<String, dynamic>> startAfter(Iterable<Object?> values) {
    _assertQueryCursorValues(values);
    return _JsonQuery(firestore, _delegate.startAfter(values.toList()));
  }

  /// Creates and returns a new [Query] that starts at the provided document
  /// (inclusive). The starting position is relative to the order of the query.
  /// The document must contain all of the fields provided in the orderBy of
  /// this query.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  @override
  Query<Map<String, dynamic>> startAtDocument(
    DocumentSnapshot documentSnapshot,
  ) {
    Map<String, dynamic> results = _assertQueryCursorSnapshot(documentSnapshot);

    return _JsonQuery(
      firestore,
      _delegate.startAtDocument(results['orders'], results['values']),
    );
  }

  /// Takes a list of [values], creates and returns a new [Query] that starts at
  /// the provided fields relative to the order of the query.
  ///
  /// The [values] must be in order of [orderBy] filters.
  ///
  /// Calling this method will replace any existing cursor "start" query modifiers.
  @override
  Query<Map<String, dynamic>> startAt(Iterable<Object?> values) {
    _assertQueryCursorValues(values);
    return _JsonQuery(firestore, _delegate.startAt(values.toList()));
  }

  /// Creates and returns a new [Query] with additional filter on specified
  /// [fieldOrFilter]. [fieldOrFilter] refers to a field in a document or a [Filter] object.
  ///
  /// The [fieldOrFilter] may be a [String] consisting of a single field name
  /// (referring to a top level field in the document),
  /// a series of field names separated by dots '.'
  /// (referring to a nested field in the document),
  /// or a [Filter] that can be used to combine multiple conditions.
  /// Alternatively, the [field] can also be a [FieldPath].
  ///
  /// Only documents satisfying provided condition are included in the result
  /// set.
  @override
  Query<Map<String, dynamic>> where(
    Object fieldOrFilter, {
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  }) {
    _assertValidFieldType(fieldOrFilter);

    if (fieldOrFilter is Filter) {
      assert(
        isEqualTo == null &&
            isNotEqualTo == null &&
            isLessThan == null &&
            isLessThanOrEqualTo == null &&
            isGreaterThan == null &&
            isGreaterThanOrEqualTo == null &&
            arrayContains == null &&
            arrayContainsAny == null &&
            whereIn == null &&
            whereNotIn == null &&
            isNull == null,
        'Conditions cannot be used with a Filter. Use a single Filter instead, or use a String or a FieldPath as the first parameter.',
      );
      return _JsonQuery(firestore, _delegate.whereFilter(fieldOrFilter));
    }

    final field = fieldOrFilter;

    const ListEquality<dynamic> equality = ListEquality<dynamic>();
    final List<List<dynamic>> conditions =
        List<List<dynamic>>.from(parameters['where']);

    // Conditions can be chained from other [Query] instances
    void addCondition(dynamic field, String operator, dynamic value) {
      List<dynamic> condition;
      dynamic codecValue = _CodecUtility.valueEncode(value);

      if (field == FieldPath.documentId) {
        condition = <dynamic>[field, operator, codecValue];
      } else {
        FieldPath fieldPath =
            field is String ? FieldPath.fromString(field) : field as FieldPath;
        condition = <dynamic>[fieldPath, operator, codecValue];
      }

      assert(
        conditions
            .where((List<dynamic> item) => equality.equals(condition, item))
            .isEmpty,
        'Condition $condition already exists in this query.',
      );
      conditions.add(condition);
    }

    if (isEqualTo != null) addCondition(field, '==', isEqualTo);
    if (isNotEqualTo != null) addCondition(field, '!=', isNotEqualTo);
    if (isLessThan != null) addCondition(field, '<', isLessThan);
    if (isLessThanOrEqualTo != null) {
      addCondition(field, '<=', isLessThanOrEqualTo);
    }
    if (isGreaterThan != null) addCondition(field, '>', isGreaterThan);
    if (isGreaterThanOrEqualTo != null) {
      addCondition(field, '>=', isGreaterThanOrEqualTo);
    }
    if (arrayContains != null) {
      addCondition(field, 'array-contains', arrayContains);
    }
    if (arrayContainsAny != null) {
      addCondition(field, 'array-contains-any', arrayContainsAny);
    }
    if (whereIn != null) addCondition(field, 'in', whereIn);
    if (whereNotIn != null) addCondition(field, 'not-in', whereNotIn);
    if (isNull != null) {
      if (isNull == true) {
        addCondition(field, '==', null);
      } else {
        addCondition(field, '!=', null);
      }
    }

    bool hasIn = false;
    bool hasNotIn = false;
    bool hasNotEqualTo = false;
    bool hasNotEqualToOperatorAndNotDocumentIdField = false;
    bool hasArrayContains = false;
    bool hasArrayContainsAny = false;
    bool hasDocumentIdField = false;

    // Once all conditions have been set, we must now check them to ensure the
    // query is valid.
    for (final dynamic condition in conditions) {
      dynamic field = condition[0]; // FieldPath or FieldPathType
      String operator = condition[1];
      dynamic value = condition[2];

      if (field != FieldPath.documentId && hasDocumentIdField) {
        assert(
          operator != '!=',
          "You cannot use '!=' filters whilst using a FieldPath.documentId field in another filter.",
        );
      }

      if (field == FieldPath.documentId) {
        assert(
          !hasNotEqualToOperatorAndNotDocumentIdField,
          "You cannot use FieldPath.documentId field whilst using a '!=' filter on a different field.",
        );
        hasDocumentIdField = true;
      }

      if (operator == 'in' ||
          operator == 'array-contains-any' ||
          isNotIn(operator)) {
        assert(
          value is Iterable,
          "A non-empty [Iterable] is required for '$operator' filters.",
        );
        // This assert checks every operator other than "in" or "array-contains-any" have 10 or less filters
        assert(
          (operator == 'in' || operator == 'array-contains-any') ||
              (value as Iterable).length <= 10,
          "'$operator' filters support a maximum of 10 elements in the value [Iterable].",
        );
        // This assert checks whether "in" or "array-contains-any" have 30 or less filters
        assert(
          (operator != 'in' && operator != 'array-contains-any') ||
              (value as Iterable).length <= 30,
          "'$operator' filters support a maximum of 30 elements in the value [Iterable].",
        );
        assert(
          (value as Iterable).isNotEmpty,
          "'$operator' filters require a non-empty [Iterable].",
        );
        assert(
          (value as Iterable).where((value) => value == null).isEmpty,
          "'$operator' filters cannot contain 'null' in the [Iterable].",
        );
      }

      if (operator == '!=') {
        assert(!hasNotEqualTo, "You cannot use '!=' filters more than once.");
        assert(!hasNotIn, "You cannot use '!=' filters with 'not-in' filters.");

        hasNotEqualTo = true;

        if (field != FieldPath.documentId) {
          hasNotEqualToOperatorAndNotDocumentIdField = true;
        }
      }

      if (isNotIn(operator)) {
        assert(!hasNotIn, "You cannot use 'not-in' filters more than once.");
        assert(
          !hasNotEqualTo,
          "You cannot use 'not-in' filters with '!=' filters.",
        );
        assert(
          !hasIn,
          "You cannot use 'not-in' filters with 'in' filters.",
        );
        hasNotIn = true;
      }

      if (operator == 'in') {
        assert(
          !hasNotIn,
          "You cannot use 'in' filters with 'not-in' filters.",
        );
        hasIn = true;
      }

      if (operator == 'array-contains') {
        assert(
          !hasArrayContains,
          "You cannot use 'array-contains' filters more than once.",
        );
        hasArrayContains = true;
      }

      if (operator == 'array-contains-any') {
        assert(
          !hasArrayContainsAny,
          "You cannot use 'array-contains-any' filters more than once.",
        );
        hasArrayContainsAny = true;
      }

      if (operator == 'array-contains' || operator == 'array-contains-any') {
        assert(
          !(hasArrayContains && hasArrayContainsAny),
          "You cannot use both 'array-contains-any' or 'array-contains' filters together.",
        );
      }
    }

    return _JsonQuery(firestore, _delegate.where(conditions));
  }

  @override
  Query<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterQuery(
      this,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) {
    return runtimeType == other.runtimeType &&
        other is _JsonQuery &&
        other.firestore == firestore &&
        other._delegate == _delegate;
  }

  @override
  int get hashCode => Object.hash(runtimeType, firestore, _delegate);

  /// Represents an [AggregateQuery] over the data at a particular location for retrieving metadata
  /// without retrieving the actual documents.
  @override
  AggregateQuery count() {
    return AggregateQuery._(_delegate.count(), this);
  }

  /// Calculates the specified aggregations over the documents in the
  /// result set of the given query, without actually downloading the documents.
  @override
  AggregateQuery aggregate(
    AggregateField aggregateField1, [
    AggregateField? aggregateField2,
    AggregateField? aggregateField3,
    AggregateField? aggregateField4,
    AggregateField? aggregateField5,
    AggregateField? aggregateField6,
    AggregateField? aggregateField7,
    AggregateField? aggregateField8,
    AggregateField? aggregateField9,
    AggregateField? aggregateField10,
    AggregateField? aggregateField11,
    AggregateField? aggregateField12,
    AggregateField? aggregateField13,
    AggregateField? aggregateField14,
    AggregateField? aggregateField15,
    AggregateField? aggregateField16,
    AggregateField? aggregateField17,
    AggregateField? aggregateField18,
    AggregateField? aggregateField19,
    AggregateField? aggregateField20,
    AggregateField? aggregateField21,
    AggregateField? aggregateField22,
    AggregateField? aggregateField23,
    AggregateField? aggregateField24,
    AggregateField? aggregateField25,
    AggregateField? aggregateField26,
    AggregateField? aggregateField27,
    AggregateField? aggregateField28,
    AggregateField? aggregateField29,
    AggregateField? aggregateField30,
  ]) {
    return AggregateQuery._(
      _delegate.aggregate(
        aggregateField1,
        aggregateField2,
        aggregateField3,
        aggregateField4,
        aggregateField5,
        aggregateField6,
        aggregateField7,
        aggregateField8,
        aggregateField9,
        aggregateField10,
        aggregateField11,
        aggregateField12,
        aggregateField13,
        aggregateField14,
        aggregateField15,
        aggregateField16,
        aggregateField17,
        aggregateField18,
        aggregateField19,
        aggregateField20,
        aggregateField21,
        aggregateField22,
        aggregateField23,
        aggregateField24,
        aggregateField25,
        aggregateField26,
        aggregateField27,
        aggregateField28,
        aggregateField29,
        aggregateField30,
      ),
      this,
    );
  }
}

class _WithConverterQuery<T extends Object?> implements Query<T> {
  _WithConverterQuery(
    this._originalQuery,
    this._fromFirestore,
    this._toFirestore,
  );

  final Query<Map<String, dynamic>> _originalQuery;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  FirebaseFirestore get firestore => _originalQuery.firestore;

  @override
  Map<String, dynamic> get parameters => _originalQuery.parameters;

  Query<T> _mapQuery(Query<Map<String, dynamic>> newOriginalQuery) {
    return _WithConverterQuery<T>(
      newOriginalQuery,
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  Future<QuerySnapshot<T>> get([GetOptions? options]) async {
    final snapshot = await _originalQuery.get(options);
    return _WithConverterQuerySnapshot<T>(
      snapshot,
      _fromFirestore,
      _toFirestore,
    );
  }

  @override
  Stream<QuerySnapshot<T>> snapshots({
    bool includeMetadataChanges = false,
    ListenSource source = ListenSource.defaultSource,
  }) {
    return _originalQuery
        .snapshots(
          includeMetadataChanges: includeMetadataChanges,
          source: source,
        )
        .map(
          (snapshot) => _WithConverterQuerySnapshot<T>(
            snapshot,
            _fromFirestore,
            _toFirestore,
          ),
        );
  }

  @override
  Query<T> endAt(Iterable<Object?> values) {
    return _mapQuery(_originalQuery.endAt(values));
  }

  @override
  Query<T> endAtDocument(DocumentSnapshot documentSnapshot) {
    return _mapQuery(_originalQuery.endAtDocument(documentSnapshot));
  }

  @override
  Query<T> endBefore(Iterable<Object?> values) {
    return _mapQuery(_originalQuery.endBefore(values));
  }

  @override
  Query<T> endBeforeDocument(DocumentSnapshot documentSnapshot) {
    return _mapQuery(_originalQuery.endBeforeDocument(documentSnapshot));
  }

  @override
  Query<T> limit(int limit) {
    return _mapQuery(_originalQuery.limit(limit));
  }

  @override
  Query<T> limitToLast(int limit) {
    return _mapQuery(_originalQuery.limitToLast(limit));
  }

  @override
  Query<T> orderBy(Object field, {bool descending = false}) {
    return _mapQuery(_originalQuery.orderBy(field, descending: descending));
  }

  @override
  Query<T> startAfter(Iterable<Object?> values) {
    return _mapQuery(_originalQuery.startAfter(values));
  }

  @override
  Query<T> startAfterDocument(DocumentSnapshot documentSnapshot) {
    return _mapQuery(_originalQuery.startAfterDocument(documentSnapshot));
  }

  @override
  Query<T> startAt(Iterable<Object?> values) {
    return _mapQuery(_originalQuery.startAt(values));
  }

  @override
  Query<T> startAtDocument(DocumentSnapshot documentSnapshot) {
    return _mapQuery(_originalQuery.startAtDocument(documentSnapshot));
  }

  @override
  Query<T> where(
    Object field, {
    Object? isEqualTo,
    Object? isNotEqualTo,
    Object? isLessThan,
    Object? isLessThanOrEqualTo,
    Object? isGreaterThan,
    Object? isGreaterThanOrEqualTo,
    Object? arrayContains,
    Iterable<Object?>? arrayContainsAny,
    Iterable<Object?>? whereIn,
    Iterable<Object?>? whereNotIn,
    bool? isNull,
  }) {
    return _mapQuery(
      _originalQuery.where(
        field,
        isEqualTo: isEqualTo,
        isNotEqualTo: isNotEqualTo,
        isLessThan: isLessThan,
        isLessThanOrEqualTo: isLessThanOrEqualTo,
        isGreaterThan: isGreaterThan,
        isGreaterThanOrEqualTo: isGreaterThanOrEqualTo,
        arrayContains: arrayContains,
        arrayContainsAny: arrayContainsAny,
        whereIn: whereIn,
        whereNotIn: whereNotIn,
        isNull: isNull,
      ),
    );
  }

  @override
  Query<R> withConverter<R extends Object?>({
    required FromFirestore<R> fromFirestore,
    required ToFirestore<R> toFirestore,
  }) {
    return _WithConverterQuery(
      _originalQuery,
      fromFirestore,
      toFirestore,
    );
  }

  @override
  bool operator ==(Object other) {
    return runtimeType == other.runtimeType &&
        other is _WithConverterQuery<T> &&
        other._fromFirestore == _fromFirestore &&
        other._toFirestore == _toFirestore &&
        other._originalQuery == _originalQuery;
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, _fromFirestore, _toFirestore, _originalQuery);

  /// Represents an [AggregateQuery] over the data at a particular location for retrieving metadata
  /// without retrieving the actual documents.
  @override
  AggregateQuery count() {
    return _originalQuery.count();
  }

  /// Calculates the specified aggregations over the documents in the
  /// result set of the given query, without actually downloading the documents.
  @override
  AggregateQuery aggregate(
    AggregateField aggregateField1, [
    AggregateField? aggregateField2,
    AggregateField? aggregateField3,
    AggregateField? aggregateField4,
    AggregateField? aggregateField5,
    AggregateField? aggregateField6,
    AggregateField? aggregateField7,
    AggregateField? aggregateField8,
    AggregateField? aggregateField9,
    AggregateField? aggregateField10,
    AggregateField? aggregateField11,
    AggregateField? aggregateField12,
    AggregateField? aggregateField13,
    AggregateField? aggregateField14,
    AggregateField? aggregateField15,
    AggregateField? aggregateField16,
    AggregateField? aggregateField17,
    AggregateField? aggregateField18,
    AggregateField? aggregateField19,
    AggregateField? aggregateField20,
    AggregateField? aggregateField21,
    AggregateField? aggregateField22,
    AggregateField? aggregateField23,
    AggregateField? aggregateField24,
    AggregateField? aggregateField25,
    AggregateField? aggregateField26,
    AggregateField? aggregateField27,
    AggregateField? aggregateField28,
    AggregateField? aggregateField29,
    AggregateField? aggregateField30,
  ]) {
    return _originalQuery.aggregate(
      aggregateField1,
      aggregateField2,
      aggregateField3,
      aggregateField4,
      aggregateField5,
      aggregateField6,
      aggregateField7,
      aggregateField8,
      aggregateField9,
      aggregateField10,
      aggregateField11,
      aggregateField12,
      aggregateField13,
      aggregateField14,
      aggregateField15,
      aggregateField16,
      aggregateField17,
      aggregateField18,
      aggregateField19,
      aggregateField20,
      aggregateField21,
      aggregateField22,
      aggregateField23,
      aggregateField24,
      aggregateField25,
      aggregateField26,
      aggregateField27,
      aggregateField28,
      aggregateField29,
      aggregateField30,
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\query_document_snapshot.dart =====
// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [QueryDocumentSnapshot] contains data read from a document in your [FirebaseFirestore]
/// database as part of a query.
///
/// A [QueryDocumentSnapshot] offers the same API surface as a [DocumentSnapshot].
/// Since query results contain only existing documents, the exists property
/// will always be `true` and [data()] will never return `null`.
@sealed
abstract class QueryDocumentSnapshot<T extends Object?>
    implements DocumentSnapshot<T> {
  @override
  T data();
}

class _JsonQueryDocumentSnapshot extends _JsonDocumentSnapshot
    implements QueryDocumentSnapshot<Map<String, dynamic>> {
  _JsonQueryDocumentSnapshot(_firestore, _delegate)
      : super(_firestore, _delegate);

  @override
  bool get exists => true;

  @override
  Map<String, dynamic> data() => super.data()!;
}

/// A [QueryDocumentSnapshot] contains data read from a document in your [FirebaseFirestore]
/// database as part of a query.
///
/// A [QueryDocumentSnapshot] offers the same API surface as a [DocumentSnapshot].
/// Since query results contain only existing documents, the exists property
/// will always be `true` and [data()] will never return `null`.
class _WithConverterQueryDocumentSnapshot<T extends Object?>
    extends _WithConverterDocumentSnapshot<T>
    implements QueryDocumentSnapshot<T> {
  _WithConverterQueryDocumentSnapshot(
    QueryDocumentSnapshot<Map<String, dynamic>> originalQueryDocumentSnapshot,
    FromFirestore<T> fromFirestore,
    ToFirestore<T> toFirestore,
  ) : super(
          originalQueryDocumentSnapshot,
          fromFirestore,
          toFirestore,
        );

  @override
  bool get exists => true;

  @override
  T data() => super.data() as T;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\query_snapshot.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// Contains the results of a query.
/// It can contain zero or more [DocumentSnapshot] objects.
abstract class QuerySnapshot<T extends Object?> {
  /// Gets a list of all the documents included in this snapshot.
  List<QueryDocumentSnapshot<T>> get docs;

  /// An array of the documents that changed since the last snapshot. If this
  /// is the first snapshot, all documents will be in the list as Added changes.
  List<DocumentChange<T>> get docChanges;

  /// Returns the [SnapshotMetadata] for this snapshot.
  SnapshotMetadata get metadata;

  /// Returns the size (number of documents) of this snapshot.
  int get size;
}

/// Contains the results of a query.
/// It can contain zero or more [DocumentSnapshot] objects.
class _JsonQuerySnapshot implements QuerySnapshot<Map<String, dynamic>> {
  _JsonQuerySnapshot(this._firestore, this._delegate) {
    QuerySnapshotPlatform.verify(_delegate);
  }

  final FirebaseFirestore _firestore;
  final QuerySnapshotPlatform _delegate;

  @override
  List<QueryDocumentSnapshot<Map<String, dynamic>>> get docs => _delegate.docs
      .map(
        (documentDelegate) =>
            _JsonQueryDocumentSnapshot(_firestore, documentDelegate),
      )
      .toList();

  @override
  List<DocumentChange<Map<String, dynamic>>> get docChanges {
    return _delegate.docChanges.map((documentDelegate) {
      return _JsonDocumentChange(_firestore, documentDelegate);
    }).toList();
  }

  @override
  SnapshotMetadata get metadata => SnapshotMetadata._(_delegate.metadata);

  @override
  int get size => _delegate.size;
}

/// Contains the results of a query.
/// It can contain zero or more [DocumentSnapshot] objects.
class _WithConverterQuerySnapshot<T extends Object?>
    implements QuerySnapshot<T> {
  _WithConverterQuerySnapshot(
    this._originalQuerySnapshot,
    this._fromFirestore,
    this._toFirestore,
  );

  final QuerySnapshot<Map<String, dynamic>> _originalQuerySnapshot;
  final FromFirestore<T> _fromFirestore;
  final ToFirestore<T> _toFirestore;

  @override
  List<QueryDocumentSnapshot<T>> get docs {
    return [
      for (final snapshot in _originalQuerySnapshot.docs)
        _WithConverterQueryDocumentSnapshot<T>(
          snapshot,
          _fromFirestore,
          _toFirestore,
        ),
    ];
  }

  @override
  List<DocumentChange<T>> get docChanges {
    return [
      for (final change in _originalQuerySnapshot.docChanges)
        _WithConverterDocumentChange<T>(
          change,
          _fromFirestore,
          _toFirestore,
        ),
    ];
  }

  @override
  SnapshotMetadata get metadata => _originalQuerySnapshot.metadata;

  @override
  int get size => _originalQuerySnapshot.size;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\snapshot_metadata.dart =====
// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// Metadata about a snapshot, describing the state of the snapshot.
class SnapshotMetadata {
  SnapshotMetadataPlatform _delegate;

  SnapshotMetadata._(this._delegate);

  /// Whether the snapshot contains the result of local writes that have not yet
  /// been committed to the backend.
  ///
  /// If you called [DocumentReference.snapshots] or [Query.snapshots] with
  /// `includeMetadataChanges` parameter set to `true` you will receive another
  /// snapshot with `hasPendingWrites` equal to `false` once the writes have been
  /// committed to the backend.
  bool get hasPendingWrites => _delegate.hasPendingWrites;

  /// Whether the snapshot was created from cached data rather than guaranteed
  /// up-to-date server data.
  ///
  /// If you called [DocumentReference.snapshots] or [Query.snapshots] with
  /// `includeMetadataChanges` parameter set to `true` you will receive another
  /// snapshot with `isFromCache` equal to `false` once the client has received
  /// up-to-date data from the backend.
  bool get isFromCache => _delegate.isFromCache;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\transaction.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// The [TransactionHandler] may be executed multiple times; it should be able
/// to handle multiple executions.
typedef TransactionHandler<T> = Future<T> Function(Transaction transaction);

/// Transaction class which is created from a call to [runTransaction()].
class Transaction {
  final FirebaseFirestore _firestore;
  final TransactionPlatform _delegate;

  Transaction._(this._firestore, this._delegate) {
    TransactionPlatform.verify(_delegate);
  }

  /// Reads the document referenced by the provided [DocumentReference].
  ///
  /// If the document changes whilst the transaction is in progress, it will
  /// be re-tried up to five times.
  Future<DocumentSnapshot<T>> get<T extends Object?>(
    DocumentReference<T> documentReference,
  ) async {
    DocumentSnapshotPlatform documentSnapshotPlatform =
        await _delegate.get(documentReference.path);

    final snapshot =
        _JsonDocumentSnapshot(_firestore, documentSnapshotPlatform);

    if (snapshot is DocumentSnapshot<T>) {
      return snapshot as DocumentSnapshot<T>;
    }

    final withConverterDocRef =
        documentReference as _WithConverterDocumentReference<T>;

    return _WithConverterDocumentSnapshot<T>(
      snapshot,
      withConverterDocRef._fromFirestore,
      withConverterDocRef._toFirestore,
    );
  }

  /// Deletes the document referred to by the provided [documentReference].
  Transaction delete(DocumentReference documentReference) {
    assert(
      documentReference.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );

    return Transaction._(
      _firestore,
      _delegate.delete(documentReference.path),
    );
  }

  /// Updates fields in the document referred to by [documentReference].
  /// The update will fail if applied to a document that does not exist.
  Transaction update(
    DocumentReference documentReference,
    Map<String, dynamic> data,
  ) {
    assert(
      documentReference.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );

    return Transaction._(
      _firestore,
      _delegate.update(
        documentReference.path,
        _CodecUtility.replaceValueWithDelegatesInMap(data)!,
      ),
    );
  }

  /// Writes to the document referred to by the provided [DocumentReference].
  /// If the document does not exist yet, it will be created. If you pass
  /// [SetOptions], the provided data can be merged into the existing document.
  Transaction set<T>(
    DocumentReference<T> documentReference,
    T data, [
    SetOptions? options,
  ]) {
    assert(
      documentReference.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );

    Map<String, dynamic> firestoreData;
    if (documentReference is _JsonDocumentReference) {
      firestoreData = data as Map<String, dynamic>;
    } else {
      final withConverterDoc =
          documentReference as _WithConverterDocumentReference<T>;
      firestoreData = withConverterDoc._toFirestore(data, options);
    }

    return Transaction._(
      _firestore,
      _delegate.set(
        documentReference.path,
        _CodecUtility.replaceValueWithDelegatesInMap(firestoreData)!,
        options,
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\src\write_batch.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../cloud_firestore.dart';

/// A [WriteBatch] is a series of write operations to be performed as one unit.
///
/// Operations done on a [WriteBatch] do not take effect until you [commit()].
///
/// Once committed, no further operations can be performed on the [WriteBatch],
/// nor can it be committed again.
class WriteBatch {
  WriteBatch._(this._firestore, this._delegate) {
    WriteBatchPlatform.verify(_delegate);
  }

  final FirebaseFirestore _firestore;
  final WriteBatchPlatform _delegate;

  /// Commits all of the writes in this write batch as a single atomic unit.
  ///
  /// Calling this method prevents any future operations from being added.
  Future<void> commit() => _delegate.commit();

  /// Deletes the document referred to by [document].
  void delete(DocumentReference document) {
    assert(
      document.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );
    return _delegate.delete(document.path);
  }

  /// Writes to the document referred to by [document].
  ///
  /// If the document does not yet exist, it will be created.
  ///
  /// If [SetOptions] are provided, the data will be merged into an existing
  /// document instead of overwriting.
  void set<T>(
    DocumentReference<T> document,
    T data, [
    SetOptions? options,
  ]) {
    assert(
      document.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );

    Map<String, dynamic> firestoreData;
    if (document is _JsonDocumentReference) {
      firestoreData = data as Map<String, dynamic>;
    } else {
      final withConverterDoc = document as _WithConverterDocumentReference<T>;
      firestoreData = withConverterDoc._toFirestore(data, options);
    }

    return _delegate.set(
      document.path,
      _CodecUtility.replaceValueWithDelegatesInMap(firestoreData)!,
      options,
    );
  }

  /// Updates a given [document].
  ///
  /// If the document does not yet exist, an exception will be thrown.
  void update(DocumentReference document, Map<String, dynamic> data) {
    assert(
      document.firestore == _firestore,
      'the document provided is from a different Firestore instance',
    );
    return _delegate.update(
      document.path,
      _CodecUtility.replaceValueWithDelegatesInMap(data)!,
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\lib\cloud_firestore.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore_platform_interface/cloud_firestore_platform_interface.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebasePluginPlatform;
import 'package:flutter/foundation.dart';
import 'package:meta/meta.dart';

export 'package:cloud_firestore_platform_interface/cloud_firestore_platform_interface.dart'
    show
        AggregateField,
        AggregateSource,
        ListEquality,
        FieldPath,
        Blob,
        GeoPoint,
        VectorValue,
        Timestamp,
        Source,
        GetOptions,
        ServerTimestampBehavior,
        SetOptions,
        ListenSource,
        DocumentChangeType,
        PersistenceSettings,
        Settings,
        WebExperimentalLongPollingOptions,
        IndexField,
        Index,
        FieldOverrides,
        FieldOverrideIndex,
        Order,
        ArrayConfig,
        QueryScope,
        LoadBundleTaskState,
        average,
        count,
        sum;
export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseException;

part 'src/aggregate_query.dart';
part 'src/aggregate_query_snapshot.dart';
part 'src/collection_reference.dart';
part 'src/document_change.dart';
part 'src/document_reference.dart';
part 'src/document_snapshot.dart';
part 'src/field_value.dart';
part 'src/filters.dart';
part 'src/firestore.dart';
part 'src/load_bundle_task.dart';
part 'src/load_bundle_task_snapshot.dart';
part 'src/persistent_cache_index_manager.dart';
part 'src/query.dart';
part 'src/query_document_snapshot.dart';
part 'src/query_snapshot.dart';
part 'src/snapshot_metadata.dart';
part 'src/transaction.dart';
part 'src/utils/codec_utility.dart';
part 'src/write_batch.dart';
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\test\cloud_firestore_test.dart =====
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';

import './mock.dart';

void main() {
  setupCloudFirestoreMocks();
  FirebaseFirestore? firestore;
  FirebaseFirestore? firestoreSecondary;
  FirebaseApp? secondaryApp;

  group('$FirebaseFirestore', () {
    setUpAll(() async {
      await Firebase.initializeApp();
      secondaryApp = await Firebase.initializeApp(
        name: 'foo',
        options: const FirebaseOptions(
          apiKey: '123',
          appId: '123',
          messagingSenderId: '123',
          projectId: '123',
        ),
      );

      firestore = FirebaseFirestore.instance;
      firestoreSecondary = FirebaseFirestore.instanceFor(app: secondaryApp!);
    });

    test('equality', () {
      expect(firestore, equals(FirebaseFirestore.instance));
      expect(firestore.hashCode, firestore.hashCode);
      expect(
        firestoreSecondary,
        equals(FirebaseFirestore.instanceFor(app: secondaryApp!)),
      );
    });

    test('databaseId', () {
      final firestore = FirebaseFirestore.instanceFor(
        app: Firebase.app(),
        databaseId: 'foo',
      );

      expect(firestore.databaseId, equals('foo'));

      final firestore2 =
          FirebaseFirestore.instanceFor(app: Firebase.app(), databaseId: 'bar');

      expect(firestore2.databaseId, equals('bar'));

      final firestore3 = FirebaseFirestore.instanceFor(
        app: Firebase.app(),
        databaseId: 'fire',
      );

      expect(firestore3.databaseId, equals('fire'));
    });

    test('returns the correct $FirebaseApp', () {
      expect(firestore!.app, equals(Firebase.app()));
      expect(firestoreSecondary!.app, equals(Firebase.app('foo')));
    });

    group('.collection', () {
      test('returns a $CollectionReference', () {
        expect(firestore!.collection('foo'), isA<CollectionReference>());
      });

      test('does not expect an empty path', () {
        expect(() => firestore!.collection(''), throwsArgumentError);
      });

      test('does accept an invalid path', () {
        // 'foo/bar' points to a document
        expect(() => firestore!.collection('foo/bar'), throwsArgumentError);
      });
    });

    group('.collectionGroup', () {
      test('returns a $Query', () {
        expect(firestore!.collectionGroup('foo'), isA<Query>());
      });

      test('does not expect an empty path', () {
        expect(() => firestore!.collectionGroup(''), throwsArgumentError);
      });

      test('does accept a path containing "/"', () {
        expect(
          () => firestore!.collectionGroup('foo/bar/baz'),
          throwsArgumentError,
        );
      });
    });

    group('.document', () {
      test('returns a $DocumentReference', () {
        expect(firestore!.doc('foo/bar'), isA<DocumentReference>());
      });

      test('does not expect an empty path', () {
        expect(() => firestore!.doc(''), throwsArgumentError);
      });

      test('does accept an invalid path', () {
        // 'foo' points to a collection
        expect(() => firestore!.doc('bar'), throwsArgumentError);
      });
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\test\collection_reference_test.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';

import './mock.dart';

void main() {
  setupCloudFirestoreMocks();
  late FirebaseFirestore firestore;
  late FirebaseFirestore firestoreSecondary;

  group('$CollectionReference', () {
    setUpAll(() async {
      await Firebase.initializeApp();
      FirebaseApp secondaryApp = await Firebase.initializeApp(
        name: 'foo',
        options: const FirebaseOptions(
          apiKey: '123',
          appId: '123',
          messagingSenderId: '123',
          projectId: '123',
        ),
      );

      firestore = FirebaseFirestore.instance;
      firestoreSecondary = FirebaseFirestore.instanceFor(app: secondaryApp);
    });

    test('extends $Query', () {
      // The `firestore` property is publicly accessible via Query.
      // Is there a better way to test this?
      CollectionReference ref = firestore.collection('foo');

      expect(ref.firestore, equals(firestore));
    });

    test('toString', () async {
      expect(
        firestore.collection('foo').toString(),
        'CollectionReference<Map<String, dynamic>>(foo)',
      );
    });

    test('equality', () {
      CollectionReference ref = firestore.collection('foo');
      CollectionReference ref2 = firestoreSecondary.collection('foo');
      CollectionReference ref3 = firestore.collection('bar');

      expect(ref == firestore.collection('foo'), isTrue);
      expect(ref2 == firestoreSecondary.collection('foo'), isTrue);
      expect(ref3 == ref, isFalse);

      DocumentReference docRef = firestore.collection('foo').doc('bar');
      DocumentReference docRef2 =
          firestoreSecondary.collection('foo').doc('bar');

      expect(docRef, firestore.collection('foo').doc('bar'));
      expect(docRef2, firestoreSecondary.collection('foo').doc('bar'));
      expect(docRef == docRef2, isFalse);
    });

    test('returns the correct id', () {
      CollectionReference ref = firestore.collection('foo');
      CollectionReference ref2 = firestore.collection('foo/bar/baz');

      expect(ref.id, equals('foo'));
      expect(ref2.id, equals('baz'));
    });

    test('returns the correct parent', () {
      CollectionReference ref = firestore.collection('foo');
      CollectionReference ref2 = firestore.collection('foo/bar/baz');

      expect(ref.parent, isNull);
      expect(ref2.parent, isA<DocumentReference>());

      DocumentReference docRef = firestore.doc('foo/bar');
      expect(ref2.parent, equals(docRef));
    });

    test('returns the correct path', () {
      CollectionReference ref = firestore.collection('foo');
      CollectionReference ref2 = firestore.collection('foo/bar/baz');

      expect(ref.path, equals('foo'));
      expect(ref2.path, equals('foo/bar/baz'));
    });

    test('doc() returns the correct $DocumentReference', () {
      CollectionReference ref = firestore.collection('foo');

      expect(ref.doc('bar'), firestore.doc('foo/bar'));
    });

    test('path must be non-empty strings', () {
      DocumentReference docRef = firestore.doc('foo/bar');
      expect(() => firestore.collection(''), throwsArgumentError);
      expect(() => docRef.collection(''), throwsArgumentError);
    });

    test('path must be odd length', () {
      DocumentReference docRef = firestore.doc('foo/bar');
      expect(() => firestore.collection('foo/bar'), throwsArgumentError);
      expect(
        () => firestore.collection('foo/bar/baz/quu'),
        throwsArgumentError,
      );
      expect(() => docRef.collection('foo/bar'), throwsArgumentError);
      expect(() => docRef.collection('foo/bar/baz/quu'), throwsArgumentError);
    });

    test('must not have empty segments', () {
      // NOTE: Leading / trailing slashes are okay.
      firestore.collection('/foo/');
      firestore.collection('/foo');
      firestore.collection('foo/');

      const badPaths = ['foo//bar//baz', '//foo', 'foo//'];
      CollectionReference colRef = firestore.collection('test-collection');
      DocumentReference docRef = colRef.doc('test-document');

      for (final path in badPaths) {
        expect(() => firestore.collection(path), throwsArgumentError);
        expect(() => firestore.doc(path), throwsArgumentError);
        expect(() => colRef.doc(path), throwsArgumentError);
        expect(() => docRef.collection(path), throwsArgumentError);
      }
    });

    group('validate', () {
      test('path must be non-empty strings', () {
        DocumentReference docRef = firestore.doc('foo/bar');
        expect(() => firestore.collection(''), throwsArgumentError);
        expect(() => docRef.collection(''), throwsArgumentError);
      });

      test('path must be odd length', () {
        DocumentReference docRef = firestore.doc('foo/bar');
        expect(() => firestore.collection('foo/bar'), throwsArgumentError);
        expect(
          () => firestore.collection('foo/bar/baz/quu'),
          throwsArgumentError,
        );
        expect(() => docRef.collection('foo/bar'), throwsArgumentError);
        expect(
          () => docRef.collection('foo/bar/baz/quu'),
          throwsArgumentError,
        );
      });

      test('must not have empty segments', () {
        // NOTE: Leading / trailing slashes are okay.
        firestore.collection('/foo/');
        firestore.collection('/foo');
        firestore.collection('foo/');

        final badPaths = ['foo//bar//baz', '//foo', 'foo//'];
        CollectionReference colRef = firestore.collection('test-collection');
        DocumentReference docRef = colRef.doc('test-document');

        for (final String path in badPaths) {
          expect(() => firestore.collection(path), throwsArgumentError);
          expect(() => firestore.doc(path), throwsArgumentError);
          expect(() => colRef.doc(path), throwsArgumentError);
          expect(() => docRef.collection(path), throwsArgumentError);
        }
      });
    });

    group('withConverter', () {
      test('implements ==', () {
        int fromFirestore(
          DocumentSnapshot snapshot,
          SnapshotOptions? options,
        ) =>
            42;
        Map<String, dynamic> toFirestore(Object value, SetOptions? options) =>
            {};

        final foo = firestore.collection('foo');
        final bar = firestore.collection('bar');

        final intFoo = foo.withConverter<int>(
          fromFirestore: fromFirestore,
          toFirestore: toFirestore,
        );

        // utilities to check == in both directions as it is possible that
        // a == b is true but b == a is false since the former invoke a's == operator
        // while the latter invoke b's == operator
        void expectEqual(Object? a, Object? b) {
          expect(a, b);
          expect(b, a);
        }

        void expectNotEqual(Object? a, Object? b) {
          expect(a, isNot(b));
          expect(b, isNot(a));
        }

        expectEqual(
          foo.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          intFoo,
        );

        expectNotEqual(
          bar.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          intFoo,
        );

        expectNotEqual(
          foo.withConverter<Object>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          intFoo,
        );

        expectNotEqual(
          foo.withConverter<int>(
            fromFirestore: (_, __) => 42,
            toFirestore: toFirestore,
          ),
          intFoo,
        );

        expectNotEqual(
          foo.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: (_, __) => {},
          ),
          intFoo,
        );
      });

      test('toString', () {
        final foo = firestore.collection('foo');

        expect(
          foo
              .withConverter<int>(
                fromFirestore: (map, _) => 42,
                toFirestore: (value, _) => {},
              )
              .toString(),
          'CollectionReference<int>(foo)',
        );

        expect(
          foo
              .withConverter<double>(
                fromFirestore: (map, _) => 42,
                toFirestore: (value, _) => {},
              )
              .toString(),
          'CollectionReference<double>(foo)',
        );
      });

      test('id', () {
        final foo = firestore.collection('foo');

        expect(
          foo
              .withConverter(
                fromFirestore: (_, __) => 42,
                toFirestore: (_, __) => {},
              )
              .id,
          foo.id,
        );
      });

      test('path', () {
        final subCollection =
            firestore.collection('foo').doc('42').collection('bar');

        expect(
          subCollection
              .withConverter(
                fromFirestore: (_, __) => 42,
                toFirestore: (_, __) => {},
              )
              .path,
          subCollection.path,
        );
      });

      test('parent', () {
        final subCollection =
            firestore.collection('foo').doc('42').collection('bar');

        expect(
          subCollection
              .withConverter(
                fromFirestore: (_, __) => 42,
                toFirestore: (_, __) => {},
              )
              .parent,
          subCollection.parent,
        );
      });

      test('doc', () {
        final foo = firestore.collection('foo');

        int fromFirestore(
          DocumentSnapshot snapshot,
          SnapshotOptions? options,
        ) =>
            42;
        Map<String, dynamic> toFirestore(Object value, SetOptions? options) =>
            {};

        expect(
          foo
              .withConverter(
                fromFirestore: fromFirestore,
                toFirestore: toFirestore,
              )
              .doc('42'),
          foo.doc('42').withConverter(
                fromFirestore: fromFirestore,
                toFirestore: toFirestore,
              ),
        );
      });
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\test\field_value_test.dart =====
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('$FieldValue', () {
    test('equality', () {
      expect(FieldValue.delete() == FieldValue.delete(), isTrue);
      expect(
        FieldValue.serverTimestamp() == FieldValue.serverTimestamp(),
        isTrue,
      );
      expect(FieldValue.delete() == FieldValue.serverTimestamp(), isFalse);
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\test\mock.dart =====
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core_platform_interface/test.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

typedef Callback = void Function(MethodCall call);

void setupCloudFirestoreMocks([Callback? customHandlers]) {
  TestWidgetsFlutterBinding.ensureInitialized();

  setupFirebaseCoreMocks();
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\test\query_test.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';

import './mock.dart';

void main() {
  setupCloudFirestoreMocks();
  late FirebaseFirestore firestore;
  Query? query;

  group('$Query', () {
    setUpAll(() async {
      await Firebase.initializeApp();
      // secondary app
      await Firebase.initializeApp(
        name: 'foo',
        options: const FirebaseOptions(
          apiKey: '123',
          appId: '123',
          messagingSenderId: '123',
          projectId: '123',
        ),
      );

      firestore = FirebaseFirestore.instance;
    });

    setUp(() {
      // Reset the query before each test
      query = firestore.collection('foo');
    });

    test('.limit() throws if limit is negative', () {
      expect(() => query!.limit(0), throwsAssertionError);
      expect(() => query!.limitToLast(-1), throwsAssertionError);
    });

    group('.where()', () {
      test('throws if field is invalid', () {
        expect(() => query!.where(123), throwsAssertionError);
      });

      test('allows multiple inequalities on different paths is provided', () {
        query!
            .where('foo.bar', isGreaterThanOrEqualTo: 123)
            .where('bar', isLessThan: 123);
      });

      test('allows inequality on the same path', () {
        query!
            .where('foo.bar', isGreaterThan: 123)
            .where('foo.bar', isGreaterThan: 1234);
      });

      test('throw an exception when making query combining `in` & `not-in`',
          () {
        expect(
          () => query!.where('number', whereIn: [1, 2], whereNotIn: [3, 4]),
          throwsAssertionError,
        );

        expect(
          () => query!.where('number', whereIn: [1, 2]).where(
            'number',
            whereNotIn: [3, 4],
          ),
          throwsAssertionError,
        );

        expect(
          () => query!.where('number', whereNotIn: [3, 4]).where(
            'number',
            whereIn: [1, 2],
          ),
          throwsAssertionError,
        );
      });

      test('allows inequality  different to first orderBy', () {
        query!.where('foo', isGreaterThan: 123).orderBy('bar');
        query!.orderBy('bar').where('foo', isGreaterThan: 123);
        query!.where('foo', isGreaterThan: 123).orderBy('bar').orderBy('foo');
        query!.orderBy('bar').orderBy('foo').where('foo', isGreaterThan: 123);
        query!.where(FieldPath.documentId, whereNotIn: ['bar']).orderBy('foo');
        query!.where(FieldPath.documentId, isLessThan: 3).orderBy('foo');
        query!.where(FieldPath.documentId, isGreaterThan: 3).orderBy('foo');
        query!.where('foo', whereNotIn: ['bar']).orderBy('baz');
        query!.where('foo', isLessThan: 3).orderBy('bar');
        query!.where('foo', isGreaterThan: 3).orderBy('bar');
      });

      test('throws if whereIn query length is greater than 30', () {
        List<int> numbers = List.generate(31, (i) => i + 1);
        expect(
          () => query!.where('foo.bar', whereIn: numbers),
          throwsAssertionError,
        );
      });

      test('throws if arrayContainsAny query length is greater than 30', () {
        List<int> numbers = List.generate(31, (i) => i + 1);
        expect(
          () => query!.where(
            'foo',
            arrayContainsAny: numbers,
          ),
          throwsAssertionError,
        );
      });

      test('throws if whereNotIn query length is greater than 10', () {
        expect(
          () => query!.where(
            'foo',
            whereNotIn: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          ),
          throwsAssertionError,
        );
      });

      test('throws if empty array used for whereIn filters', () {
        expect(() => query!.where('foo', whereIn: []), throwsAssertionError);
      });

      test('throws if empty array used for arrayContainsAny filters', () {
        expect(
          () => query!.where('foo', arrayContainsAny: []),
          throwsAssertionError,
        );
      });

      test('throws if multiple array filters in query', () {
        expect(
          () => query!
              .where('foo.bar', arrayContains: 1)
              .where('foo.bar', arrayContains: 2),
          throwsAssertionError,
        );
        expect(
          () => query!
              .where('foo.bar', arrayContains: 1)
              .where('foo.bar', arrayContainsAny: [2, 3]),
          throwsAssertionError,
        );
        expect(
          () => query!.where(
            'foo.bar',
            arrayContainsAny: [1, 2],
          ).where('foo.bar', arrayContains: 3),
          throwsAssertionError,
        );
      });

      test('throws if multiple disjunctive filters in query', () {
        expect(
          () => query!.where('foo', arrayContainsAny: [1]).where(
            'foo',
            arrayContainsAny: [2, 3],
          ),
          throwsAssertionError,
        );
        expect(
          () => query!
              .where('foo', whereIn: [2, 3])
              .where('foo', arrayContains: 1)
              .where('foo', arrayContainsAny: [2]),
          throwsAssertionError,
        );
        expect(
          () => query!.where('foo', arrayContains: 1).where(
            'foo',
            whereIn: [2, 3],
          ).where('foo', arrayContainsAny: [2]),
          throwsAssertionError,
        );
      });

      test(
          'throws if FieldPath.documentId field is used in conjunction with isNotEqualTo filter',
          () {
        expect(
          () => query!
              .where(FieldPath.documentId, isEqualTo: 'fake-id')
              .where('foo', isNotEqualTo: 'bar'),
          throwsAssertionError,
        );

        expect(
          () => query!
              .where('foo', isNotEqualTo: 'bar')
              .where(FieldPath.documentId, whereIn: [2, 3]),
          throwsAssertionError,
        );
      });

      test(
          'allow isNotEqualTo filter on FieldPath.documentId field & a different field on a separate filter',
          () {
        query!
            .where(FieldPath.documentId, isNotEqualTo: 'fake-id')
            .where(FieldPath.documentId, isEqualTo: 'another-fake-id')
            .where('foo', isNull: true);
      });

      test('allows arrayContains with whereIn filter', () {
        query!.where('foo', arrayContains: 1).where('foo', whereIn: [2, 3]);
        query!.where('foo', whereIn: [2, 3]).where('foo', arrayContains: 1);
        // cannot use more than one 'array-contains' or 'whereIn' filter
        expect(
          () => query!
              .where('foo', whereIn: [2, 3])
              .where('foo', arrayContains: 1)
              .where('foo', arrayContains: 2),
          throwsAssertionError,
        );
      });
    });

    group('cursor queries', () {
      test('throws if starting or ending point specified after orderBy', () {
        Query q = query!.orderBy('foo');
        expect(() => q.startAt([1]).orderBy('bar'), throwsAssertionError);
        expect(() => q.startAfter([1]).orderBy('bar'), throwsAssertionError);
        expect(() => q.endAt([1]).orderBy('bar'), throwsAssertionError);
        expect(() => q.endBefore([1]).orderBy('bar'), throwsAssertionError);
      });

      test('throws if inconsistent arguments number', () {
        expect(
          () => query!.orderBy('foo').startAt(['bar', 'baz']),
          throwsAssertionError,
        );
        expect(
          () => query!.orderBy('foo').startAfter(['bar', 'baz']),
          throwsAssertionError,
        );
        expect(
          () => query!.orderBy('foo').endAt(['bar', 'baz']),
          throwsAssertionError,
        );
        expect(
          () => query!.orderBy('foo').endBefore(['bar', 'baz']),
          throwsAssertionError,
        );
      });

      test('throws if fields are not a String or FieldPath', () {
        expect(() => query!.endAt([123, {}]), throwsAssertionError);
        expect(() => query!.startAt(['123', []]), throwsAssertionError);
        expect(() => query!.endBefore([true]), throwsAssertionError);
        expect(() => query!.startAfter([false]), throwsAssertionError);
      });

      test('throws if fields is greater than the number of orders', () {
        expect(() => query!.endAt(['123']), throwsAssertionError);
        expect(
          () => query!.startAt([
            FieldPath(const ['123']),
          ]),
          throwsAssertionError,
        );
      });

      test('endAt() replaces all end parameters', () {
        Query q = query!.orderBy('foo').endBefore(['123']);
        expect(q.parameters['endBefore'], equals(['123']));
        q = q.endAt(['456']);
        expect(q.parameters['endBefore'], isNull);
        expect(q.parameters['endAt'], equals(['456']));
      });
    });

    group('withConverter', () {
      test('overrides ==', () {
        final query = firestore.collection('/movies').limit(42);
        final query2 = firestore.collection('/movies').limit(21);

        int fromFirestore(Object? snapshot, Object? options) => 42;
        Map<String, Object?> toFirestore(Object? value, Object? options) => {};
        Map<String, Object?> intToFirestore(int value, Object? options) => {};

        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: intToFirestore,
          ),
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: intToFirestore,
          ),
        );

        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
        );
        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query.withConverter<Object?>(
              fromFirestore: fromFirestore,
              toFirestore: toFirestore,
            ),
          ),
        );
        expect(
          query.withConverter<Object?>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query.withConverter<int>(
              fromFirestore: fromFirestore,
              toFirestore: toFirestore,
            ),
          ),
        );
        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query2.withConverter<int>(
              fromFirestore: fromFirestore,
              toFirestore: toFirestore,
            ),
          ),
        );
        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query.withConverter<int>(
              fromFirestore: (_, __) => 21,
              toFirestore: toFirestore,
            ),
          ),
        );
        expect(
          query.withConverter<int>(
            fromFirestore: fromFirestore,
            toFirestore: toFirestore,
          ),
          isNot(
            query.withConverter<int>(
              fromFirestore: fromFirestore,
              toFirestore: (_, __) => {},
            ),
          ),
        );
      });
    });

    group('Settings()', () {
      test('Test the assert for setting `cacheSizeBytes` minimum and maximum',
          () {
        void configureCache(int? cacheSizeBytes) {
          assert(
            cacheSizeBytes == null ||
                cacheSizeBytes == Settings.CACHE_SIZE_UNLIMITED ||
                (cacheSizeBytes >= 1048576 && cacheSizeBytes <= 104857600),
            'Cache size, if specified, must be either CACHE_SIZE_UNLIMITED or between 1048576 bytes (inclusive) and 104857600 bytes (inclusive).',
          );
        }

        // Happy paths
        expect(() => configureCache(null), returnsNormally);
        expect(
          () => configureCache(Settings.CACHE_SIZE_UNLIMITED),
          returnsNormally,
        );
        expect(() => configureCache(5000000), returnsNormally);
        expect(() => configureCache(1048577), returnsNormally);
        expect(() => configureCache(104857600), returnsNormally);
        expect(() => configureCache(104857500), returnsNormally);

        // Assertion triggers
        expect(() => configureCache(1), throwsA(isA<AssertionError>()));
        expect(() => configureCache(1000), throwsA(isA<AssertionError>()));
        expect(() => configureCache(200000000), throwsA(isA<AssertionError>()));
        expect(() => configureCache(500000), throwsA(isA<AssertionError>()));
      });
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\test\test_firestore_message_codec.dart =====
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:cloud_firestore_platform_interface/cloud_firestore_platform_interface.dart';
import 'package:cloud_firestore_platform_interface/src/method_channel/method_channel_firestore.dart';
import 'package:cloud_firestore_platform_interface/src/method_channel/method_channel_query.dart';
import 'package:cloud_firestore_platform_interface/src/method_channel/utils/firestore_message_codec.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';

/// This codec is able to decode FieldValues.
/// This ability is only required in tests, hence why
/// those values are only decoded in tests.
class TestFirestoreMessageCodec extends FirestoreMessageCodec {
  /// Constructor.
  const TestFirestoreMessageCodec();
  static const int _kDocumentReference = 130;
  static const int _kArrayUnion = 132;
  static const int _kArrayRemove = 133;
  static const int _kDelete = 134;
  static const int _kServerTimestamp = 135;
  static const int _kFirestoreInstance = 144;
  static const int _kFirestoreQuery = 145;
  static const int _kFirestoreSettings = 146;

  static const int _kIncrementDouble = 137;
  static const int _kIncrementInteger = 138;

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      // The following cases are only used by unit tests, and not by actual application
      // code paths.
      case _kArrayUnion:
        final List<dynamic> value = readValue(buffer)! as List<dynamic>;
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.arrayUnion(value),
        );
      case _kArrayRemove:
        final List<dynamic> value = readValue(buffer)! as List<dynamic>;
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.arrayRemove(value),
        );
      case _kDelete:
        return FieldValuePlatform(FieldValueFactoryPlatform.instance.delete());
      case _kServerTimestamp:
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.serverTimestamp(),
        );
      case _kIncrementDouble:
        final double value = readValue(buffer)! as double;
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.increment(value),
        );
      case _kIncrementInteger:
        final int value = readValue(buffer)! as int;
        return FieldValuePlatform(
          FieldValueFactoryPlatform.instance.increment(value),
        );
      case _kFirestoreInstance:
        String appName = readValue(buffer)! as String;
        String databaseId = readValue(buffer)! as String;
        readValue(buffer);
        final FirebaseApp app = Firebase.app(appName);
        return MethodChannelFirebaseFirestore(
          app: app,
          databaseId: databaseId,
        );
      case _kFirestoreQuery:
        String appName = readValue(buffer)! as String;
        Map<dynamic, dynamic> values =
            readValue(buffer)! as Map<dynamic, dynamic>;
        final FirebaseApp app = Firebase.app(appName);
        return MethodChannelQuery(
          MethodChannelFirebaseFirestore(app: app, databaseId: '(default)'),
          values['path'],
          FirestorePigeonFirebaseApp(
            appName: "['DEFAULT']",
            settings: PigeonFirebaseSettings(ignoreUndefinedProperties: true),
            databaseURL: '',
          ),
        );
      case _kFirestoreSettings:
        readValue(buffer);
        return const Settings();
      case _kDocumentReference:
        MethodChannelFirebaseFirestore firestore =
            readValue(buffer)! as MethodChannelFirebaseFirestore;
        String path = readValue(buffer)! as String;
        return firestore.doc(path);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\cloud_firestore\pubspec.yaml =====
name: cloud_firestore
description:
  Flutter plugin for Cloud Firestore, a cloud-hosted, noSQL database with
  live synchronization and offline support on Android and iOS.
homepage: https://firebase.google.com/docs/firestore
repository: https://github.com/firebase/flutterfire/tree/main/packages/cloud_firestore/cloud_firestore
version: 6.0.3
topics:
  - firebase
  - firestore
  - realtime
  - database

false_secrets:
  - example/**
  - dartpad/**

environment:
  sdk: '>=3.2.0 <4.0.0'
  flutter: '>=3.3.0'

dependencies:
  cloud_firestore_platform_interface: ^7.0.3
  cloud_firestore_web: ^5.0.3
  collection: ^1.0.0
  firebase_core: ^4.2.0
  firebase_core_platform_interface: ^6.0.2
  flutter:
    sdk: flutter
  meta: ^1.8.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  mockito: ^5.0.0

flutter:
  plugin:
    platforms:
      android:
        package: io.flutter.plugins.firebase.firestore
        pluginClass: FlutterFirebaseFirestorePlugin
      ios:
        pluginClass: FLTFirebaseFirestorePlugin
      macos:
        pluginClass: FLTFirebaseFirestorePlugin
      web:
        default_package: cloud_firestore_web
      windows:
        pluginClass: CloudFirestorePluginCApi

===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\get_directory_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a directory using `getDirectoryPath`,
///  then displays the selected directory in a dialog.
class GetDirectoryPage extends StatelessWidget {
  /// Default Constructor
  const GetDirectoryPage({super.key});

  Future<void> _getDirectoryPath(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final String? directoryPath =
        await FileSelectorPlatform.instance.getDirectoryPath(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPath == null) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(directoryPath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to ask user to choose a directory'),
              onPressed: () => _getDirectoryPath(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPath, {super.key});

  /// The path selected in the dialog.
  final String directoryPath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directory'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPath),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\get_multiple_directories_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select one or more directories using `getDirectoryPaths`,
/// then displays the selected directories in a dialog.
class GetMultipleDirectoriesPage extends StatelessWidget {
  /// Default Constructor
  const GetMultipleDirectoriesPage({super.key});

  Future<void> _getDirectoryPaths(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final List<String?> directoriesPaths =
        await FileSelectorPlatform.instance.getDirectoryPaths(
      confirmButtonText: confirmButtonText,
    );
    if (directoriesPaths.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) =>
            TextDisplay(directoriesPaths.join('\n')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Select multiple directories'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text(
                  'Press to ask user to choose multiple directories'),
              onPressed: () => _getDirectoryPaths(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPaths, {super.key});

  /// The paths selected in the dialog.
  final String directoryPaths;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directories'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPaths),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\home_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Home Page of the application.
class HomePage extends StatelessWidget {
  /// Default Constructor
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final ButtonStyle style = ElevatedButton.styleFrom(
      backgroundColor: Colors.blue,
      foregroundColor: Colors.white,
    );
    return Scaffold(
      appBar: AppBar(
        title: const Text('File Selector Demo Home Page'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: style,
              child: const Text('Open a text file'),
              onPressed: () => Navigator.pushNamed(context, '/open/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open an image'),
              onPressed: () => Navigator.pushNamed(context, '/open/image'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open multiple images'),
              onPressed: () => Navigator.pushNamed(context, '/open/images'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Save a file'),
              onPressed: () => Navigator.pushNamed(context, '/save/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directory dialog'),
              onPressed: () => Navigator.pushNamed(context, '/directory'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directories dialog'),
              onPressed: () =>
                  Navigator.pushNamed(context, '/multi-directories'),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

import 'get_directory_page.dart';
import 'get_multiple_directories_page.dart';
import 'home_page.dart';
import 'open_image_page.dart';
import 'open_multiple_images_page.dart';
import 'open_text_page.dart';
import 'save_text_page.dart';

void main() {
  runApp(const MyApp());
}

/// MyApp is the Main Application.
class MyApp extends StatelessWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'File Selector Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: const HomePage(),
      routes: <String, WidgetBuilder>{
        '/open/image': (BuildContext context) => const OpenImagePage(),
        '/open/images': (BuildContext context) =>
            const OpenMultipleImagesPage(),
        '/open/text': (BuildContext context) => const OpenTextPage(),
        '/save/text': (BuildContext context) => SaveTextPage(),
        '/directory': (BuildContext context) => const GetDirectoryPage(),
        '/multi-directories': (BuildContext context) =>
            const GetMultipleDirectoriesPage()
      },
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\open_image_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select an image file using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenImagePage extends StatelessWidget {
  /// Default Constructor
  const OpenImagePage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'images',
      extensions: <String>['jpg', 'png'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String filePath = file.path;

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => ImageDisplay(fileName, filePath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open an image'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open an image file(png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays an image in a dialog.
class ImageDisplay extends StatelessWidget {
  /// Default Constructor.
  const ImageDisplay(this.fileName, this.filePath, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The path to the selected file.
  final String filePath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: kIsWeb ? Image.network(filePath) : Image.file(File(filePath)),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\open_multiple_images_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select multiple image files using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenMultipleImagesPage extends StatelessWidget {
  /// Default Constructor
  const OpenMultipleImagesPage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup jpgsTypeGroup = XTypeGroup(
      label: 'JPEGs',
      extensions: <String>['jpg', 'jpeg'],
    );
    const XTypeGroup pngTypeGroup = XTypeGroup(
      label: 'PNGs',
      extensions: <String>['png'],
    );
    final List<XFile> files = await FileSelectorPlatform.instance
        .openFiles(acceptedTypeGroups: <XTypeGroup>[
      jpgsTypeGroup,
      pngTypeGroup,
    ]);
    if (files.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => MultipleImagesDisplay(files),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open multiple images'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open multiple images (png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class MultipleImagesDisplay extends StatelessWidget {
  /// Default Constructor.
  const MultipleImagesDisplay(this.files, {super.key});

  /// The files containing the images.
  final List<XFile> files;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Gallery'),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: Center(
        child: Row(
          children: <Widget>[
            ...files.map(
              (XFile file) => Flexible(
                  child: kIsWeb
                      ? Image.network(file.path)
                      : Image.file(File(file.path))),
            )
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\open_text_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a text file using `openFile`, then
/// displays its contents in a dialog.
class OpenTextPage extends StatelessWidget {
  /// Default Constructor
  const OpenTextPage({super.key});

  Future<void> _openTextFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'text',
      extensions: <String>['txt', 'json'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String fileContent = await file.readAsString();

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(fileName, fileContent),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open a text file (json, txt)'),
              onPressed: () => _openTextFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Default Constructor.
  const TextDisplay(this.fileName, this.fileContent, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The contents of the text file.
  final String fileContent;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(fileContent),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\save_text_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'dart:typed_data';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a save location using `getSavePath`,
/// then writes text to a file at that location.
class SaveTextPage extends StatelessWidget {
  /// Default Constructor
  SaveTextPage({super.key});

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _contentController = TextEditingController();

  Future<void> _saveFile() async {
    final String fileName = _nameController.text;
    final FileSaveLocation? result =
        await FileSelectorPlatform.instance.getSaveLocation(
      options: SaveDialogOptions(suggestedName: fileName),
      acceptedTypeGroups: const <XTypeGroup>[
        XTypeGroup(
          label: 'Plain text',
          extensions: <String>['txt'],
        ),
        XTypeGroup(
          label: 'JSON',
          extensions: <String>['json'],
        ),
      ],
    );
    // Operation was canceled by the user.
    if (result == null) {
      return;
    }
    String path = result.path;
    // Append an extension based on the selected type group if the user didn't
    // include one.
    if (!path.split(Platform.pathSeparator).last.contains('.')) {
      final XTypeGroup? activeGroup = result.activeFilter;
      if (activeGroup != null) {
        // The group is one of the groups passed in above, each of which has
        // exactly one `extensions` entry.
        path = '$path.${activeGroup.extensions!.first}';
      }
    }
    final String text = _contentController.text;
    final Uint8List fileData = Uint8List.fromList(text.codeUnits);
    final XFile textFile = XFile.fromData(fileData, name: fileName);
    await textFile.saveTo(result.path);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Save text into a file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: '(Optional) Suggest File Name',
                ),
              ),
            ),
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _contentController,
                decoration: const InputDecoration(
                  hintText: 'Enter File Contents',
                ),
              ),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              onPressed: _saveFile,
              child: const Text('Press to save a text file'),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\pubspec.yaml =====
name: example
description: Example for file_selector_windows implementation.
publish_to: 'none'
version: 1.0.0

environment:
  sdk: ^3.4.0
  flutter: ">=3.22.0"

dependencies:
  file_selector_platform_interface: ^2.6.0
  file_selector_windows:
    # When depending on this package from a real application you should use:
    #   file_selector_windows: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ..
  flutter:
    sdk: flutter

dev_dependencies:
  flutter_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\lib\src\messages.g.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.4.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse(
    {Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

class TypeGroup {
  TypeGroup({
    required this.label,
    required this.extensions,
  });

  String label;

  List<String> extensions;

  Object encode() {
    return <Object?>[
      label,
      extensions,
    ];
  }

  static TypeGroup decode(Object result) {
    result as List<Object?>;
    return TypeGroup(
      label: result[0]! as String,
      extensions: (result[1] as List<Object?>?)!.cast<String>(),
    );
  }
}

class SelectionOptions {
  SelectionOptions({
    this.allowMultiple = false,
    this.selectFolders = false,
    this.allowedTypes = const <TypeGroup>[],
  });

  bool allowMultiple;

  bool selectFolders;

  List<TypeGroup> allowedTypes;

  Object encode() {
    return <Object?>[
      allowMultiple,
      selectFolders,
      allowedTypes,
    ];
  }

  static SelectionOptions decode(Object result) {
    result as List<Object?>;
    return SelectionOptions(
      allowMultiple: result[0]! as bool,
      selectFolders: result[1]! as bool,
      allowedTypes: (result[2] as List<Object?>?)!.cast<TypeGroup>(),
    );
  }
}

/// The result from an open or save dialog.
class FileDialogResult {
  FileDialogResult({
    required this.paths,
    this.typeGroupIndex,
  });

  /// The selected paths.
  ///
  /// Empty if the dialog was canceled.
  List<String> paths;

  /// The type group index (into the list provided in [SelectionOptions]) of
  /// the group that was selected when the dialog was confirmed.
  ///
  /// Null if no type groups were provided, or the dialog was canceled.
  int? typeGroupIndex;

  Object encode() {
    return <Object?>[
      paths,
      typeGroupIndex,
    ];
  }

  static FileDialogResult decode(Object result) {
    result as List<Object?>;
    return FileDialogResult(
      paths: (result[0] as List<Object?>?)!.cast<String>(),
      typeGroupIndex: result[1] as int?,
    );
  }
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is TypeGroup) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is SelectionOptions) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is FileDialogResult) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        return TypeGroup.decode(readValue(buffer)!);
      case 130:
        return SelectionOptions.decode(readValue(buffer)!);
      case 131:
        return FileDialogResult.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FileSelectorApi {
  /// Constructor for [FileSelectorApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FileSelectorApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<FileDialogResult> showOpenDialog(SelectionOptions options,
      String? initialDirectory, String? confirmButtonText) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[options, initialDirectory, confirmButtonText])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FileDialogResult?)!;
    }
  }

  Future<FileDialogResult> showSaveDialog(
      SelectionOptions options,
      String? initialDirectory,
      String? suggestedName,
      String? confirmButtonText) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[
      options,
      initialDirectory,
      suggestedName,
      confirmButtonText
    ]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FileDialogResult?)!;
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\lib\file_selector_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [FileSelectorPlatform] for Windows.
class FileSelectorWindows extends FileSelectorPlatform {
  final FileSelectorApi _hostApi = FileSelectorApi();

  /// Registers the Windows implementation.
  static void registerWith() {
    FileSelectorPlatform.instance = FileSelectorWindows();
  }

  @override
  Future<XFile?> openFile({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? null : XFile(result.paths.first);
  }

  @override
  Future<List<XFile>> openFiles({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowMultiple: true,
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.map((String? path) => XFile(path!)).toList();
  }

  @override
  Future<String?> getSavePath({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) async {
    final FileSaveLocation? location = await getSaveLocation(
        acceptedTypeGroups: acceptedTypeGroups,
        options: SaveDialogOptions(
          initialDirectory: initialDirectory,
          suggestedName: suggestedName,
          confirmButtonText: confirmButtonText,
        ));
    return location?.path;
  }

  @override
  Future<FileSaveLocation?> getSaveLocation({
    List<XTypeGroup>? acceptedTypeGroups,
    SaveDialogOptions options = const SaveDialogOptions(),
  }) async {
    final FileDialogResult result = await _hostApi.showSaveDialog(
        SelectionOptions(
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        options.initialDirectory,
        options.suggestedName,
        options.confirmButtonText);
    final int? groupIndex = result.typeGroupIndex;
    return result.paths.isEmpty
        ? null
        : FileSaveLocation(result.paths.first,
            activeFilter:
                groupIndex == null ? null : acceptedTypeGroups?[groupIndex]);
  }

  @override
  Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          selectFolders: true,
          allowedTypes: <TypeGroup>[],
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? null : result.paths.first;
  }

  @override
  Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowMultiple: true,
          selectFolders: true,
          allowedTypes: <TypeGroup>[],
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? <String>[] : List<String>.from(result.paths);
  }
}

List<TypeGroup> _typeGroupsFromXTypeGroups(List<XTypeGroup>? xtypes) {
  return (xtypes ?? <XTypeGroup>[]).map((XTypeGroup xtype) {
    if (!xtype.allowsAny && (xtype.extensions?.isEmpty ?? true)) {
      throw ArgumentError('Provided type group $xtype does not allow '
          'all files, but does not set any of the Windows-supported filter '
          'categories. "extensions" must be non-empty for Windows if '
          'anything is non-empty.');
    }
    return TypeGroup(
        label: xtype.label ?? '', extensions: xtype.extensions ?? <String>[]);
  }).toList();
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\pigeons\messages.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  dartTestOut: 'test/test_api.g.dart',
  cppOptions: CppOptions(namespace: 'file_selector_windows'),
  cppHeaderOut: 'windows/messages.g.h',
  cppSourceOut: 'windows/messages.g.cpp',
  copyrightHeader: 'pigeons/copyright.txt',
))
class TypeGroup {
  TypeGroup(this.label, {required this.extensions});

  String label;
  List<String> extensions;
}

class SelectionOptions {
  SelectionOptions({
    this.allowMultiple = false,
    this.selectFolders = false,
    this.allowedTypes = const <TypeGroup>[],
  });
  bool allowMultiple;
  bool selectFolders;
  List<TypeGroup> allowedTypes;
}

/// The result from an open or save dialog.
class FileDialogResult {
  FileDialogResult({required this.paths, this.typeGroupIndex});

  /// The selected paths.
  ///
  /// Empty if the dialog was canceled.
  List<String> paths;

  /// The type group index (into the list provided in [SelectionOptions]) of
  /// the group that was selected when the dialog was confirmed.
  ///
  /// Null if no type groups were provided, or the dialog was canceled.
  int? typeGroupIndex;
}

@HostApi(dartHostTestHandler: 'TestFileSelectorApi')
abstract class FileSelectorApi {
  FileDialogResult showOpenDialog(
    SelectionOptions options,
    String? initialDirectory,
    String? confirmButtonText,
  );
  FileDialogResult showSaveDialog(
    SelectionOptions options,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\test\file_selector_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:file_selector_windows/src/messages.g.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'file_selector_windows_test.mocks.dart';
import 'test_api.g.dart';

@GenerateMocks(<Type>[TestFileSelectorApi])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  final FileSelectorWindows plugin = FileSelectorWindows();
  late MockTestFileSelectorApi mockApi;

  setUp(() {
    mockApi = MockTestFileSelectorApi();
    TestFileSelectorApi.setUp(mockApi);
  });

  test('registered instance', () {
    FileSelectorWindows.registerWith();
    expect(FileSelectorPlatform.instance, isA<FileSelectorWindows>());
  });

  group('openFile', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final XFile? file = await plugin.openFile();

      expect(file!.path, 'foo');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.openFile(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.openFile(confirmButtonText: 'Open File');

      verify(mockApi.showOpenDialog(any, null, 'Open File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]), completes);
    });
  });

  group('openFiles', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo', 'bar']));
    });

    test('simple call works', () async {
      final List<XFile> file = await plugin.openFiles();

      expect(file[0].path, 'foo');
      expect(file[1].path, 'bar');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, true);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.openFiles(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.openFiles(confirmButtonText: 'Open Files');

      verify(mockApi.showOpenDialog(any, null, 'Open Files'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]), completes);
    });
  });

  group('getDirectoryPath', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final String? path = await plugin.getDirectoryPath();

      expect(path, 'foo');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getDirectoryPath(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getDirectoryPath(confirmButtonText: 'Open Directory');

      verify(mockApi.showOpenDialog(any, null, 'Open Directory'));
    });
  });

  group('getDirectoryPaths', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo', 'bar']));
    });

    test('simple call works', () async {
      final List<String> paths = await plugin.getDirectoryPaths();

      expect(paths[0], 'foo');
      expect(paths[1], 'bar');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, true);
      expect(options.selectFolders, true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getDirectoryPath(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getDirectoryPath(confirmButtonText: 'Open Directory');

      verify(mockApi.showOpenDialog(any, null, 'Open Directory'));
    });
  });

  group('getSaveLocation', () {
    setUp(() {
      when(mockApi.showSaveDialog(any, any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final FileSaveLocation? location = await plugin.getSaveLocation();

      expect(location?.path, 'foo');
      expect(location?.activeFilter, null);
      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('returns the selected type group correctly', () async {
      when(mockApi.showSaveDialog(any, any, any, any)).thenReturn(
          FileDialogResult(paths: <String>['foo'], typeGroupIndex: 1));
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      final FileSaveLocation? result = await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      verify(mockApi.showSaveDialog(captureAny, null, null, null));

      expect(result?.activeFilter, groupTwo);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getSaveLocation(
          options:
              const SaveDialogOptions(initialDirectory: '/example/directory'));

      verify(mockApi.showSaveDialog(any, '/example/directory', null, null));
    });

    test('passes suggestedName correctly', () async {
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(suggestedName: 'baz.txt'));

      verify(mockApi.showSaveDialog(any, null, 'baz.txt', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(confirmButtonText: 'Save File'));

      verify(mockApi.showSaveDialog(any, null, null, 'Save File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          completes);
    });
  });

  group('getSavePath (deprecated)', () {
    setUp(() {
      when(mockApi.showSaveDialog(any, any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final String? path = await plugin.getSavePath();

      expect(path, 'foo');
      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSavePath(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getSavePath(initialDirectory: '/example/directory');

      verify(mockApi.showSaveDialog(any, '/example/directory', null, null));
    });

    test('passes suggestedName correctly', () async {
      await plugin.getSavePath(suggestedName: 'baz.txt');

      verify(mockApi.showSaveDialog(any, null, 'baz.txt', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getSavePath(confirmButtonText: 'Save File');

      verify(mockApi.showSaveDialog(any, null, null, 'Save File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          completes);
    });
  });
}

// True if the given options match.
//
// This is needed because Pigeon data classes don't have custom equality checks,
// so only match for identical instances.
bool _typeGroupListsMatch(List<TypeGroup?> a, List<TypeGroup?> b) {
  if (a.length != b.length) {
    return false;
  }
  for (int i = 0; i < a.length; i++) {
    if (!_typeGroupsMatch(a[i], b[i])) {
      return false;
    }
  }
  return true;
}

// True if the given type groups match.
//
// This is needed because Pigeon data classes don't have custom equality checks,
// so only match for identical instances.
bool _typeGroupsMatch(TypeGroup? a, TypeGroup? b) {
  return a!.label == b!.label && listEquals(a.extensions, b.extensions);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\test\file_selector_windows_test.mocks.dart =====
// Mocks generated by Mockito 5.4.4 from annotations
// in file_selector_windows/test/file_selector_windows_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:file_selector_windows/src/messages.g.dart' as _i2;
import 'package:mockito/mockito.dart' as _i1;

import 'test_api.g.dart' as _i3;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

class _FakeFileDialogResult_0 extends _i1.SmartFake
    implements _i2.FileDialogResult {
  _FakeFileDialogResult_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [TestFileSelectorApi].
///
/// See the documentation for Mockito's code generation for more information.
class MockTestFileSelectorApi extends _i1.Mock
    implements _i3.TestFileSelectorApi {
  MockTestFileSelectorApi() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.FileDialogResult showOpenDialog(
    _i2.SelectionOptions? options,
    String? initialDirectory,
    String? confirmButtonText,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #showOpenDialog,
          [
            options,
            initialDirectory,
            confirmButtonText,
          ],
        ),
        returnValue: _FakeFileDialogResult_0(
          this,
          Invocation.method(
            #showOpenDialog,
            [
              options,
              initialDirectory,
              confirmButtonText,
            ],
          ),
        ),
      ) as _i2.FileDialogResult);

  @override
  _i2.FileDialogResult showSaveDialog(
    _i2.SelectionOptions? options,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #showSaveDialog,
          [
            options,
            initialDirectory,
            suggestedName,
            confirmButtonText,
          ],
        ),
        returnValue: _FakeFileDialogResult_0(
          this,
          Invocation.method(
            #showSaveDialog,
            [
              options,
              initialDirectory,
              suggestedName,
              confirmButtonText,
            ],
          ),
        ),
      ) as _i2.FileDialogResult);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\test\test_api.g.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.4.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, unnecessary_import, no_leading_underscores_for_local_identifiers
// ignore_for_file: avoid_relative_lib_imports
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;
import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:file_selector_windows/src/messages.g.dart';

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is TypeGroup) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is SelectionOptions) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is FileDialogResult) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        return TypeGroup.decode(readValue(buffer)!);
      case 130:
        return SelectionOptions.decode(readValue(buffer)!);
      case 131:
        return FileDialogResult.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class TestFileSelectorApi {
  static TestDefaultBinaryMessengerBinding? get _testBinaryMessengerBinding =>
      TestDefaultBinaryMessengerBinding.instance;
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  FileDialogResult showOpenDialog(SelectionOptions options,
      String? initialDirectory, String? confirmButtonText);

  FileDialogResult showSaveDialog(
      SelectionOptions options,
      String? initialDirectory,
      String? suggestedName,
      String? confirmButtonText);

  static void setUp(
    TestFileSelectorApi? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel, null);
      } else {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel,
                (Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final SelectionOptions? arg_options = (args[0] as SelectionOptions?);
          assert(arg_options != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog was null, expected non-null SelectionOptions.');
          final String? arg_initialDirectory = (args[1] as String?);
          final String? arg_confirmButtonText = (args[2] as String?);
          try {
            final FileDialogResult output = api.showOpenDialog(
                arg_options!, arg_initialDirectory, arg_confirmButtonText);
            return <Object?>[output];
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel, null);
      } else {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel,
                (Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final SelectionOptions? arg_options = (args[0] as SelectionOptions?);
          assert(arg_options != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog was null, expected non-null SelectionOptions.');
          final String? arg_initialDirectory = (args[1] as String?);
          final String? arg_suggestedName = (args[2] as String?);
          final String? arg_confirmButtonText = (args[3] as String?);
          try {
            final FileDialogResult output = api.showSaveDialog(arg_options!,
                arg_initialDirectory, arg_suggestedName, arg_confirmButtonText);
            return <Object?>[output];
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\pubspec.yaml =====
name: file_selector_windows
description: Windows implementation of the file_selector plugin.
repository: https://github.com/flutter/packages/tree/main/packages/file_selector/file_selector_windows
issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+file_selector%22
version: 0.9.3+4

environment:
  sdk: ^3.4.0
  flutter: ">=3.22.0"

flutter:
  plugin:
    implements: file_selector
    platforms:
      windows:
        dartPluginClass: FileSelectorWindows
        pluginClass: FileSelectorWindows

dependencies:
  cross_file: ^0.3.1
  file_selector_platform_interface: ^2.6.0
  flutter:
    sdk: flutter

dev_dependencies:
  build_runner: ^2.3.0
  flutter_test:
    sdk: flutter
  mockito: ^5.4.4
  pigeon: ^22.4.1

topics:
  - files
  - file-selection
  - file-selector
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\android\src\main\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="io.flutter.plugins.firebase.auth">
    <application>
        <service android:name="com.google.firebase.components.ComponentDiscoveryService">
            <meta-data android:name="com.google.firebase.components:io.flutter.plugins.firebase.auth.FlutterFirebaseAuthRegistrar"
                       android:value="com.google.firebase.components.ComponentRegistrar" />
        </service>
    </application>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\android\app\src\debug\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\android\app\src\main\res\drawable\launch_background.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\android\app\src\main\res\drawable-v21\launch_background.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\android\app\src\main\res\values\styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\android\app\src\main\res\values-night\styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\android\app\src\main\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="example"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\android\app\src\profile\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\android\app\google-services.json =====
{
  "project_info": {
    "project_number": "406099696497",
    "firebase_url": "https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app",
    "project_id": "flutterfire-e2e-tests",
    "storage_bucket": "flutterfire-e2e-tests.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:d86a91cc7b338b233574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.analytics.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:a241c4b471513a203574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.appcheck.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-7bvmqp0fffe24vm2arng0dtdeh2tvkgl.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.appcheck.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:21d5142deea38dda3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.auth.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-emmujnd7g2ammh5uu9ni6v04p4ateqac.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-in8bfp0nali85oul1o98huoar6eo1vv1.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:3ef965ff044efc0b3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dataconnect.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:40da41183cb3d3ff3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dynamiclinksexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:175ea7a64b2faf5e3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.firestore.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:7ca3394493cc601a3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.functions.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:6d1c1fbf4688f39c3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.installations.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:74ebb073d7727cd43574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.messaging.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:f54b85cfa36a39f73574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.remoteconfig.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0d4ed619c031c0ac3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.tests"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ib9hj9281l3343cm3nfvvdotaojrthdc.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-lc54d5l8sp90k39r0bb39ovsgo1s9bek.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:899c6485cfce26c13574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase_ui_example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ltgvphphcckosvqhituel5km2k3aecg8.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase_ui_example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:bc0b12b0605df8633574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecoreexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0f3f7bfe78b8b7103574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecrashlyticsexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:2751af6868a69f073574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasestorageexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\ios\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json =====
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\ios\Runner\Assets.xcassets\LaunchImage.imageset\Contents.json =====
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\ios\firebase_app_id_file.json =====
{
  "file_generated_by": "FlutterFire CLI",
  "purpose": "FirebaseAppID & ProjectID for this Firebase app in this directory",
  "GOOGLE_APP_ID": "1:406099696497:ios:58cbc26aca8e5cf83574d0",
  "FIREBASE_PROJECT_ID": "flutterfire-e2e-tests",
  "GCM_SENDER_ID": "406099696497"
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\lib\auth.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:io';

import 'package:barcode_widget/barcode_widget.dart';
import 'package:collection/collection.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_auth_example/main.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter_facebook_auth/flutter_facebook_auth.dart';
import 'package:flutter_signin_button/flutter_signin_button.dart';
import 'package:google_sign_in/google_sign_in.dart';

typedef OAuthSignIn = void Function();

// If set to true, the app will request notification permissions to use
// silent verification for SMS MFA instead of Recaptcha.
const withSilentVerificationSMSMFA = true;

/// Helper class to show a snackbar using the passed context.
class ScaffoldSnackbar {
  // ignore: public_member_api_docs
  ScaffoldSnackbar(this._context);

  /// The scaffold of current context.
  factory ScaffoldSnackbar.of(BuildContext context) {
    return ScaffoldSnackbar(context);
  }

  final BuildContext _context;

  /// Helper method to show a SnackBar.
  void show(String message) {
    ScaffoldMessenger.of(_context)
      ..hideCurrentSnackBar()
      ..showSnackBar(
        SnackBar(
          content: Text(message),
          behavior: SnackBarBehavior.floating,
        ),
      );
  }
}

/// The mode of the current auth session, either [AuthMode.login] or [AuthMode.register].
// ignore: public_member_api_docs
enum AuthMode { login, register, phone }

extension on AuthMode {
  String get label => this == AuthMode.login
      ? 'Sign in'
      : this == AuthMode.phone
          ? 'Sign in'
          : 'Register';
}

/// Entrypoint example for various sign-in flows with Firebase.
class AuthGate extends StatefulWidget {
  // ignore: public_member_api_docs
  const AuthGate({Key? key}) : super(key: key);
  static String? appleAuthorizationCode;
  @override
  State<StatefulWidget> createState() => _AuthGateState();
}

class _AuthGateState extends State<AuthGate> {
  TextEditingController emailController = TextEditingController();
  TextEditingController passwordController = TextEditingController();
  TextEditingController phoneController = TextEditingController();

  GlobalKey<FormState> formKey = GlobalKey<FormState>();
  String error = '';
  String verificationId = '';

  AuthMode mode = AuthMode.login;

  bool isLoading = false;

  void setIsLoading() {
    setState(() {
      isLoading = !isLoading;
    });
  }

  late Map<Buttons, OAuthSignIn> authButtons;

  @override
  void initState() {
    super.initState();

    if (withSilentVerificationSMSMFA && !kIsWeb) {
      FirebaseMessaging messaging = FirebaseMessaging.instance;
      messaging.requestPermission();
    }

    if (!kIsWeb && Platform.isMacOS) {
      authButtons = {
        Buttons.Apple: () => _handleMultiFactorException(
              _signInWithApple,
            ),
      };
    } else {
      authButtons = {
        Buttons.Apple: () => _handleMultiFactorException(
              _signInWithApple,
            ),
        Buttons.Google: () => _handleMultiFactorException(
              _signInWithGoogle,
            ),
        Buttons.GitHub: () => _handleMultiFactorException(
              _signInWithGitHub,
            ),
        Buttons.Microsoft: () => _handleMultiFactorException(
              _signInWithMicrosoft,
            ),
        Buttons.Twitter: () => _handleMultiFactorException(
              _signInWithTwitter,
            ),
        Buttons.Yahoo: () => _handleMultiFactorException(
              _signInWithYahoo,
            ),
        Buttons.Facebook: () => _handleMultiFactorException(
              _signInWithFacebook,
            ),
      };
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: FocusScope.of(context).unfocus,
      child: Scaffold(
        body: Center(
          child: SingleChildScrollView(
            child: Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: SafeArea(
                  child: Form(
                    key: formKey,
                    autovalidateMode: AutovalidateMode.onUserInteraction,
                    child: ConstrainedBox(
                      constraints: const BoxConstraints(maxWidth: 400),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Visibility(
                            visible: error.isNotEmpty,
                            child: MaterialBanner(
                              backgroundColor:
                                  Theme.of(context).colorScheme.error,
                              content: SelectableText(error),
                              actions: [
                                TextButton(
                                  onPressed: () {
                                    setState(() {
                                      error = '';
                                    });
                                  },
                                  child: const Text(
                                    'dismiss',
                                    style: TextStyle(color: Colors.white),
                                  ),
                                ),
                              ],
                              contentTextStyle:
                                  const TextStyle(color: Colors.white),
                              padding: const EdgeInsets.all(10),
                            ),
                          ),
                          const SizedBox(height: 20),
                          if (mode != AuthMode.phone)
                            Column(
                              children: [
                                TextFormField(
                                  controller: emailController,
                                  decoration: const InputDecoration(
                                    hintText: 'Email',
                                    border: OutlineInputBorder(),
                                  ),
                                  keyboardType: TextInputType.emailAddress,
                                  autofillHints: const [AutofillHints.email],
                                  validator: (value) =>
                                      value != null && value.isNotEmpty
                                          ? null
                                          : 'Required',
                                ),
                                const SizedBox(height: 20),
                                TextFormField(
                                  controller: passwordController,
                                  obscureText: true,
                                  decoration: const InputDecoration(
                                    hintText: 'Password',
                                    border: OutlineInputBorder(),
                                  ),
                                  validator: (value) =>
                                      value != null && value.isNotEmpty
                                          ? null
                                          : 'Required',
                                ),
                              ],
                            ),
                          if (mode == AuthMode.phone)
                            TextFormField(
                              controller: phoneController,
                              decoration: const InputDecoration(
                                hintText: '+12345678910',
                                labelText: 'Phone number',
                                border: OutlineInputBorder(),
                              ),
                              validator: (value) =>
                                  value != null && value.isNotEmpty
                                      ? null
                                      : 'Required',
                            ),
                          const SizedBox(height: 20),
                          SizedBox(
                            width: double.infinity,
                            height: 50,
                            child: ElevatedButton(
                              onPressed: isLoading
                                  ? null
                                  : () => _handleMultiFactorException(
                                        _emailAndPassword,
                                      ),
                              child: isLoading
                                  ? const CircularProgressIndicator.adaptive()
                                  : Text(mode.label),
                            ),
                          ),
                          TextButton(
                            onPressed: _resetPassword,
                            child: const Text('Forgot password?'),
                          ),
                          ...authButtons.keys
                              .map(
                                (button) => Padding(
                                  padding:
                                      const EdgeInsets.symmetric(vertical: 5),
                                  child: AnimatedSwitcher(
                                    duration: const Duration(milliseconds: 200),
                                    child: isLoading
                                        ? Container(
                                            color: Colors.grey[200],
                                            height: 50,
                                            width: double.infinity,
                                          )
                                        : SizedBox(
                                            width: double.infinity,
                                            height: 50,
                                            child: SignInButton(
                                              button,
                                              onPressed: authButtons[button],
                                            ),
                                          ),
                                  ),
                                ),
                              )
                              .toList(),
                          SizedBox(
                            width: double.infinity,
                            height: 50,
                            child: OutlinedButton(
                              onPressed: isLoading
                                  ? null
                                  : () {
                                      if (mode != AuthMode.phone) {
                                        setState(() {
                                          mode = AuthMode.phone;
                                        });
                                      } else {
                                        setState(() {
                                          mode = AuthMode.login;
                                        });
                                      }
                                    },
                              child: isLoading
                                  ? const CircularProgressIndicator.adaptive()
                                  : Text(
                                      mode != AuthMode.phone
                                          ? 'Sign in with Phone Number'
                                          : 'Sign in with Email and Password',
                                    ),
                            ),
                          ),
                          const SizedBox(height: 20),
                          if (mode != AuthMode.phone)
                            RichText(
                              text: TextSpan(
                                style: Theme.of(context).textTheme.bodyLarge,
                                children: [
                                  TextSpan(
                                    text: mode == AuthMode.login
                                        ? "Don't have an account? "
                                        : 'You have an account? ',
                                  ),
                                  TextSpan(
                                    text: mode == AuthMode.login
                                        ? 'Register now'
                                        : 'Click to login',
                                    style: const TextStyle(color: Colors.blue),
                                    recognizer: TapGestureRecognizer()
                                      ..onTap = () {
                                        setState(() {
                                          mode = mode == AuthMode.login
                                              ? AuthMode.register
                                              : AuthMode.login;
                                        });
                                      },
                                  ),
                                ],
                              ),
                            ),
                          const SizedBox(height: 10),
                          RichText(
                            text: TextSpan(
                              style: Theme.of(context).textTheme.bodyLarge,
                              children: [
                                const TextSpan(text: 'Or '),
                                TextSpan(
                                  text: 'continue as guest',
                                  style: const TextStyle(color: Colors.blue),
                                  recognizer: TapGestureRecognizer()
                                    ..onTap = _anonymousAuth,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future _resetPassword() async {
    String? email;
    await showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Send'),
            ),
          ],
          content: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Enter your email'),
              const SizedBox(height: 20),
              TextFormField(
                onChanged: (value) {
                  email = value;
                },
              ),
            ],
          ),
        );
      },
    );

    if (email != null) {
      try {
        await auth.sendPasswordResetEmail(email: email!);
        ScaffoldSnackbar.of(context).show('Password reset email is sent');
      } catch (e) {
        ScaffoldSnackbar.of(context).show('Error resetting');
      }
    }
  }

  Future<void> _anonymousAuth() async {
    setIsLoading();

    try {
      await auth.signInAnonymously();
    } on FirebaseAuthException catch (e) {
      setState(() {
        error = '${e.message}';
      });
    } catch (e) {
      setState(() {
        error = '$e';
      });
    } finally {
      setIsLoading();
    }
  }

  Future<void> _handleMultiFactorException(
    Future<void> Function() authFunction,
  ) async {
    setIsLoading();
    try {
      await authFunction();
    } on FirebaseAuthMultiFactorException catch (e) {
      setState(() {
        error = '${e.message}';
      });
      final firstTotpHint = e.resolver.hints
          .firstWhereOrNull((element) => element is TotpMultiFactorInfo);
      if (firstTotpHint != null) {
        final code = await getSmsCodeFromUser(context);
        final assertion = await TotpMultiFactorGenerator.getAssertionForSignIn(
          firstTotpHint.uid,
          code!,
        );
        await e.resolver.resolveSignIn(assertion);
        return;
      }

      final firstPhoneHint = e.resolver.hints
          .firstWhereOrNull((element) => element is PhoneMultiFactorInfo);

      if (firstPhoneHint is! PhoneMultiFactorInfo) {
        return;
      }
      await auth.verifyPhoneNumber(
        multiFactorSession: e.resolver.session,
        multiFactorInfo: firstPhoneHint,
        verificationCompleted: (_) {},
        verificationFailed: print,
        codeSent: (String verificationId, int? resendToken) async {
          final smsCode = await getSmsCodeFromUser(context);

          if (smsCode != null) {
            // Create a PhoneAuthCredential with the code
            final credential = PhoneAuthProvider.credential(
              verificationId: verificationId,
              smsCode: smsCode,
            );

            try {
              await e.resolver.resolveSignIn(
                PhoneMultiFactorGenerator.getAssertion(
                  credential,
                ),
              );
            } on FirebaseAuthException catch (e) {
              print(e.message);
            }
          }
        },
        codeAutoRetrievalTimeout: print,
      );
    } on FirebaseAuthException catch (e) {
      setState(() {
        error = '${e.message}';
      });
    } catch (e) {
      setState(() {
        error = '$e';
      });
    }
    setIsLoading();
  }

  Future<void> _emailAndPassword() async {
    if (formKey.currentState?.validate() ?? false) {
      if (mode == AuthMode.login) {
        await auth.signInWithEmailAndPassword(
          email: emailController.text,
          password: passwordController.text,
        );
      } else if (mode == AuthMode.register) {
        await auth.createUserWithEmailAndPassword(
          email: emailController.text,
          password: passwordController.text,
        );
      } else {
        await _phoneAuth();
      }
    }
  }

  Future<void> _phoneAuth() async {
    if (mode != AuthMode.phone) {
      setState(() {
        mode = AuthMode.phone;
      });
    } else {
      if (kIsWeb) {
        final confirmationResult =
            await auth.signInWithPhoneNumber(phoneController.text);
        final smsCode = await getSmsCodeFromUser(context);

        if (smsCode != null) {
          await confirmationResult.confirm(smsCode);
        }
      } else {
        await auth.verifyPhoneNumber(
          phoneNumber: phoneController.text,
          verificationCompleted: (_) {},
          verificationFailed: (e) {
            setState(() {
              error = '${e.message}';
            });
          },
          codeSent: (String verificationId, int? resendToken) async {
            final smsCode = await getSmsCodeFromUser(context);

            if (smsCode != null) {
              // Create a PhoneAuthCredential with the code
              final credential = PhoneAuthProvider.credential(
                verificationId: verificationId,
                smsCode: smsCode,
              );

              try {
                // Sign the user in (or link) with the credential
                await auth.signInWithCredential(credential);
              } on FirebaseAuthException catch (e) {
                setState(() {
                  error = e.message ?? '';
                });
              }
            }
          },
          codeAutoRetrievalTimeout: (e) {
            setState(() {
              error = e;
            });
          },
        );
      }
    }
  }

  Future<void> _signInWithGoogle() async {
    // Trigger the authentication flow
    final googleUser = await GoogleSignIn().signIn();

    // Obtain the auth details from the request
    final googleAuth = await googleUser?.authentication;

    if (googleAuth != null) {
      // Create a new credential
      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );

      // Once signed in, return the UserCredential
      await auth.signInWithCredential(credential);
    }
  }

  Future<void> _signInWithFacebook() async {
    // Trigger the authentication flow
    // by default we request the email and the public profile
    final LoginResult result = await FacebookAuth.instance.login();

    if (result.status == LoginStatus.success) {
      // Get access token
      final AccessToken accessToken = result.accessToken!;

      // Login with token
      await auth.signInWithCredential(
        FacebookAuthProvider.credential(accessToken.tokenString),
      );
    } else {
      print('Facebook login did not succeed');
      print(result.status);
      print(result.message);
    }
  }
}

Future<void> _signInWithTwitter() async {
  TwitterAuthProvider twitterProvider = TwitterAuthProvider();

  if (kIsWeb) {
    await auth.signInWithPopup(twitterProvider);
  } else {
    await auth.signInWithProvider(twitterProvider);
  }
}

Future<void> _signInWithApple() async {
  final appleProvider = AppleAuthProvider();
  appleProvider.addScope('email');

  if (kIsWeb) {
    // Once signed in, return the UserCredential
    await auth.signInWithPopup(appleProvider);
  } else {
    final userCred = await auth.signInWithProvider(appleProvider);
    AuthGate.appleAuthorizationCode =
        userCred.additionalUserInfo?.authorizationCode;
  }
}

Future<void> _signInWithYahoo() async {
  final yahooProvider = YahooAuthProvider();

  if (kIsWeb) {
    // Once signed in, return the UserCredential
    await auth.signInWithPopup(yahooProvider);
  } else {
    await auth.signInWithProvider(yahooProvider);
  }
}

Future<void> _signInWithGitHub() async {
  final githubProvider = GithubAuthProvider();

  if (kIsWeb) {
    await auth.signInWithPopup(githubProvider);
  } else {
    await auth.signInWithProvider(githubProvider);
  }
}

Future<void> _signInWithMicrosoft() async {
  final microsoftProvider = MicrosoftAuthProvider();

  if (kIsWeb) {
    await auth.signInWithPopup(microsoftProvider);
  } else {
    await auth.signInWithProvider(microsoftProvider);
  }
}

Future<String?> getSmsCodeFromUser(BuildContext context) async {
  String? smsCode;

  // Update the UI - wait for the user to enter the SMS code
  await showDialog<String>(
    context: context,
    barrierDismissible: false,
    builder: (context) {
      return AlertDialog(
        title: const Text('SMS code:'),
        actions: [
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: const Text('Sign in'),
          ),
          OutlinedButton(
            onPressed: () {
              smsCode = null;
              Navigator.of(context).pop();
            },
            child: const Text('Cancel'),
          ),
        ],
        content: Container(
          padding: const EdgeInsets.all(20),
          child: TextField(
            onChanged: (value) {
              smsCode = value;
            },
            textAlign: TextAlign.center,
            autofocus: true,
          ),
        ),
      );
    },
  );

  return smsCode;
}

Future<String?> getTotpFromUser(
  BuildContext context,
  TotpSecret totpSecret,
) async {
  String? smsCode;

  final qrCodeUrl = await totpSecret.generateQrCodeUrl(
    accountName: FirebaseAuth.instance.currentUser!.email,
    issuer: 'Firebase',
  );

  // Update the UI - wait for the user to enter the SMS code
  await showDialog<String>(
    context: context,
    barrierDismissible: false,
    builder: (context) {
      return AlertDialog(
        title: const Text('TOTP code:'),
        content: Container(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              BarcodeWidget(
                barcode: Barcode.qrCode(),
                data: qrCodeUrl,
                width: 150,
                height: 150,
              ),
              TextField(
                onChanged: (value) {
                  smsCode = value;
                },
                textAlign: TextAlign.center,
                autofocus: true,
              ),
              ElevatedButton(
                onPressed: () {
                  totpSecret.openInOtpApp(qrCodeUrl);
                },
                child: const Text('Open in OTP App'),
              ),
            ],
          ),
        ),
        actions: [
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: const Text('Sign in'),
          ),
          OutlinedButton(
            onPressed: () {
              smsCode = null;
              Navigator.of(context).pop();
            },
            child: const Text('Cancel'),
          ),
        ],
      );
    },
  );

  return smsCode;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\lib\firebase_options.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return macos;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:21d5142deea38dda3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:58cbc26aca8e5cf83574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-134k3722m01rtrsklhf3b7k8sqa5r7in.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.auth.example',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:58cbc26aca8e5cf83574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com',
    iosClientId:
        '406099696497-134k3722m01rtrsklhf3b7k8sqa5r7in.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.auth.example',
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\lib\main.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:io';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:google_sign_in_dartio/google_sign_in_dartio.dart';

import 'auth.dart';
import 'firebase_options.dart';
import 'profile.dart';

/// Requires that a Firebase local emulator is running locally.
/// See https://firebase.google.com/docs/auth/flutter/start#optional_prototype_and_test_with_firebase_local_emulator_suite
bool shouldUseFirebaseEmulator = false;

late final FirebaseApp app;
late final FirebaseAuth auth;

// Requires that the Firebase Auth emulator is running locally
// e.g via `melos run firebase:emulator`.
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  // We're using the manual installation on non-web platforms since Google sign in plugin doesn't yet support Dart initialization.
  // See related issue: https://github.com/flutter/flutter/issues/96391

  // We store the app and auth to make testing with a named instance easier.
  app = await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  auth = FirebaseAuth.instanceFor(app: app);

  if (shouldUseFirebaseEmulator) {
    await auth.useAuthEmulator('localhost', 9099);
  }

  if (!kIsWeb && Platform.isWindows) {
    await GoogleSignInDart.register(
      clientId:
          '406099696497-g5o9l0blii9970bgmfcfv14pioj90djd.apps.googleusercontent.com',
    );
  }

  runApp(const AuthExampleApp());
}

/// The entry point of the application.
///
/// Returns a [MaterialApp].
class AuthExampleApp extends StatelessWidget {
  const AuthExampleApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Firebase Example App',
      theme: ThemeData(primarySwatch: Colors.amber),
      home: Scaffold(
        body: LayoutBuilder(
          builder: (context, constraints) {
            return Row(
              children: [
                Visibility(
                  visible: constraints.maxWidth >= 1200,
                  child: Expanded(
                    child: Container(
                      height: double.infinity,
                      color: Theme.of(context).colorScheme.primary,
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Text(
                              'Firebase Auth Desktop',
                              style: Theme.of(context).textTheme.headlineMedium,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
                SizedBox(
                  width: constraints.maxWidth >= 1200
                      ? constraints.maxWidth / 2
                      : constraints.maxWidth,
                  child: StreamBuilder<User?>(
                    stream: auth.authStateChanges(),
                    builder: (context, snapshot) {
                      if (snapshot.hasData) {
                        return const ProfilePage();
                      }
                      return const AuthGate();
                    },
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\lib\profile.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:developer';

import 'package:collection/collection.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_auth_example/main.dart';
import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';

import 'auth.dart';

/// Displayed as a profile image if the user doesn't have one.
const placeholderImage =
    'https://upload.wikimedia.org/wikipedia/commons/c/cd/Portrait_Placeholder_Square.png';

/// Profile page shows after sign in or registration.
class ProfilePage extends StatefulWidget {
  // ignore: public_member_api_docs
  const ProfilePage({Key? key}) : super(key: key);

  @override
  // ignore: library_private_types_in_public_api
  _ProfilePageState createState() => _ProfilePageState();
}

class _ProfilePageState extends State<ProfilePage> {
  late User user;
  late TextEditingController controller;
  final phoneController = TextEditingController();

  String? photoURL;

  bool showSaveButton = false;
  bool isLoading = false;

  @override
  void initState() {
    user = auth.currentUser!;
    controller = TextEditingController(text: user.displayName);

    controller.addListener(_onNameChanged);

    auth.userChanges().listen((event) {
      if (event != null && mounted) {
        setState(() {
          user = event;
        });
      }
    });

    log(user.toString());

    super.initState();
  }

  @override
  void dispose() {
    controller.removeListener(_onNameChanged);

    super.dispose();
  }

  void setIsLoading() {
    setState(() {
      isLoading = !isLoading;
    });
  }

  void _onNameChanged() {
    setState(() {
      if (controller.text == user.displayName || controller.text.isEmpty) {
        showSaveButton = false;
      } else {
        showSaveButton = true;
      }
    });
  }

  /// Map User provider data into a list of Provider Ids.
  List get userProviders => user.providerData.map((e) => e.providerId).toList();

  Future updateDisplayName() async {
    await user.updateDisplayName(controller.text);

    setState(() {
      showSaveButton = false;
    });

    // ignore: use_build_context_synchronously
    ScaffoldSnackbar.of(context).show('Name updated');
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: FocusScope.of(context).unfocus,
      child: Scaffold(
        body: Stack(
          children: [
            Center(
              child: SizedBox(
                width: 400,
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Stack(
                        children: [
                          CircleAvatar(
                            maxRadius: 60,
                            backgroundImage: NetworkImage(
                              user.photoURL ?? placeholderImage,
                            ),
                          ),
                          Positioned.directional(
                            textDirection: Directionality.of(context),
                            end: 0,
                            bottom: 0,
                            child: Material(
                              clipBehavior: Clip.antiAlias,
                              color: Theme.of(context).colorScheme.secondary,
                              borderRadius: BorderRadius.circular(40),
                              child: InkWell(
                                onTap: () async {
                                  final photoURL = await getPhotoURLFromUser();

                                  if (photoURL != null) {
                                    await user.updatePhotoURL(photoURL);
                                  }
                                },
                                radius: 50,
                                child: const SizedBox(
                                  width: 35,
                                  height: 35,
                                  child: Icon(Icons.edit),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 10),
                      TextField(
                        textAlign: TextAlign.center,
                        controller: controller,
                        decoration: const InputDecoration(
                          border: InputBorder.none,
                          floatingLabelBehavior: FloatingLabelBehavior.never,
                          alignLabelWithHint: true,
                          label: Center(
                            child: Text(
                              'Click to add a display name',
                            ),
                          ),
                        ),
                      ),
                      Text(user.email ?? user.phoneNumber ?? 'User'),
                      const SizedBox(height: 10),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          if (userProviders.contains('phone'))
                            const Icon(Icons.phone),
                          if (userProviders.contains('password'))
                            const Icon(Icons.mail),
                          if (userProviders.contains('google.com'))
                            SizedBox(
                              width: 24,
                              child: Image.network(
                                'https://upload.wikimedia.org/wikipedia/commons/0/09/IOS_Google_icon.png',
                              ),
                            ),
                        ],
                      ),
                      const SizedBox(height: 20),
                      TextButton(
                        onPressed: () {
                          user.sendEmailVerification();
                        },
                        child: const Text('Verify Email'),
                      ),
                      TextButton(
                        onPressed: () async {
                          final a = await user.multiFactor.getEnrolledFactors();
                          print(a);
                        },
                        child: const Text('Get enrolled factors'),
                      ),
                      TextButton(
                        onPressed: () async {
                          if (AuthGate.appleAuthorizationCode != null) {
                            // The `authorizationCode` is on the user credential.
                            // e.g. final authorizationCode = userCredential.additionalUserInfo?.authorizationCode;
                            await FirebaseAuth.instance
                                .revokeTokenWithAuthorizationCode(
                              AuthGate.appleAuthorizationCode!,
                            );
                            // You may wish to delete the user at this point
                            AuthGate.appleAuthorizationCode = null;
                          } else {
                            print(
                              'Apple `authorizationCode` is null, cannot revoke token.',
                            );
                          }
                        },
                        child: const Text('Revoke Apple auth token'),
                      ),
                      TextFormField(
                        controller: phoneController,
                        decoration: const InputDecoration(
                          icon: Icon(Icons.phone),
                          hintText: '+33612345678',
                          labelText: 'Phone number',
                        ),
                      ),
                      const SizedBox(height: 20),
                      TextButton(
                        onPressed: () async {
                          final session = await user.multiFactor.getSession();
                          await auth.verifyPhoneNumber(
                            multiFactorSession: session,
                            phoneNumber: phoneController.text,
                            verificationCompleted: (_) {},
                            verificationFailed: print,
                            codeSent: (
                              String verificationId,
                              int? resendToken,
                            ) async {
                              final smsCode = await getSmsCodeFromUser(context);

                              if (smsCode != null) {
                                // Create a PhoneAuthCredential with the code
                                final credential = PhoneAuthProvider.credential(
                                  verificationId: verificationId,
                                  smsCode: smsCode,
                                );

                                try {
                                  await user.multiFactor.enroll(
                                    PhoneMultiFactorGenerator.getAssertion(
                                      credential,
                                    ),
                                  );
                                } on FirebaseAuthException catch (e) {
                                  print(e.message);
                                }
                              }
                            },
                            codeAutoRetrievalTimeout: print,
                          );
                        },
                        child: const Text('Verify Number For MFA'),
                      ),
                      TextButton(
                        onPressed: () async {
                          final totp =
                              (await user.multiFactor.getEnrolledFactors())
                                  .firstWhereOrNull(
                            (element) => element.factorId == 'totp',
                          );
                          if (totp != null) {
                            await user.multiFactor.unenroll(
                              factorUid:
                                  (await user.multiFactor.getEnrolledFactors())
                                      .firstWhere(
                                        (element) => element.factorId == 'totp',
                                      )
                                      .uid,
                            );
                          }
                          final session = await user.multiFactor.getSession();
                          final totpSecret =
                              await TotpMultiFactorGenerator.generateSecret(
                            session,
                          );
                          print(totpSecret);
                          final code =
                              await getTotpFromUser(context, totpSecret);
                          print('code: $code');
                          if (code == null) {
                            return;
                          }
                          await user.multiFactor.enroll(
                            await TotpMultiFactorGenerator
                                .getAssertionForEnrollment(
                              totpSecret,
                              code,
                            ),
                            displayName: 'TOTP',
                          );
                        },
                        child: const Text('Enroll TOTP'),
                      ),
                      TextButton(
                        onPressed: () async {
                          try {
                            final enrolledFactors =
                                await user.multiFactor.getEnrolledFactors();

                            await user.multiFactor.unenroll(
                              factorUid: enrolledFactors.first.uid,
                            );
                            // Show snackbar
                            ScaffoldSnackbar.of(context).show('MFA unenrolled');
                          } catch (e) {
                            print(e);
                          }
                        },
                        child: const Text('Unenroll MFA'),
                      ),
                      const Divider(),
                      TextButton(
                        onPressed: _signOut,
                        child: const Text('Sign out'),
                      ),
                    ],
                  ),
                ),
              ),
            ),
            Positioned.directional(
              textDirection: Directionality.of(context),
              end: 40,
              top: 40,
              child: AnimatedSwitcher(
                duration: const Duration(milliseconds: 200),
                child: !showSaveButton
                    ? SizedBox(key: UniqueKey())
                    : TextButton(
                        onPressed: isLoading ? null : updateDisplayName,
                        child: const Text('Save changes'),
                      ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<String?> getPhotoURLFromUser() async {
    String? photoURL;

    // Update the UI - wait for the user to enter the SMS code
    await showDialog<String>(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        return AlertDialog(
          title: const Text('New image Url:'),
          actions: [
            ElevatedButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Update'),
            ),
            OutlinedButton(
              onPressed: () {
                photoURL = null;
                Navigator.of(context).pop();
              },
              child: const Text('Cancel'),
            ),
          ],
          content: Container(
            padding: const EdgeInsets.all(20),
            child: TextField(
              onChanged: (value) {
                photoURL = value;
              },
              textAlign: TextAlign.center,
              autofocus: true,
            ),
          ),
        );
      },
    );

    return photoURL;
  }

  /// Example code for sign out.
  Future<void> _signOut() async {
    await auth.signOut();
    await GoogleSignIn().signOut();
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\macos\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json =====
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\macos\firebase_app_id_file.json =====
{
  "file_generated_by": "FlutterFire CLI",
  "purpose": "FirebaseAppID & ProjectID for this Firebase app in this directory",
  "GOOGLE_APP_ID": "1:406099696497:ios:58cbc26aca8e5cf83574d0",
  "FIREBASE_PROJECT_ID": "flutterfire-e2e-tests",
  "GCM_SENDER_ID": "406099696497"
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\web\manifest.json =====
{
    "name": "flutterfire_auth",
    "short_name": "flutterfire_auth",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\analysis_options.yaml =====
include: ../../../../analysis_options.yaml

linter:
  rules:
    avoid_print: false
    depend_on_referenced_packages: false
    library_private_types_in_public_api: false
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\example\pubspec.yaml =====
name: firebase_auth_example
description: Demonstrates how to use the firebase_auth plugin.

environment:
  sdk: '>=3.2.0 <4.0.0'

dependencies:
  barcode_widget: ^2.0.4
  firebase_auth: ^6.1.1
  firebase_core: ^4.2.0
  firebase_messaging: ^16.0.3
  flutter:
    sdk: flutter
  flutter_facebook_auth: ^7.0.1
  flutter_signin_button: ^2.0.0
  google_sign_in: ^6.1.0
  google_sign_in_dartio: ^0.3.0

dev_dependencies:
  http: ^1.0.0

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\lib\src\confirmation_result.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// A result from a phone number sign-in, link, or reauthenticate call.
///
/// This class is only usable on web based platforms.
class ConfirmationResult {
  ConfirmationResultPlatform _delegate;

  final FirebaseAuth _auth;

  ConfirmationResult._(this._auth, this._delegate) {
    ConfirmationResultPlatform.verify(_delegate);
  }

  /// The phone number authentication operation's verification ID.
  ///
  /// This can be used along with the verification code to initialize a phone
  /// auth credential.
  String get verificationId {
    return _delegate.verificationId;
  }

  /// Finishes a phone number sign-in, link, or reauthentication, given the code
  /// that was sent to the user's mobile device.
  Future<UserCredential> confirm(String verificationCode) async {
    return UserCredential._(
      _auth,
      await _delegate.confirm(verificationCode),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\lib\src\firebase_auth.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// The entry point of the Firebase Authentication SDK.
class FirebaseAuth extends FirebasePluginPlatform {
  // Cached instances of [FirebaseAuth].
  static Map<String, FirebaseAuth> _firebaseAuthInstances = {};

  // Cached and lazily loaded instance of [FirebaseAuthPlatform] to avoid
  // creating a [MethodChannelFirebaseAuth] when not needed or creating an
  // instance with the default app before a user specifies an app.
  FirebaseAuthPlatform? _delegatePackingProperty;

  /// Returns the underlying delegate implementation.
  ///
  /// If called and no [_delegatePackingProperty] exists, it will first be
  /// created and assigned before returning the delegate.
  FirebaseAuthPlatform get _delegate {
    _delegatePackingProperty ??= FirebaseAuthPlatform.instanceFor(
      app: app,
      pluginConstants: pluginConstants,
    );
    return _delegatePackingProperty!;
  }

  /// The [FirebaseApp] for this current Auth instance.
  FirebaseApp app;

  FirebaseAuth._({required this.app})
      : super(app.name, 'plugins.flutter.io/firebase_auth');

  /// Returns an instance using the default [FirebaseApp].
  static FirebaseAuth get instance {
    FirebaseApp defaultAppInstance = Firebase.app();

    return FirebaseAuth.instanceFor(app: defaultAppInstance);
  }

  /// Returns an instance using a specified [FirebaseApp].
  factory FirebaseAuth.instanceFor({
    required FirebaseApp app,
  }) {
    return _firebaseAuthInstances.putIfAbsent(app.name, () {
      return FirebaseAuth._(app: app);
    });
  }

  /// Returns the current [User] if they are currently signed-in, or `null` if
  /// not.
  ///
  /// This getter only provides a snapshot of user state. Applications that need
  /// to react to changes in user state should instead use [authStateChanges],
  /// [idTokenChanges] or [userChanges] to subscribe to updates.
  User? get currentUser {
    if (_delegate.currentUser != null) {
      return User._(this, _delegate.currentUser!);
    }

    return null;
  }

  /// The current Auth instance's language code.
  ///
  /// See [setLanguageCode] to update the language code.
  String? get languageCode {
    return _delegate.languageCode;
  }

  /// Changes this instance to point to an Auth emulator running locally.
  ///
  /// Set the [host] of the local emulator, such as "localhost"
  /// Set the [port] of the local emulator, such as "9099" (port 9099 is default for auth package)
  ///
  /// Note: Must be called immediately, prior to accessing auth methods.
  /// Do not use with production credentials as emulator traffic is not encrypted.
  Future<void> useAuthEmulator(String host, int port,
      {bool automaticHostMapping = true}) async {
    String mappedHost = automaticHostMapping ? getMappedHost(host) : host;

    await _delegate.useAuthEmulator(mappedHost, port);
  }

  /// The current Auth instance's tenant ID.
  String? get tenantId {
    return _delegate.tenantId;
  }

  /// Set the current Auth instance's tenant ID.
  ///
  /// When you set the tenant ID of an Auth instance, all future sign-in/sign-up
  /// operations will pass this tenant ID and sign in or sign up users to the
  /// specified tenant project. When set to null, users are signed in to the
  /// parent project. By default, this is set to `null`.
  set tenantId(String? tenantId) {
    _delegate.tenantId = tenantId;
  }

  /// The current Auth instance's custom auth domain.
  /// The auth domain used to handle redirects from OAuth provides, for example
  /// "my-awesome-app.firebaseapp.com". By default, this is set to `null` and
  /// default auth domain is used.
  ///
  /// If not `null`, this value will supersede `authDomain` property set in `initializeApp`.
  String? get customAuthDomain {
    return _delegate.customAuthDomain;
  }

  /// Set the current Auth instance's auth domain for apple and android platforms.
  /// The auth domain used to handle redirects from OAuth provides, for example
  /// "my-awesome-app.firebaseapp.com". By default, this is set to `null` and
  /// default auth domain is used.
  ///
  /// If not `null`, this value will supersede `authDomain` property set in `initializeApp`.
  set customAuthDomain(String? customAuthDomain) {
    // Web and windows do not support setting custom auth domains on the auth instance
    if (defaultTargetPlatform == TargetPlatform.windows || kIsWeb) {
      final message = defaultTargetPlatform == TargetPlatform.windows
          ? 'Cannot set custom auth domain on a FirebaseAuth instance for windows platform'
          : 'Cannot set custom auth domain on a FirebaseAuth instance. Set the custom auth domain on `FirebaseOptions.authDomain` instance and pass into `Firebase.initializeApp()` instead.';
      throw UnimplementedError(
        message,
      );
    }
    _delegate.customAuthDomain = customAuthDomain;
  }

  /// Applies a verification code sent to the user by email or other out-of-band
  /// mechanism.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if the action code has expired.
  /// - **invalid-action-code**:
  ///  - Thrown if the action code is invalid. This can happen if the code is
  ///    malformed or has already been used.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given action code has been
  ///    disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the action code. This may
  ///    have happened if the user was deleted between when the action code was
  ///    issued and when this method was called.
  Future<void> applyActionCode(String code) async {
    await _delegate.applyActionCode(code);
  }

  /// Checks a verification code sent to the user by email or other out-of-band
  /// mechanism.
  ///
  /// Returns [ActionCodeInfo] about the code.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if the action code has expired.
  /// - **invalid-action-code**:
  ///  - Thrown if the action code is invalid. This can happen if the code is
  ///    malformed or has already been used.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given action code has been
  ///    disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the action code. This may
  ///    have happened if the user was deleted between when the action code was
  ///    issued and when this method was called.
  Future<ActionCodeInfo> checkActionCode(String code) {
    return _delegate.checkActionCode(code);
  }

  /// Completes the password reset process, given a confirmation code and new
  /// password.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if the action code has expired.
  /// - **invalid-action-code**:
  ///  - Thrown if the action code is invalid. This can happen if the code is
  ///    malformed or has already been used.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given action code has been
  ///    disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the action code. This may
  ///    have happened if the user was deleted between when the action code was
  ///    issued and when this method was called.
  /// - **weak-password**:
  ///  - Thrown if the new password is not strong enough.
  Future<void> confirmPasswordReset({
    required String code,
    required String newPassword,
  }) async {
    await _delegate.confirmPasswordReset(code, newPassword);
  }

  /// Tries to create a new user account with the given email address and
  /// password.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **email-already-in-use**:
  ///  - Thrown if there already exists an account with the given email address.
  /// - **invalid-email**:
  ///  - Thrown if the email address is not valid.
  /// - **operation-not-allowed**:
  ///  - Thrown if email/password accounts are not enabled. Enable
  ///    email/password accounts in the Firebase Console, under the Auth tab.
  /// - **weak-password**:
  ///  - Thrown if the password is not strong enough.
  /// - **too-many-requests**:
  ///  - Thrown if the user sent too many requests at the same time, for security
  ///     the api will not allow too many attempts at the same time, user will have
  ///     to wait for some time
  /// - **user-token-expired**:
  ///  - Thrown if the user is no longer authenticated since his refresh token
  ///    has been expired
  /// - **network-request-failed**:
  ///  - Thrown if there was a network request error, for example the user
  ///    doesn't have internet connection
  /// - **operation-not-allowed**:
  ///  - Thrown if email/password accounts are not enabled. Enable
  ///    email/password accounts in the Firebase Console, under the Auth tab.
  Future<UserCredential> createUserWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    return UserCredential._(
      this,
      await _delegate.createUserWithEmailAndPassword(email, password),
    );
  }

  /// Returns a UserCredential from the redirect-based sign-in flow.
  ///
  /// If sign-in succeeded, returns the signed in user. If sign-in was
  /// unsuccessful, fails with an error. If no redirect operation was called,
  /// returns a [UserCredential] with a null User.
  ///
  /// This method is only support on web platforms.
  Future<UserCredential> getRedirectResult() async {
    return UserCredential._(this, await _delegate.getRedirectResult());
  }

  /// Checks if an incoming link is a sign-in with email link.
  bool isSignInWithEmailLink(String emailLink) {
    return _delegate.isSignInWithEmailLink(emailLink);
  }

  /// Internal helper which pipes internal [Stream] events onto
  /// a users own Stream.
  Stream<User?> _pipeStreamChanges(Stream<UserPlatform?> stream) {
    return stream.map((delegateUser) {
      if (delegateUser == null) {
        return null;
      }

      return User._(this, delegateUser);
    }).asBroadcastStream(onCancel: (sub) => sub.cancel());
  }

  /// Notifies about changes to the user's sign-in state (such as sign-in or
  /// sign-out).
  Stream<User?> authStateChanges() =>
      _pipeStreamChanges(_delegate.authStateChanges());

  /// Notifies about changes to the user's sign-in state (such as sign-in or
  /// sign-out) and also token refresh events.
  Stream<User?> idTokenChanges() =>
      _pipeStreamChanges(_delegate.idTokenChanges());

  /// Notifies about changes to any user updates.
  ///
  /// This is a superset of both [authStateChanges] and [idTokenChanges]. It
  /// provides events on all user changes, such as when credentials are linked,
  /// unlinked and when updates to the user profile are made. The purpose of
  /// this Stream is for listening to realtime updates to the user state
  /// (signed-in, signed-out, different user & token refresh) without
  /// manually having to call [reload] and then rehydrating changes to your
  /// application.
  Stream<User?> userChanges() => _pipeStreamChanges(_delegate.userChanges());

  /// Sends a password reset email to the given email address.
  ///
  /// To complete the password reset, call [confirmPasswordReset] with the code supplied
  /// in the email sent to the user, along with the new password specified by the user.
  ///
  /// May throw a [FirebaseAuthException] with the following error codes:
  ///
  /// - **auth/invalid-email**\
  ///   Thrown if the email address is not valid.
  /// - **auth/missing-android-pkg-name**\
  ///   An Android package name must be provided if the Android app is required to be installed.
  /// - **auth/missing-continue-uri**\
  ///   A continue URL must be provided in the request.
  /// - **auth/missing-ios-bundle-id**\
  ///   An iOS Bundle ID must be provided if an App Store ID is provided.
  /// - **auth/invalid-continue-uri**\
  ///   The continue URL provided in the request is invalid.
  /// - **auth/unauthorized-continue-uri**\
  ///   The domain of the continue URL is not whitelisted. Whitelist the domain in the Firebase console.
  /// - **auth/user-not-found**\
  ///   Thrown if there is no user corresponding to the email address. Note: This exception is no longer thrown when enabling email enumeration protection.
  Future<void> sendPasswordResetEmail({
    required String email,
    ActionCodeSettings? actionCodeSettings,
  }) {
    return _delegate.sendPasswordResetEmail(email, actionCodeSettings);
  }

  /// Sends a sign in with email link to provided email address.
  ///
  /// To complete the password reset, call [confirmPasswordReset] with the code
  /// supplied in the email sent to the user, along with the new password
  /// specified by the user.
  ///
  /// The [handleCodeInApp] of [actionCodeSettings] must be set to `true`
  /// otherwise an [ArgumentError] will be thrown.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **invalid-email**:
  ///  - Thrown if the email address is not valid.
  Future<void> sendSignInLinkToEmail({
    required String email,
    required ActionCodeSettings actionCodeSettings,
  }) async {
    if (actionCodeSettings.handleCodeInApp != true) {
      throw ArgumentError(
        'The [handleCodeInApp] value of [ActionCodeSettings] must be `true`.',
      );
    }

    await _delegate.sendSignInLinkToEmail(email, actionCodeSettings);
  }

  /// When set to null, sets the user-facing language code to be the default app language.
  ///
  /// The language code will propagate to email action templates (password
  /// reset, email verification and email change revocation), SMS templates for
  /// phone authentication, reCAPTCHA verifier and OAuth popup/redirect
  /// operations provided the specified providers support localization with the
  /// language code specified.
  Future<void> setLanguageCode(String? languageCode) {
    return _delegate.setLanguageCode(languageCode);
  }

  /// Updates the current instance with the provided settings.
  ///
  /// [appVerificationDisabledForTesting] This setting applies to Android, iOS and
  ///   web platforms. When set to `true`, this property disables app
  ///   verification for the purpose of testing phone authentication. For this
  ///   property to take effect, it needs to be set before handling a reCAPTCHA
  ///   app verifier. When this is disabled, a mock reCAPTCHA is rendered
  ///   instead. This is useful for manual testing during development or for
  ///   automated integration tests.
  ///
  ///   In order to use this feature, you will need to
  ///   [whitelist your phone number](https://firebase.google.com/docs/auth/web/phone-auth?authuser=0#test-with-whitelisted-phone-numbers)
  ///   via the Firebase Console.
  ///
  ///   The default value is `false` (app verification is enabled).
  ///
  /// [forceRecaptchaFlow] This setting applies to Android only. When set to 'true',
  ///   it forces the application verification to use the web reCAPTCHA flow for Phone Authentication.
  ///   Once this has been called, every call to PhoneAuthProvider#verifyPhoneNumber() will skip the SafetyNet verification flow and use the reCAPTCHA flow instead.
  ///   Calling this method a second time will overwrite the previously passed parameter.
  ///
  /// [phoneNumber] & [smsCode] These settings apply to Android only. The phone number and SMS code here must have been configured in the Firebase Console (Authentication > Sign In Method > Phone).
  ///   Once this has been called, every call to PhoneAuthProvider#verifyPhoneNumber() with the same phone number as the one that is configured here will have onVerificationCompleted() triggered as the callback.
  ///   Calling this method a second time will overwrite the previously passed parameters. Only one number can be configured at a given time.
  ///   Calling this method with either parameter set to null removes this functionality until valid parameters are passed.
  ///   Verifying a phone number other than the one configured here will trigger normal behavior. If the phone number is configured as a test phone number in the console, the regular testing flow occurs. Otherwise, normal phone number verification will take place.
  ///   When this is set and PhoneAuthProvider#verifyPhoneNumber() is called with a matching phone number, PhoneAuthProvider.OnVerificationStateChangedCallbacks.onCodeAutoRetrievalTimeOut(String) will never be called.
  ///
  /// [userAccessGroup] This setting only applies to iOS and MacOS platforms.
  ///   When set, it allows you to share authentication state between
  ///   applications. Set the property to your team group ID or set to `null`
  ///   to remove sharing capabilities.
  ///
  ///   Key Sharing capabilities must be enabled for your app via XCode (Project
  ///   settings > Capabilities). To learn more, visit the
  ///   [Apple documentation](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps).
  Future<void> setSettings({
    bool appVerificationDisabledForTesting = false,
    String? userAccessGroup,
    String? phoneNumber,
    String? smsCode,
    bool? forceRecaptchaFlow,
  }) {
    return _delegate.setSettings(
      appVerificationDisabledForTesting: appVerificationDisabledForTesting,
      userAccessGroup: userAccessGroup,
      phoneNumber: phoneNumber,
      smsCode: smsCode,
      forceRecaptchaFlow: forceRecaptchaFlow,
    );
  }

  /// Changes the current type of persistence on the current Auth instance for
  /// the currently saved Auth session and applies this type of persistence for
  /// future sign-in requests, including sign-in with redirect requests.
  ///
  /// This will return a promise that will resolve once the state finishes
  /// copying from one type of storage to the other. Calling a sign-in method
  /// after changing persistence will wait for that persistence change to
  /// complete before applying it on the new Auth state.
  ///
  /// This makes it easy for a user signing in to specify whether their session
  /// should be remembered or not. It also makes it easier to never persist the
  /// Auth state for applications that are shared by other users or have
  /// sensitive data.
  ///
  /// This is only supported on web based platforms.
  Future<void> setPersistence(Persistence persistence) async {
    return _delegate.setPersistence(persistence);
  }

  /// Asynchronously creates and becomes an anonymous user.
  ///
  /// If there is already an anonymous user signed in, that user will be
  /// returned instead. If there is any other existing user signed in, that
  /// user will be signed out.
  ///
  /// **Important**: You must enable Anonymous accounts in the Auth section
  /// of the Firebase console before being able to use them.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **operation-not-allowed**:
  ///  - Thrown if anonymous accounts are not enabled. Enable anonymous accounts
  /// in the Firebase Console, under the Auth tab.
  Future<UserCredential> signInAnonymously() async {
    return UserCredential._(this, await _delegate.signInAnonymously());
  }

  /// Asynchronously signs in to Firebase with the given 3rd-party credentials
  /// (e.g. a Facebook login Access Token, a Google ID Token/Access Token pair,
  /// etc.) and returns additional identity provider data.
  ///
  /// If successful, it also signs the user in into the app and updates
  /// any [authStateChanges], [idTokenChanges] or [userChanges] stream
  /// listeners.
  ///
  /// If the user doesn't have an account already, one will be created
  /// automatically.
  ///
  /// **Important**: You must enable the relevant accounts in the Auth section
  /// of the Firebase console before being able to use them.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **account-exists-with-different-credential**:
  ///  - Thrown if there already exists an account with the email address
  ///    asserted by the credential.
  // ignore: deprecated_member_use_from_same_package
  ///    Resolve this by asking
  ///    the user to sign in using one of the returned providers.
  ///    Once the user is signed in, the original credential can be linked to
  ///    the user with [linkWithCredential].
  /// - **invalid-credential**:
  ///  - Thrown if the credential is malformed or has expired.
  /// - **operation-not-allowed**:
  ///  - Thrown if the type of account corresponding to the credential is not
  ///    enabled. Enable the account type in the Firebase Console, under the
  ///    Auth tab.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given credential has been
  ///    disabled.
  /// - **user-not-found**:
  ///  - Thrown if signing in with a credential from [EmailAuthProvider.credential]
  ///    and there is no user corresponding to the given email.
  /// - **wrong-password**:
  ///  - Thrown if signing in with a credential from [EmailAuthProvider.credential]
  ///    and the password is invalid for the given email, or if the account
  ///    corresponding to the email does not have a password set.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> signInWithCredential(AuthCredential credential) async {
    try {
      return UserCredential._(
        this,
        await _delegate.signInWithCredential(credential),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Tries to sign in a user with a given custom token.
  ///
  /// Custom tokens are used to integrate Firebase Auth with existing auth
  /// systems, and must be generated by the auth backend.
  ///
  /// If successful, it also signs the user in into the app and updates
  /// any [authStateChanges], [idTokenChanges] or [userChanges] stream
  /// listeners.
  ///
  /// If the user identified by the [uid] specified in the token doesn't
  /// have an account already, one will be created automatically.
  ///
  /// Read how to use Custom Token authentication and the cases where it is
  /// useful in [the guides](https://firebase.google.com/docs/auth/android/custom-auth).
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **custom-token-mismatch**:
  ///  - Thrown if the custom token is for a different Firebase App.
  /// - **invalid-custom-token**:
  ///  - Thrown if the custom token format is incorrect.
  Future<UserCredential> signInWithCustomToken(String token) async {
    try {
      return UserCredential._(
          this, await _delegate.signInWithCustomToken(token));
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Attempts to sign in a user with the given email address and password.
  ///
  /// If successful, it also signs the user in into the app and updates
  /// any [authStateChanges], [idTokenChanges] or [userChanges] stream
  /// listeners.
  ///
  /// **Important**: You must enable Email & Password accounts in the Auth
  /// section of the Firebase console before being able to use them.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **invalid-email**:
  ///  - Thrown if the email address is not valid.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given email has been disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the given email.
  /// - **wrong-password**:
  ///  - Thrown if the password is invalid for the given email, or the account
  ///    corresponding to the email does not have a password set.
  /// - **too-many-requests**:
  ///  - Thrown if the user sent too many requests at the same time, for security
  ///     the api will not allow too many attempts at the same time, user will have
  ///     to wait for some time
  /// - **user-token-expired**:
  ///  - Thrown if the user is no longer authenticated since his refresh token
  ///    has been expired
  /// - **network-request-failed**:
  ///  - Thrown if there was a network request error, for example the user
  ///    doesn't have internet connection
  /// - **INVALID_LOGIN_CREDENTIALS** or **invalid-credential**:
  ///  - Thrown if the password is invalid for the given email, or the account
  ///    corresponding to the email does not have a password set.
  ///    Depending on if you are using firebase emulator or not the code is
  ///    different
  /// - **operation-not-allowed**:
  ///  - Thrown if email/password accounts are not enabled. Enable
  ///    email/password accounts in the Firebase Console, under the Auth tab.
  Future<UserCredential> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      return UserCredential._(
        this,
        await _delegate.signInWithEmailAndPassword(email, password),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Signs in using an email address and email sign-in link.
  ///
  /// Fails with an error if the email address is invalid or OTP in email link
  /// expires.
  ///
  /// Confirm the link is a sign-in email link before calling this method,
  /// using [isSignInWithEmailLink].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if OTP in email link expires.
  /// - **invalid-email**:
  ///  - Thrown if the email address is not valid.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given email has been disabled.
  Future<UserCredential> signInWithEmailLink({
    required String email,
    required String emailLink,
  }) async {
    try {
      return UserCredential._(
        this,
        await _delegate.signInWithEmailLink(email, emailLink),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Signs in with an AuthProvider using native authentication flow.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given email has been disabled.
  Future<UserCredential> signInWithProvider(
    AuthProvider provider,
  ) async {
    try {
      return UserCredential._(
        this,
        await _delegate.signInWithProvider(provider),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Starts a sign-in flow for a phone number.
  ///
  /// You can optionally provide a [RecaptchaVerifier] instance to control the
  /// reCAPTCHA widget appearance and behavior.
  ///
  /// Once the reCAPTCHA verification has completed, called [ConfirmationResult.confirm]
  /// with the users SMS verification code to complete the authentication flow.
  ///
  /// This method is only available on web based platforms.
  Future<ConfirmationResult> signInWithPhoneNumber(
    String phoneNumber, [
    RecaptchaVerifier? verifier,
  ]) async {
    assert(phoneNumber.isNotEmpty);
    // If we add a recaptcha to the page by creating a new instance, we must
    // also clear that instance before proceeding.
    bool mustClear = verifier == null;
    verifier ??= RecaptchaVerifier(auth: _delegate);
    final result =
        await _delegate.signInWithPhoneNumber(phoneNumber, verifier.delegate);
    if (mustClear) {
      verifier.clear();
    }
    return ConfirmationResult._(this, result);
  }

  /// Authenticates a Firebase client using a popup-based OAuth authentication
  /// flow.
  ///
  /// If succeeds, returns the signed in user along with the provider's
  /// credential.
  ///
  /// This method is only available on web based platforms.
  Future<UserCredential> signInWithPopup(AuthProvider provider) async {
    try {
      return UserCredential._(this, await _delegate.signInWithPopup(provider));
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Authenticates a Firebase client using a full-page redirect flow.
  ///
  /// To handle the results and errors for this operation, refer to
  /// [getRedirectResult].
  Future<void> signInWithRedirect(AuthProvider provider) {
    try {
      return _delegate.signInWithRedirect(provider);
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(this, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Checks a password reset code sent to the user by email or other
  /// out-of-band mechanism.
  ///
  /// Returns the user's email address if valid.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **expired-action-code**:
  ///  - Thrown if the password reset code has expired.
  /// - **invalid-action-code**:
  ///  - Thrown if the password reset code is invalid. This can happen if the
  ///    code is malformed or has already been used.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given email has been disabled.
  /// - **user-not-found**:
  ///  - Thrown if there is no user corresponding to the password reset code.
  ///    This may have happened if the user was deleted between when the code
  ///    was issued and when this method was called.
  Future<String> verifyPasswordResetCode(String code) {
    return _delegate.verifyPasswordResetCode(code);
  }

  /// Starts a phone number verification process for the given phone number.
  ///
  /// This method is used to verify that the user-provided phone number belongs
  /// to the user. Firebase sends a code via SMS message to the phone number,
  /// where you must then prompt the user to enter the code. The code can be
  /// combined with the verification ID to create a [PhoneAuthProvider.credential]
  /// which you can then use to sign the user in, or link with their account (
  /// see [signInWithCredential] or [linkWithCredential]).
  ///
  /// On some Android devices, auto-verification can be handled by the device
  /// and a [PhoneAuthCredential] will be automatically provided.
  ///
  /// No duplicated SMS will be sent out unless a [forceResendingToken] is
  /// provided.
  ///
  /// [phoneNumber] The phone number for the account the user is signing up
  ///   for or signing into. Make sure to pass in a phone number with country
  ///   code prefixed with plus sign ('+').
  ///   Should be null if it's a multi-factor sign in.
  ///
  /// [multiFactorInfo] The multi factor info you're using to verify the phone number.
  ///   Should be set if a [multiFactorSession] is provided.
  ///
  /// [multiFactorSession] The multi factor session you're using to verify the phone number.
  ///   Should be set if a [multiFactorInfo] is provided.
  ///
  /// [timeout] The maximum amount of time you are willing to wait for SMS
  ///   auto-retrieval to be completed by the library. Maximum allowed value
  ///   is 2 minutes.
  ///
  /// [forceResendingToken] The [forceResendingToken] obtained from [codeSent]
  ///   callback to force re-sending another verification SMS before the
  ///   auto-retrieval timeout.
  ///
  /// [verificationCompleted] Triggered when an SMS is auto-retrieved or the
  ///   phone number has been instantly verified. The callback will receive an
  ///   [PhoneAuthCredential] that can be passed to [signInWithCredential] or
  ///   [linkWithCredential].
  ///
  /// [verificationFailed] Triggered when an error occurred during phone number
  ///   verification. A [FirebaseAuthException] is provided when this is
  ///   triggered.
  ///
  /// [codeSent] Triggered when an SMS has been sent to the users phone, and
  ///   will include a [verificationId] and [forceResendingToken].
  ///
  /// [codeAutoRetrievalTimeout] Triggered when SMS auto-retrieval times out and
  ///   provide a [verificationId].
  Future<void> verifyPhoneNumber({
    String? phoneNumber,
    PhoneMultiFactorInfo? multiFactorInfo,
    required PhoneVerificationCompleted verificationCompleted,
    required PhoneVerificationFailed verificationFailed,
    required PhoneCodeSent codeSent,
    required PhoneCodeAutoRetrievalTimeout codeAutoRetrievalTimeout,
    @visibleForTesting String? autoRetrievedSmsCodeForTesting,
    Duration timeout = const Duration(seconds: 30),
    int? forceResendingToken,
    MultiFactorSession? multiFactorSession,
  }) {
    assert(
      phoneNumber != null || multiFactorInfo != null,
      'Either phoneNumber or multiFactorInfo must be provided.',
    );
    return _delegate.verifyPhoneNumber(
      phoneNumber: phoneNumber,
      multiFactorInfo: multiFactorInfo,
      timeout: timeout,
      forceResendingToken: forceResendingToken,
      verificationCompleted: verificationCompleted,
      verificationFailed: verificationFailed,
      codeSent: codeSent,
      codeAutoRetrievalTimeout: codeAutoRetrievalTimeout,
      // ignore: invalid_use_of_visible_for_testing_member
      autoRetrievedSmsCodeForTesting: autoRetrievedSmsCodeForTesting,
      multiFactorSession: multiFactorSession,
    );
  }

  /// Apple only. Users signed in with Apple provider can revoke their token using an authorization code.
  /// Authorization code can be retrieved on the user credential i.e. userCredential.additionalUserInfo.authorizationCode
  Future<void> revokeTokenWithAuthorizationCode(String authorizationCode) {
    return _delegate.revokeTokenWithAuthorizationCode(authorizationCode);
  }

  /// Signs out the current user.
  ///
  /// If successful, it also updates
  /// any [authStateChanges], [idTokenChanges] or [userChanges] stream
  /// listeners.
  Future<void> signOut() async {
    await _delegate.signOut();
  }

  /// Initializes the reCAPTCHA Enterprise client proactively to enhance reCAPTCHA signal collection and
  /// to complete reCAPTCHA-protected flows in a single attempt.
  Future<void> initializeRecaptchaConfig() {
    return _delegate.initializeRecaptchaConfig();
  }

  /// Validates a password against the password policy configured for the project or tenant.
  ///
  /// If no tenant ID is set on the Auth instance, then this method will use the password policy configured for the project.
  /// Otherwise, this method will use the policy configured for the tenant. If a password policy has not been configured,
  /// then the default policy configured for all projects will be used.
  ///
  /// If an auth flow fails because a submitted password does not meet the password policy requirements and this method has previously been called,
  /// then this method will use the most recent policy available when called again.
  ///
  /// Returns a map with the following keys:
  /// - **status**: A boolean indicating if the password is valid.
  /// - **passwordPolicy**: The password policy used to validate the password.
  /// - **meetsMinPasswordLength**: A boolean indicating if the password meets the minimum length requirement.
  /// - **meetsMaxPasswordLength**: A boolean indicating if the password meets the maximum length requirement.
  /// - **meetsLowercaseRequirement**: A boolean indicating if the password meets the lowercase requirement.
  /// - **meetsUppercaseRequirement**: A boolean indicating if the password meets the uppercase requirement.
  /// - **meetsDigitsRequirement**: A boolean indicating if the password meets the digits requirement.
  /// - **meetsSymbolsRequirement**: A boolean indicating if the password meets the symbols requirement.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **invalid-password**:
  ///  - Thrown if the password is invalid.
  /// - **network-request-failed**:
  ///  - Thrown if there was a network request error, for example the user
  ///    doesn't have internet connection
  /// - **INVALID_LOGIN_CREDENTIALS** or **invalid-credential**:
  ///  - Thrown if the password is invalid for the given email, or the account
  ///    corresponding to the email does not have a password set.
  ///    Depending on if you are using firebase emulator or not the code is
  ///    different
  /// - **operation-not-allowed**:
  ///  - Thrown if email/password accounts are not enabled. Enable
  ///    email/password accounts in the Firebase Console, under the Auth tab.
  Future<PasswordValidationStatus> validatePassword(
    FirebaseAuth auth,
    String? password,
  ) async {
    if (password == null || password.isEmpty) {
      throw FirebaseAuthException(
        code: 'invalid-password',
        message: 'Password cannot be null or empty',
      );
    }
    PasswordPolicyApi passwordPolicyApi =
        PasswordPolicyApi(auth.app.options.apiKey);
    PasswordPolicy passwordPolicy =
        await passwordPolicyApi.fetchPasswordPolicy();
    PasswordPolicyImpl passwordPolicyImpl = PasswordPolicyImpl(passwordPolicy);
    return passwordPolicyImpl.isPasswordValid(password);
  }

  @override
  String toString() {
    return 'FirebaseAuth(app: ${app.name})';
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\lib\src\multi_factor.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../firebase_auth.dart';

/// Defines multi-factor related properties and operations pertaining to a [User].
/// This class acts as the main entry point for enrolling or un-enrolling
/// second factors for a user, and provides access to their currently enrolled factors.
class MultiFactor {
  MultiFactorPlatform _delegate;

  MultiFactor._(this._delegate);

  /// Returns a session identifier for a second factor enrollment operation.
  Future<MultiFactorSession> getSession() {
    return _delegate.getSession();
  }

  /// Enrolls a second factor as identified by the [MultiFactorAssertion] parameter for the current user.
  ///
  /// [displayName] can be used to provide a display name for the second factor.
  Future<void> enroll(
    MultiFactorAssertion assertion, {
    String? displayName,
  }) async {
    if (assertion._delegate is TotpMultiFactorGeneratorPlatform) {
      assert(displayName != null, 'displayName is mandatory for TOTP');
    }
    return _delegate.enroll(assertion._delegate, displayName: displayName);
  }

  /// Unenrolls a second factor from this user.
  ///
  /// [factorUid] is the unique identifier of the second factor to unenroll.
  /// [multiFactorInfo] is the [MultiFactorInfo] of the second factor to unenroll.
  /// Only one of [factorUid] or [multiFactorInfo] should be provided.
  Future<void> unenroll({String? factorUid, MultiFactorInfo? multiFactorInfo}) {
    assert(
      (factorUid != null && multiFactorInfo == null) ||
          (factorUid == null && multiFactorInfo != null),
      'Exactly one of `factorUid` or `multiFactorInfo` must be provided',
    );
    return _delegate.unenroll(
      factorUid: factorUid,
      multiFactorInfo: multiFactorInfo,
    );
  }

  /// Returns a list of the [MultiFactorInfo] already associated with this user.
  Future<List<MultiFactorInfo>> getEnrolledFactors() {
    return _delegate.getEnrolledFactors();
  }
}

/// Provider for generating a PhoneMultiFactorAssertion.
class PhoneMultiFactorGenerator {
  /// Transforms a PhoneAuthCredential into a [MultiFactorAssertion]
  /// which can be used to confirm ownership of a phone second factor.
  static MultiFactorAssertion getAssertion(
    PhoneAuthCredential credential,
  ) {
    final assertion =
        PhoneMultiFactorGeneratorPlatform.instance.getAssertion(credential);
    return MultiFactorAssertion._(assertion);
  }
}

/// Provider for generating a PhoneMultiFactorAssertion.
class TotpMultiFactorGenerator {
  /// Transforms a PhoneAuthCredential into a [MultiFactorAssertion]
  /// which can be used to confirm ownership of a phone second factor.
  static Future<TotpSecret> generateSecret(
    MultiFactorSession session,
  ) async {
    final secret =
        await TotpMultiFactorGeneratorPlatform.instance.generateSecret(session);
    return TotpSecret._(
      secret.codeIntervalSeconds,
      secret.codeLength,
      secret.enrollmentCompletionDeadline,
      secret.hashingAlgorithm,
      secret.secretKey,
      secret,
    );
  }

  /// Get a [MultiFactorAssertion]
  /// which can be used to confirm ownership of a TOTP second factor.
  static Future<MultiFactorAssertion> getAssertionForEnrollment(
    TotpSecret secret,
    String oneTimePassword,
  ) async {
    final assertion = await TotpMultiFactorGeneratorPlatform.instance
        .getAssertionForEnrollment(
      secret._instance,
      oneTimePassword,
    );

    return MultiFactorAssertion._(assertion);
  }

  /// Get a [MultiFactorAssertion]
  /// which can be used to confirm ownership of a TOTP second factor.
  static Future<MultiFactorAssertion> getAssertionForSignIn(
    String enrollmentId,
    String oneTimePassword,
  ) async {
    final assertion =
        await TotpMultiFactorGeneratorPlatform.instance.getAssertionForSignIn(
      enrollmentId,
      oneTimePassword,
    );

    return MultiFactorAssertion._(assertion);
  }
}

class TotpSecret {
  final TotpSecretPlatform _instance;

  final int? codeIntervalSeconds;
  final int? codeLength;
  final DateTime? enrollmentCompletionDeadline;
  final String? hashingAlgorithm;
  final String secretKey;

  TotpSecret._(
    this.codeIntervalSeconds,
    this.codeLength,
    this.enrollmentCompletionDeadline,
    this.hashingAlgorithm,
    this.secretKey,
    this._instance,
  );

  /// Generate a TOTP secret for the authenticated user.
  Future<String> generateQrCodeUrl({
    String? accountName,
    String? issuer,
  }) {
    return _instance.generateQrCodeUrl(
      accountName: accountName,
      issuer: issuer,
    );
  }

  /// Opens the specified QR Code URL in a password manager like iCloud Keychain.
  Future<void> openInOtpApp(
    String qrCodeUrl,
  ) async {
    await _instance.openInOtpApp(
      qrCodeUrl,
    );
  }
}

/// Represents an assertion that the Firebase Authentication server
/// can use to authenticate a user as part of a multi-factor flow.
class MultiFactorAssertion {
  final MultiFactorAssertionPlatform _delegate;

  MultiFactorAssertion._(this._delegate) {
    MultiFactorAssertionPlatform.verify(_delegate);
  }
}

/// Utility class that contains methods to resolve second factor
/// requirements on users that have opted into two-factor authentication.
class MultiFactorResolver {
  final FirebaseAuth _auth;
  final MultiFactorResolverPlatform _delegate;

  MultiFactorResolver._(this._auth, this._delegate) {
    MultiFactorResolverPlatform.verify(_delegate);
  }

  /// List of [MultiFactorInfo] which represents the available
  /// second factors that can be used to complete the sign-in for the current session.
  List<MultiFactorInfo> get hints => _delegate.hints;

  /// A MultiFactorSession, an opaque session identifier for the current sign-in flow.
  MultiFactorSession get session => _delegate.session;

  /// Completes sign in with a second factor using an MultiFactorAssertion which
  /// confirms that the user has successfully completed the second factor challenge.
  Future<UserCredential> resolveSignIn(
    MultiFactorAssertion assertion,
  ) async {
    final credential = await _delegate.resolveSignIn(assertion._delegate);
    return UserCredential._(_auth, credential);
  }
}

/// MultiFactor exception related to Firebase Authentication. Check the error code
/// and message for more details.
class FirebaseAuthMultiFactorException extends FirebaseAuthException {
  final FirebaseAuth _auth;
  final FirebaseAuthMultiFactorExceptionPlatform _delegate;

  FirebaseAuthMultiFactorException._(this._auth, this._delegate)
      : super(
          code: _delegate.code,
          message: _delegate.message,
          email: _delegate.email,
          credential: _delegate.credential,
          phoneNumber: _delegate.phoneNumber,
          tenantId: _delegate.tenantId,
        );

  MultiFactorResolver get resolver =>
      MultiFactorResolver._(_auth, _delegate.resolver);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\lib\src\recaptcha_verifier.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// An [reCAPTCHA](https://www.google.com/recaptcha/?authuser=0)-based
/// application verifier.
class RecaptchaVerifier {
  static final RecaptchaVerifierFactoryPlatform _factory =
      RecaptchaVerifierFactoryPlatform.instance;

  RecaptchaVerifier._(this._delegate);

  RecaptchaVerifierFactoryPlatform _delegate;

  /// Creates a new [RecaptchaVerifier] instance used to render a reCAPTCHA widget
  /// when calling [signInWithPhoneNumber].
  ///
  /// It is possible to configure the reCAPTCHA widget with the following arguments,
  /// however if no arguments are provided, an "invisible" reCAPTCHA widget with
  /// defaults will be created.
  ///
  /// [container] If a value is provided, the element must exist in the DOM when
  ///   [render] or [signInWithPhoneNumber] is called. The reCAPTCHA widget will
  ///   be rendered within the specified DOM element.
  ///
  ///   If no value is provided, an "invisible" reCAPTCHA will be shown when [render]
  ///   is called. An invisible reCAPTCHA widget is shown a modal on-top of your
  ///   application.
  ///
  /// [size] When providing a custom [container], a size (normal or compact) can
  ///   be provided to change the size of the reCAPTCHA widget. This has no effect
  ///    when a [container] is not provided. Defaults to [RecaptchaVerifierSize.normal].
  ///
  /// [theme] When providing a custom [container], a theme (light or dark) can
  ///   be provided to change the appearance of the reCAPTCHA widget. This has no
  ///   effect when a [container] is not provided. Defaults to [RecaptchaVerifierTheme.light].
  ///
  /// [onSuccess] An optional callback which is called when the user successfully
  ///   completes the reCAPTCHA widget.
  ///
  /// [onError] An optional callback which is called when the reCAPTCHA widget errors
  ///   (such as a network issue).
  ///
  /// [onExpired] An optional callback which is called when the reCAPTCHA expires.
  factory RecaptchaVerifier({
    required FirebaseAuthPlatform auth,
    String? container,
    RecaptchaVerifierSize size = RecaptchaVerifierSize.normal,
    RecaptchaVerifierTheme theme = RecaptchaVerifierTheme.light,
    RecaptchaVerifierOnSuccess? onSuccess,
    RecaptchaVerifierOnError? onError,
    RecaptchaVerifierOnExpired? onExpired,
  }) {
    return RecaptchaVerifier._(
      _factory.delegateFor(
        auth: auth,
        container: container,
        size: size,
        theme: theme,
        onSuccess: onSuccess,
        onError: onError,
        onExpired: onExpired,
      ),
    );
  }

  /// Returns the underlying factory delegate instance.
  @protected
  RecaptchaVerifierFactoryPlatform get delegate {
    return _delegate;
  }

  /// The application verifier type. For a reCAPTCHA verifier, this is
  /// 'recaptcha'.
  String get type {
    return _delegate.type;
  }

  /// Clears the reCAPTCHA widget from the page and destroys the current
  /// instance.
  void clear() {
    return _delegate.clear();
  }

  /// Renders the reCAPTCHA widget on the page.
  ///
  /// Returns a [Future] that resolves with the reCAPTCHA widget ID.
  Future<int> render() async {
    return _delegate.render();
  }

  /// Waits for the user to solve the reCAPTCHA and resolves with the reCAPTCHA
  /// token.
  Future<String> verify() async {
    return _delegate.verify();
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\lib\src\user.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// A user account.
class User {
  UserPlatform _delegate;

  final FirebaseAuth _auth;
  MultiFactor? _multiFactor;

  User._(this._auth, this._delegate) {
    UserPlatform.verify(_delegate);
  }

  /// The users display name.
  ///
  /// Will be `null` if signing in anonymously or via password authentication.
  String? get displayName {
    return _delegate.displayName;
  }

  /// The users email address.
  ///
  /// Will be `null` if signing in anonymously.
  String? get email {
    return _delegate.email;
  }

  /// Returns whether the users email address has been verified.
  ///
  /// To send a verification email, see [sendEmailVerification].
  ///
  /// Once verified, call [reload] to ensure the latest user information is
  /// retrieved from Firebase.
  bool get emailVerified {
    return _delegate.isEmailVerified;
  }

  /// Returns whether the user is a anonymous.
  bool get isAnonymous {
    return _delegate.isAnonymous;
  }

  /// Returns additional metadata about the user, such as their creation time.
  UserMetadata get metadata {
    return _delegate.metadata;
  }

  /// Returns the users phone number.
  ///
  /// This property will be `null` if the user has not signed in or been has
  /// their phone number linked.
  String? get phoneNumber {
    return _delegate.phoneNumber;
  }

  /// Returns a photo URL for the user.
  ///
  /// This property will be populated if the user has signed in or been linked
  /// with a 3rd party OAuth provider (such as Google).
  String? get photoURL {
    return _delegate.photoURL;
  }

  /// Returns a list of user information for each linked provider.
  List<UserInfo> get providerData {
    return _delegate.providerData;
  }

  /// Returns a JWT refresh token for the user.
  ///
  /// This property will be an empty string for native platforms (android, iOS & macOS) as they do not
  /// support refresh tokens.
  String? get refreshToken {
    return _delegate.refreshToken;
  }

  /// The current user's tenant ID.
  ///
  /// This is a read-only property, which indicates the tenant ID used to sign
  /// in the current user. This is `null` if the user is signed in from the
  /// parent project.
  String? get tenantId {
    return _delegate.tenantId;
  }

  /// The user's unique ID.
  String get uid {
    return _delegate.uid;
  }

  /// Deletes and signs out the user.
  ///
  /// **Important**: this is a security-sensitive operation that requires the
  /// user to have recently signed in. If this requirement isn't met, ask the
  /// user to authenticate again and then call [User.reauthenticateWithCredential].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **requires-recent-login**:
  ///  - Thrown if the user's last sign-in time does not meet the security
  ///    threshold. Use [User.reauthenticateWithCredential] to resolve. This
  ///    does not apply if the user is anonymous.
  Future<void> delete() async {
    return _delegate.delete();
  }

  /// Returns a JSON Web Token (JWT) used to identify the user to a Firebase
  /// service.
  ///
  /// Returns the current token if it has not expired. Otherwise, this will
  /// refresh the token and return a new one.
  ///
  /// If [forceRefresh] is `true`, the token returned will be refreshed regardless
  /// of token expiration.
  Future<String?> getIdToken([bool forceRefresh = false]) {
    return _delegate.getIdToken(forceRefresh);
  }

  /// Returns a [IdTokenResult] containing the users JSON Web Token (JWT) and
  /// other metadata.
  ///
  /// Returns the current token if it has not expired. Otherwise, this will
  /// refresh the token and return a new one.
  ///
  /// If [forceRefresh] is `true`, the token returned will be refreshed regardless
  /// of token expiration.
  Future<IdTokenResult> getIdTokenResult([bool forceRefresh = false]) {
    return _delegate.getIdTokenResult(forceRefresh);
  }

  /// Links the user account with the given credentials.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the credential already exists
  ///    among your users, or is already linked to a Firebase User. For example,
  ///    this error could be thrown if you are upgrading an anonymous user to a
  ///    Google user by linking a Google credential to it and the Google
  ///    credential used is already associated with an existing Firebase Google
  ///    user. The fields `email`, `phoneNumber`, and `credential`
  ///    ([AuthCredential]) may be provided, depending on the type of
  ///    credential. You can recover from this error by signing in with
  ///    `credential` directly via [signInWithCredential]. Please note, you will
  ///    not recover from this error if you're using a [PhoneAuthCredential] to link
  ///    a provider to an account. Once an attempt to link an account has been made,
  ///    a new sms code is required to sign in the user.
  /// - **email-already-in-use**:
  ///  - Thrown if the email corresponding to the credential already exists
  ///    among your users. When thrown while linking a credential to an existing
  ///    user, an `email` and `credential` ([AuthCredential]) fields are also
  ///    provided. You have to link the credential to the existing user with
  ///    that email if you wish to continue signing in with that credential. To
  ///    do so, sign in to `email` via one of
  ///    the providers returned and then [User.linkWithCredential] the original
  ///    credential to that newly signed in user.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the provider in the Firebase Console. Go
  ///    to the Firebase Console for your project, in the Auth section and the
  ///    Sign in Method tab and configure the provider.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **invalid-email**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> linkWithCredential(AuthCredential credential) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.linkWithCredential(credential),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Links with an AuthProvider using native authentication flow.
  /// On web, you should use [linkWithPopup] or [linkWithRedirect] instead.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the credential already exists
  ///    among your users, or is already linked to a Firebase User. For example,
  ///    this error could be thrown if you are upgrading an anonymous user to a
  ///    Google user by linking a Google credential to it and the Google
  ///    credential used is already associated with an existing Firebase Google
  ///    user. The fields `email`, `phoneNumber`, and `credential`
  ///    ([AuthCredential]) may be provided, depending on the type of
  ///    credential. You can recover from this error by signing in with
  ///    `credential` directly via [signInWithCredential].
  /// - **email-already-in-use**:
  ///  - Thrown if the email corresponding to the credential already exists
  ///    among your users. When thrown while linking a credential to an existing
  ///    user, an `email` and `credential` ([AuthCredential]) fields are also
  ///    provided. You have to link the credential to the existing user with
  ///    that email if you wish to continue signing in with that credential.
  ///    To do so, sign in to `email` via one
  ///    of the providers and then [User.linkWithCredential] the
  ///    original credential to that newly signed in user.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the provider in the Firebase Console. Go
  ///    to the Firebase Console for your project, in the Auth section and the
  ///    Sign in Method tab and configure the provider.
  Future<UserCredential> linkWithProvider(
    AuthProvider provider,
  ) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.linkWithProvider(provider),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Re-authenticates a user using a Provider.
  ///
  /// Use before operations such as [User.updatePassword] that require tokens
  /// from recent sign-in attempts.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-mismatch**:
  ///  - Thrown if the credential given does not correspond to the user.
  /// - **user-not-found**:
  ///  - Thrown if the credential given does not correspond to any existing
  ///    user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **wrong-password**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> reauthenticateWithProvider(
    AuthProvider provider,
  ) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.reauthenticateWithProvider(provider),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Re-authenticates a user using a popup on Web.
  ///
  /// Use before operations such as [User.updatePassword] that require tokens
  /// from recent sign-in attempts.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-mismatch**:
  ///  - Thrown if the credential given does not correspond to the user.
  /// - **user-not-found**:
  ///  - Thrown if the credential given does not correspond to any existing
  ///    user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **wrong-password**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> reauthenticateWithPopup(
    AuthProvider provider,
  ) async {
    return UserCredential._(
      _auth,
      await _delegate.reauthenticateWithPopup(provider),
    );
  }

  /// Re-authenticates a user using a redirection on Web.
  ///
  /// Use before operations such as [User.updatePassword] that require tokens
  /// from recent sign-in attempts.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-mismatch**:
  ///  - Thrown if the credential given does not correspond to the user.
  /// - **user-not-found**:
  ///  - Thrown if the credential given does not correspond to any existing
  ///    user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **wrong-password**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<void> reauthenticateWithRedirect(
    AuthProvider provider,
  ) async {
    await _delegate.reauthenticateWithRedirect(provider);
  }

  /// Links the user account with the given provider.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the credential already exists
  ///    among your users, or is already linked to a Firebase User. For example,
  ///    this error could be thrown if you are upgrading an anonymous user to a
  ///    Google user by linking a Google credential to it and the Google
  ///    credential used is already associated with an existing Firebase Google
  ///    user. The fields `email`, `phoneNumber`, and `credential`
  ///    ([AuthCredential]) may be provided, depending on the type of
  ///    credential. You can recover from this error by signing in with
  ///    `credential` directly via [signInWithCredential].
  /// - **email-already-in-use**:
  ///  - Thrown if the email corresponding to the credential already exists
  ///    among your users. When thrown while linking a credential to an existing
  ///    user, an `email` and `credential` ([AuthCredential]) fields are also
  ///    provided. You have to link the credential to the existing user with
  ///    that email if you wish to continue signing in with that credential.
  ///    To do so, sign in to `email` via one
  ///    of the providers and then [User.linkWithCredential] the
  ///    original credential to that newly signed in user.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the provider in the Firebase Console. Go
  ///    to the Firebase Console for your project, in the Auth section and the
  ///    Sign in Method tab and configure the provider.
  Future<UserCredential> linkWithPopup(AuthProvider provider) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.linkWithPopup(provider),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Links the user account with the given provider.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the credential already exists
  ///    among your users, or is already linked to a Firebase User. For example,
  ///    this error could be thrown if you are upgrading an anonymous user to a
  ///    Google user by linking a Google credential to it and the Google
  ///    credential used is already associated with an existing Firebase Google
  ///    user. The fields `email`, `phoneNumber`, and `credential`
  ///    ([AuthCredential]) may be provided, depending on the type of
  ///    credential. You can recover from this error by signing in with
  ///    `credential` directly via [signInWithCredential].
  /// - **email-already-in-use**:
  ///  - Thrown if the email corresponding to the credential already exists
  ///    among your users. When thrown while linking a credential to an existing
  ///    user, an `email` and `credential` ([AuthCredential]) fields are also
  ///    provided. You have to link the credential to the existing user with
  ///    that email if you wish to continue signing in with that credential.
  ///    To do so, sign in to `email` via one
  ///    of the providers and then [User.linkWithCredential] the
  ///    original credential to that newly signed in user.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the provider in the Firebase Console. Go
  ///    to the Firebase Console for your project, in the Auth section and the
  ///    Sign in Method tab and configure the provider.
  Future<void> linkWithRedirect(AuthProvider provider) async {
    try {
      await _delegate.linkWithRedirect(provider);
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Links the user account with the given phone number.
  ///
  /// This method is only supported on web platforms. Use [verifyPhoneNumber] and
  /// then [linkWithCredential] on these platforms.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **provider-already-linked**:
  ///  - Thrown if the provider has already been linked to the user. This error
  ///    is thrown even if this is not the same provider's account that is
  ///    currently linked to the user.
  /// - **captcha-check-failed**:
  ///  - Thrown if the reCAPTCHA response token was invalid, expired, or if this
  ///    method was called from a non-whitelisted domain.
  /// - **invalid-phone-number**:
  ///  - Thrown if the phone number has an invalid format.
  /// - **quota-exceeded**:
  ///  - Thrown if the SMS quota for the Firebase project has been exceeded.
  /// - **user-disabled**:
  ///  - Thrown if the user corresponding to the given phone number has been disabled.
  /// - **credential-already-in-use**:
  ///  - Thrown if the account corresponding to the phone number already exists
  ///    among your users, or is already linked to a Firebase User.
  /// - **operation-not-allowed**:
  ///  - Thrown if you have not enabled the phone authentication provider in the
  ///  Firebase Console. Go to the Firebase Console for your project, in the Auth
  ///  section and the Sign in Method tab and configure the provider.
  Future<ConfirmationResult> linkWithPhoneNumber(
    String phoneNumber, [
    RecaptchaVerifier? verifier,
  ]) async {
    assert(phoneNumber.isNotEmpty);
    // If we add a recaptcha to the page by creating a new instance, we must
    // also clear that instance before proceeding.
    bool mustClear = verifier == null;
    verifier ??= RecaptchaVerifier(auth: _delegate.auth);
    try {
      final result =
          await _delegate.linkWithPhoneNumber(phoneNumber, verifier.delegate);
      if (mustClear) {
        verifier.clear();
      }
      return ConfirmationResult._(_auth, result);
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Re-authenticates a user using a fresh credential.
  ///
  /// Use before operations such as [User.updatePassword] that require tokens
  /// from recent sign-in attempts.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **user-mismatch**:
  ///  - Thrown if the credential given does not correspond to the user.
  /// - **user-not-found**:
  ///  - Thrown if the credential given does not correspond to any existing
  ///    user.
  /// - **invalid-credential**:
  ///  - Thrown if the provider's credential is not valid. This can happen if it
  ///    has already expired when calling link, or if it used invalid token(s).
  ///    See the Firebase documentation for your provider, and make sure you
  ///    pass in the correct parameters to the credential method.
  /// - **invalid-email**:
  ///  - Thrown if the email used in a [EmailAuthProvider.credential] is
  ///    invalid.
  /// - **wrong-password**:
  ///  - Thrown if the password used in a [EmailAuthProvider.credential] is not
  ///    correct or when the user associated with the email does not have a
  ///    password.
  /// - **invalid-verification-code**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the credential is a [PhoneAuthProvider.credential] and the
  ///    verification ID of the credential is not valid.
  Future<UserCredential> reauthenticateWithCredential(
    AuthCredential credential,
  ) async {
    try {
      return UserCredential._(
        _auth,
        await _delegate.reauthenticateWithCredential(credential),
      );
    } on FirebaseAuthMultiFactorExceptionPlatform catch (e) {
      throw FirebaseAuthMultiFactorException._(_auth, e);
    } catch (e) {
      rethrow;
    }
  }

  /// Refreshes the current user, if signed in.
  Future<void> reload() async {
    await _delegate.reload();
  }

  /// Sends a verification email to a user.
  ///
  /// The verification process is completed by calling [applyActionCode].
  Future<void> sendEmailVerification([
    ActionCodeSettings? actionCodeSettings,
  ]) async {
    await _delegate.sendEmailVerification(actionCodeSettings);
  }

  /// Unlinks a provider from a user account.
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **no-such-provider**:
  ///  - Thrown if the user does not have this provider linked or when the
  ///    provider ID given does not exist.
  Future<User> unlink(String providerId) async {
    return User._(_auth, await _delegate.unlink(providerId));
  }

  /// Updates the user's email address.
  ///
  /// An email will be sent to the original email address (if it was set) that
  /// allows to revoke the email address change, in order to protect them from
  /// account hijacking.
  ///
  /// **Important**: this is a security sensitive operation that requires the
  ///   user to have recently signed in. If this requirement isn't met, ask the
  ///   user to authenticate again and then call [User.reauthenticateWithCredential].
  ///

  /// Updates the user's password.
  ///
  /// **Important**: this is a security sensitive operation that requires the
  ///   user to have recently signed in. If this requirement isn't met, ask the
  ///   user to authenticate again and then call [User.reauthenticateWithCredential].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **weak-password**:
  ///  - Thrown if the password is not strong enough.
  /// - **requires-recent-login**:
  ///  - Thrown if the user's last sign-in time does not meet the security
  ///    threshold. Use [User.reauthenticateWithCredential] to resolve. This
  ///    does not apply if the user is anonymous.
  Future<void> updatePassword(String newPassword) async {
    await _delegate.updatePassword(newPassword);
  }

  /// Updates the user's phone number.
  ///
  /// A credential can be created by verifying a phone number via [verifyPhoneNumber].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **invalid-verification-code**:
  ///  - Thrown if the verification code of the credential is not valid.
  /// - **invalid-verification-id**:
  ///  - Thrown if the verification ID of the credential is not valid.
  Future<void> updatePhoneNumber(PhoneAuthCredential phoneCredential) async {
    await _delegate.updatePhoneNumber(phoneCredential);
  }

  /// Update the user name.
  Future<void> updateDisplayName(String? displayName) {
    return _delegate
        .updateProfile(<String, String?>{'displayName': displayName});
  }

  /// Update the user's profile picture.
  Future<void> updatePhotoURL(String? photoURL) {
    return _delegate.updateProfile(<String, String?>{'photoURL': photoURL});
  }

  /// Updates a user's profile data.
  Future<void> updateProfile({String? displayName, String? photoURL}) {
    return _delegate.updateProfile(<String, String?>{
      'displayName': displayName,
      'photoURL': photoURL,
    });
  }

  /// Sends a verification email to a new email address. The user's email will
  /// be updated to the new one after being verified.
  ///
  /// If you have a custom email action handler, you can complete the
  /// verification process by calling [applyActionCode].
  ///
  /// A [FirebaseAuthException] maybe thrown with the following error code:
  /// - **missing-android-pkg-name**:
  ///  - An Android package name must be provided if the Android app is required to be installed.
  /// - **missing-continue-uri**:
  ///  - A continue URL must be provided in the request.
  /// - **missing-ios-bundle-id**:
  ///  - An iOS bundle ID must be provided if an App Store ID is provided.
  /// - **invalid-continue-uri**:
  ///  - The continue URL provided in the request is invalid.
  /// - **unauthorized-continue-uri**:
  ///  - The domain of the continue URL is not whitelisted. Whitelist the domain in the Firebase console.
  Future<void> verifyBeforeUpdateEmail(
    String newEmail, [
    ActionCodeSettings? actionCodeSettings,
  ]) async {
    await _delegate.verifyBeforeUpdateEmail(newEmail, actionCodeSettings);
  }

  MultiFactor get multiFactor {
    if (!kIsWeb && (defaultTargetPlatform == TargetPlatform.windows)) {
      throw UnimplementedError(
        'MultiFactor Authentication is only supported on web, Android, iOS and macOS.',
      );
    }
    return _multiFactor ??= MultiFactor._(_delegate.multiFactor);
  }

  @override
  String toString() {
    return '$User('
        'displayName: $displayName, '
        'email: $email, '
        'isEmailVerified: $emailVerified, '
        'isAnonymous: $isAnonymous, '
        'metadata: $metadata, '
        'phoneNumber: $phoneNumber, '
        'photoURL: $photoURL, '
        'providerData, $providerData, '
        'refreshToken: $refreshToken, '
        'tenantId: $tenantId, '
        'uid: $uid)';
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\lib\src\user_credential.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_auth.dart';

/// A UserCredential is returned from authentication requests such as
/// [createUserWithEmailAndPassword].
class UserCredential {
  UserCredential._(this._auth, this._delegate) {
    UserCredentialPlatform.verify(_delegate);
  }

  final FirebaseAuth _auth;
  final UserCredentialPlatform _delegate;

  /// Returns additional information about the user, such as whether they are a
  /// newly created one.
  AdditionalUserInfo? get additionalUserInfo => _delegate.additionalUserInfo;

  /// The users [AuthCredential].
  AuthCredential? get credential => _delegate.credential;

  /// Returns a [User] containing additional information and user specific
  /// methods.
  User? get user {
    // TODO(rousselGit): cache the `user` instance or override == so that ".user == .user"
    return _delegate.user == null ? null : User._(_auth, _delegate.user!);
  }

  @override
  String toString() {
    return 'UserCredential('
        'additionalUserInfo: $additionalUserInfo, '
        'credential: $credential, '
        'user: $user)';
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\lib\firebase_auth.dart =====
// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:firebase_auth_platform_interface/firebase_auth_platform_interface.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart';
import 'package:flutter/foundation.dart';

export 'package:firebase_auth_platform_interface/firebase_auth_platform_interface.dart'
    show
        FirebaseAuthException,
        MultiFactorInfo,
        MultiFactorSession,
        PhoneMultiFactorInfo,
        TotpMultiFactorInfo,
        IdTokenResult,
        UserMetadata,
        UserInfo,
        ActionCodeInfo,
        ActionCodeSettings,
        AdditionalUserInfo,
        ActionCodeInfoOperation,
        Persistence,
        PhoneVerificationCompleted,
        PhoneVerificationFailed,
        PhoneCodeSent,
        PhoneCodeAutoRetrievalTimeout,
        AuthCredential,
        AuthProvider,
        AppleAuthProvider,
        AppleFullPersonName,
        AppleAuthCredential,
        EmailAuthProvider,
        EmailAuthCredential,
        FacebookAuthProvider,
        FacebookAuthCredential,
        GameCenterAuthProvider,
        GameCenterAuthCredential,
        PlayGamesAuthProvider,
        PlayGamesAuthCredential,
        GithubAuthProvider,
        GithubAuthCredential,
        GoogleAuthProvider,
        GoogleAuthCredential,
        YahooAuthProvider,
        YahooAuthCredential,
        MicrosoftAuthProvider,
        OAuthProvider,
        OAuthCredential,
        PhoneAuthProvider,
        PhoneAuthCredential,
        SAMLAuthProvider,
        TwitterAuthProvider,
        TwitterAuthCredential,
        RecaptchaVerifierOnSuccess,
        RecaptchaVerifierOnExpired,
        RecaptchaVerifierOnError,
        RecaptchaVerifierSize,
        RecaptchaVerifierTheme,
        PasswordValidationStatus;
export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseException;

part 'src/confirmation_result.dart';
part 'src/firebase_auth.dart';
part 'src/multi_factor.dart';
part 'src/recaptcha_verifier.dart';
part 'src/user.dart';
part 'src/user_credential.dart';
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\test\firebase_auth_test.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:async/async.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_auth_platform_interface/firebase_auth_platform_interface.dart';
import 'package:firebase_auth_platform_interface/src/method_channel/method_channel_firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';

import './mock.dart';

void main() {
  setupFirebaseAuthMocks();

  late FirebaseAuth auth;

  const String kMockActionCode = '12345';
  const String kMockEmail = 'test@example.com';
  const String kMockPassword = 'passw0rd';
  const String kMockIdToken = '12345';
  const String kMockRawNonce = 'abcde12345';
  const String kMockAccessToken = '67890';
  const String kMockGithubToken = 'github';
  const String kMockCustomToken = '12345';
  const String kMockPhoneNumber = '5555555555';
  const String kMockVerificationId = '12345';
  const String kMockSmsCode = '123456';
  const String kMockLanguage = 'en';
  const String kMockOobCode = 'oobcode';
  const String kMockURL = 'http://www.example.com';
  const String kMockHost = 'www.example.com';
  const String kMockValidPassword =
      'Password123!'; // For password policy impl testing
  const String kMockInvalidPassword = 'Pa1!';
  const String kMockInvalidPassword2 = 'password123!';
  const String kMockInvalidPassword3 = 'PASSWORD123!';
  const String kMockInvalidPassword4 = 'password!';
  const String kMockInvalidPassword5 = 'Password123';
  const Map<String, dynamic> kMockPasswordPolicy = {
    'customStrengthOptions': {
      'minPasswordLength': 6,
      'maxPasswordLength': 12,
      'containsLowercaseCharacter': true,
      'containsUppercaseCharacter': true,
      'containsNumericCharacter': true,
      'containsNonAlphanumericCharacter': true,
    },
    'allowedNonAlphanumericCharacters': ['!'],
    'schemaVersion': 1,
    'enforcement': 'OFF',
  };
  final PasswordPolicy kMockPasswordPolicyObject =
      PasswordPolicy(kMockPasswordPolicy);
  const int kMockPort = 31337;

  final TestAuthProvider testAuthProvider = TestAuthProvider();
  final int kMockCreationTimestamp =
      DateTime.now().subtract(const Duration(days: 2)).millisecondsSinceEpoch;
  final int kMockLastSignInTimestamp =
      DateTime.now().subtract(const Duration(days: 1)).millisecondsSinceEpoch;

  final kMockUser = PigeonUserDetails(
    userInfo: PigeonUserInfo(
      uid: '12345',
      displayName: 'displayName',
      creationTimestamp: kMockCreationTimestamp,
      lastSignInTimestamp: kMockLastSignInTimestamp,
      isAnonymous: true,
      isEmailVerified: false,
    ),
    providerData: [
      {
        'providerId': 'firebase',
        'uid': '12345',
        'displayName': 'Flutter Test User',
        'photoUrl': 'http://www.example.com/',
        'email': 'test@example.com',
      }
    ],
  );

  late MockUserPlatform mockUserPlatform;
  late MockUserCredentialPlatform mockUserCredPlatform;
  late MockConfirmationResultPlatform mockConfirmationResultPlatform;
  late MockRecaptchaVerifier mockVerifier;
  late AdditionalUserInfo mockAdditionalUserInfo;
  late EmailAuthCredential mockCredential;

  MockFirebaseAuth mockAuthPlatform = MockFirebaseAuth();

  group('$FirebaseAuth', () {
    PigeonUserDetails user;
    // used to generate a unique application name for each test
    var testCount = 0;

    setUp(() async {
      FirebaseAuthPlatform.instance = mockAuthPlatform = MockFirebaseAuth();

      // Each test uses a unique FirebaseApp instance to avoid sharing state
      final app = await Firebase.initializeApp(
        name: '$testCount',
        options: const FirebaseOptions(
          apiKey: '',
          appId: '',
          messagingSenderId: '',
          projectId: '',
        ),
      );

      auth = FirebaseAuth.instanceFor(app: app);
      user = kMockUser;

      mockUserPlatform = MockUserPlatform(
          mockAuthPlatform, TestMultiFactorPlatform(mockAuthPlatform), user);
      mockConfirmationResultPlatform = MockConfirmationResultPlatform();
      mockAdditionalUserInfo = AdditionalUserInfo(
        isNewUser: false,
        username: 'flutterUser',
        providerId: 'testProvider',
        profile: <String, dynamic>{'foo': 'bar'},
      );
      mockCredential = EmailAuthProvider.credential(
        email: 'test',
        password: 'test',
      ) as EmailAuthCredential;
      mockUserCredPlatform = MockUserCredentialPlatform(
        FirebaseAuthPlatform.instance,
        mockAdditionalUserInfo,
        mockCredential,
        mockUserPlatform,
      );
      mockVerifier = MockRecaptchaVerifier();

      when(mockAuthPlatform.signInAnonymously())
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithCredential(any)).thenAnswer(
          (_) => Future<UserCredentialPlatform>.value(mockUserCredPlatform));

      when(mockAuthPlatform.currentUser).thenReturn(mockUserPlatform);

      when(mockAuthPlatform.instanceFor(
        app: anyNamed('app'),
        pluginConstants: anyNamed('pluginConstants'),
      )).thenAnswer((_) => mockUserPlatform);

      when(mockAuthPlatform.delegateFor(
        app: anyNamed('app'),
      )).thenAnswer((_) => mockAuthPlatform);

      when(mockAuthPlatform.setInitialValues(
        currentUser: anyNamed('currentUser'),
        languageCode: anyNamed('languageCode'),
      )).thenAnswer((_) => mockAuthPlatform);

      when(mockAuthPlatform.createUserWithEmailAndPassword(any, any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.getRedirectResult())
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithCustomToken(any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithEmailAndPassword(any, any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithEmailLink(any, any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithPhoneNumber(any, any))
          .thenAnswer((_) async => mockConfirmationResultPlatform);

      when(mockVerifier.delegate).thenReturn(mockVerifier.mockDelegate);

      when(mockAuthPlatform.signInWithPopup(any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.signInWithRedirect(any))
          .thenAnswer((_) async => mockUserCredPlatform);

      when(mockAuthPlatform.authStateChanges()).thenAnswer((_) =>
          Stream<UserPlatform>.fromIterable(<UserPlatform>[mockUserPlatform]));

      when(mockAuthPlatform.idTokenChanges()).thenAnswer((_) =>
          Stream<UserPlatform>.fromIterable(<UserPlatform>[mockUserPlatform]));

      when(mockAuthPlatform.userChanges()).thenAnswer((_) =>
          Stream<UserPlatform>.fromIterable(<UserPlatform>[mockUserPlatform]));

      TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger
          .setMockMethodCallHandler(MethodChannelFirebaseAuth.channel,
              (call) async {
        return <String, dynamic>{'user': user};
      });
    });

    // incremented after tests completed, in case a test may want to use this
    // value for an assertion (toString)
    tearDown(() => testCount++);

    setUp(() async {
      user = kMockUser;
      await auth.signInAnonymously();
    });

    group('emulator', () {
      test('useAuthEmulator() should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.useAuthEmulator(kMockHost, kMockPort))
            .thenAnswer((i) async {});
        await auth.useAuthEmulator(kMockHost, kMockPort);
        verify(mockAuthPlatform.useAuthEmulator(kMockHost, kMockPort));
      });
    });

    group('currentUser', () {
      test('get currentUser', () {
        User? user = auth.currentUser;
        verify(mockAuthPlatform.currentUser);
        expect(user, isA<User>());
      });
    });

    group('tenantId', () {
      test('set tenantId should call delegate method', () async {
        // Each test uses a unique FirebaseApp instance to avoid sharing state
        final app = await Firebase.initializeApp(
            name: 'tenantIdTest',
            options: const FirebaseOptions(
                apiKey: 'apiKey',
                appId: 'appId',
                messagingSenderId: 'messagingSenderId',
                projectId: 'projectId'));

        FirebaseAuthPlatform.instance =
            FakeFirebaseAuthPlatform(tenantId: 'foo');
        auth = FirebaseAuth.instanceFor(app: app);

        expect(auth.tenantId, 'foo');

        auth.tenantId = 'bar';

        expect(auth.tenantId, 'bar');
        expect(FirebaseAuthPlatform.instance.tenantId, 'bar');
      });
    });

    group('customAuthDomain', () {
      test('set customAuthDomain should call delegate method', () async {
        // Each test uses a unique FirebaseApp instance to avoid sharing state
        final app = await Firebase.initializeApp(
            name: 'customAuthDomainTest',
            options: const FirebaseOptions(
                apiKey: 'apiKey',
                appId: 'appId',
                messagingSenderId: 'messagingSenderId',
                projectId: 'projectId'));

        FirebaseAuthPlatform.instance =
            FakeFirebaseAuthPlatform(customAuthDomain: 'foo');
        auth = FirebaseAuth.instanceFor(app: app);

        expect(auth.customAuthDomain, 'foo');
        if (defaultTargetPlatform == TargetPlatform.windows || kIsWeb) {
          try {
            auth.customAuthDomain = 'bar';
          } on UnimplementedError catch (e) {
            expect(e.message, contains('Cannot set auth domain'));
          }
        } else {
          auth.customAuthDomain = 'bar';

          expect(auth.customAuthDomain, 'bar');
          expect(FirebaseAuthPlatform.instance.customAuthDomain, 'bar');
        }
      });
    });

    group('languageCode', () {
      test('.languageCode should call delegate method', () {
        auth.languageCode;
        verify(mockAuthPlatform.languageCode);
      });

      test('setLanguageCode() should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.setLanguageCode(any)).thenAnswer((i) async {});

        await auth.setLanguageCode(kMockLanguage);
        verify(mockAuthPlatform.setLanguageCode(kMockLanguage));
      });
    });

    group('checkActionCode()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.checkActionCode(any)).thenAnswer(
          (i) async => ActionCodeInfo(
            data: ActionCodeInfoData(email: null, previousEmail: null),
            operation: ActionCodeInfoOperation.unknown,
          ),
        );

        await auth.checkActionCode(kMockActionCode);
        verify(mockAuthPlatform.checkActionCode(kMockActionCode));
      });
    });

    group('confirmPasswordReset()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.confirmPasswordReset(any, any))
            .thenAnswer((i) async {});

        await auth.confirmPasswordReset(
          code: kMockActionCode,
          newPassword: kMockPassword,
        );
        verify(mockAuthPlatform.confirmPasswordReset(
            kMockActionCode, kMockPassword));
      });
    });

    group('createUserWithEmailAndPassword()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.createUserWithEmailAndPassword(any, any))
            .thenAnswer((i) async => EmptyUserCredentialPlatform());

        await auth.createUserWithEmailAndPassword(
          email: kMockEmail,
          password: kMockPassword,
        );

        verify(mockAuthPlatform.createUserWithEmailAndPassword(
          kMockEmail,
          kMockPassword,
        ));
      });
    });

    group('getRedirectResult()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.getRedirectResult())
            .thenAnswer((i) async => EmptyUserCredentialPlatform());

        await auth.getRedirectResult();
        verify(mockAuthPlatform.getRedirectResult());
      });
    });

    group('isSignInWithEmailLink()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.isSignInWithEmailLink(any))
            .thenAnswer((i) => false);

        auth.isSignInWithEmailLink(kMockURL);
        verify(mockAuthPlatform.isSignInWithEmailLink(kMockURL));
      });
    });

    group('authStateChanges()', () {
      test('should stream changes', () async {
        final StreamQueue<User?> changes =
            StreamQueue<User?>(auth.authStateChanges());
        expect(await changes.next, isA<User>());
      });
    });

    group('idTokenChanges()', () {
      test('should stream changes', () async {
        final StreamQueue<User?> changes =
            StreamQueue<User?>(auth.idTokenChanges());
        expect(await changes.next, isA<User>());
      });
    });

    group('userChanges()', () {
      test('should stream changes', () async {
        final StreamQueue<User?> changes =
            StreamQueue<User?>(auth.userChanges());
        expect(await changes.next, isA<User>());
      });
    });

    group('sendPasswordResetEmail()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.sendPasswordResetEmail(any))
            .thenAnswer((i) async {});

        await auth.sendPasswordResetEmail(email: kMockEmail);
        verify(mockAuthPlatform.sendPasswordResetEmail(kMockEmail));
      });
    });

    group('sendPasswordResetEmail()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.sendPasswordResetEmail(any))
            .thenAnswer((i) async {});

        await auth.sendPasswordResetEmail(email: kMockEmail);
        verify(mockAuthPlatform.sendPasswordResetEmail(kMockEmail));
      });
    });

    group('sendSignInLinkToEmail()', () {
      test('should throw if actionCodeSettings.handleCodeInApp is not true',
          () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.sendSignInLinkToEmail(any, any))
            .thenAnswer((i) async {});

        final ActionCodeSettings kMockActionCodeSettingsNull =
            ActionCodeSettings(url: kMockURL);
        final ActionCodeSettings kMockActionCodeSettingsFalse =
            ActionCodeSettings(url: kMockURL);

        // when handleCodeInApp is null
        expect(
          () => auth.sendSignInLinkToEmail(
              email: kMockEmail,
              actionCodeSettings: kMockActionCodeSettingsNull),
          throwsArgumentError,
        );
        // when handleCodeInApp is false
        expect(
          () => auth.sendSignInLinkToEmail(
              email: kMockEmail,
              actionCodeSettings: kMockActionCodeSettingsFalse),
          throwsArgumentError,
        );
      });

      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.sendSignInLinkToEmail(any, any))
            .thenAnswer((i) async {});

        final ActionCodeSettings kMockActionCodeSettingsValid =
            ActionCodeSettings(url: kMockURL, handleCodeInApp: true);

        await auth.sendSignInLinkToEmail(
          email: kMockEmail,
          actionCodeSettings: kMockActionCodeSettingsValid,
        );

        verify(mockAuthPlatform.sendSignInLinkToEmail(
          kMockEmail,
          kMockActionCodeSettingsValid,
        ));
      });
    });

    group('setSettings()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.setSettings(
          appVerificationDisabledForTesting: any,
          phoneNumber: any,
          smsCode: any,
          forceRecaptchaFlow: any,
          userAccessGroup: any,
        )).thenAnswer((i) async {});

        String phoneNumber = '123456';
        String smsCode = '1234';
        bool forceRecaptchaFlow = true;
        bool appVerificationDisabledForTesting = true;
        String userAccessGroup = 'group-id';

        await auth.setSettings(
          appVerificationDisabledForTesting: appVerificationDisabledForTesting,
          phoneNumber: phoneNumber,
          smsCode: smsCode,
          forceRecaptchaFlow: forceRecaptchaFlow,
          userAccessGroup: userAccessGroup,
        );

        verify(
          mockAuthPlatform.setSettings(
            appVerificationDisabledForTesting:
                appVerificationDisabledForTesting,
            phoneNumber: phoneNumber,
            smsCode: smsCode,
            forceRecaptchaFlow: forceRecaptchaFlow,
            userAccessGroup: userAccessGroup,
          ),
        );
      });
    });

    group('setPersistence()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.setPersistence(any)).thenAnswer((i) async {});

        await auth.setPersistence(Persistence.LOCAL);
        verify(mockAuthPlatform.setPersistence(Persistence.LOCAL));
      });
    });

    group('signInAnonymously()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.signInAnonymously())
            .thenAnswer((i) async => EmptyUserCredentialPlatform());

        await auth.signInAnonymously();
        verify(mockAuthPlatform.signInAnonymously());
      });
    });

    group('signInWithCredential()', () {
      test('GithubAuthProvider signInWithCredential', () async {
        final AuthCredential credential =
            GithubAuthProvider.credential(kMockGithubToken);
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured, isA<GithubAuthCredential>());
        expect(captured.providerId, equals('github.com'));
        expect(captured.accessToken, equals(kMockGithubToken));
      });

      test('EmailAuthProvider (withLink) signInWithCredential', () async {
        final AuthCredential credential = EmailAuthProvider.credentialWithLink(
          email: 'test@example.com',
          emailLink: '<Url with domain from your Firebase project>',
        );
        await auth.signInWithCredential(credential);
        final EmailAuthCredential captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('password'));
        expect(captured.email, equals('test@example.com'));
        expect(captured.emailLink,
            equals('<Url with domain from your Firebase project>'));
      });

      test('TwitterAuthProvider signInWithCredential', () async {
        final AuthCredential credential = TwitterAuthProvider.credential(
          accessToken: kMockIdToken,
          secret: kMockAccessToken,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured, isA<TwitterAuthCredential>());
        expect(captured.providerId, equals('twitter.com'));
        expect(captured.accessToken, equals(kMockIdToken));
        expect(captured.secret, equals(kMockAccessToken));
      });

      test('GoogleAuthProvider signInWithCredential', () async {
        final credential = GoogleAuthProvider.credential(
          idToken: kMockIdToken,
          accessToken: kMockAccessToken,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured, isA<GoogleAuthCredential>());
        expect(captured.providerId, equals('google.com'));
        expect(captured.idToken, equals(kMockIdToken));
        expect(captured.accessToken, equals(kMockAccessToken));
      });

      test('OAuthProvider signInWithCredential for Apple', () async {
        OAuthProvider oAuthProvider = OAuthProvider('apple.com');
        final AuthCredential credential = oAuthProvider.credential(
          idToken: kMockIdToken,
          accessToken: kMockAccessToken,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('apple.com'));
        expect(captured.idToken, equals(kMockIdToken));
        expect(captured.accessToken, equals(kMockAccessToken));
        expect(captured.rawNonce, equals(null));
      });

      test('OAuthProvider signInWithCredential for Apple with rawNonce',
          () async {
        OAuthProvider oAuthProvider = OAuthProvider('apple.com');
        final AuthCredential credential = oAuthProvider.credential(
          idToken: kMockIdToken,
          rawNonce: kMockRawNonce,
          accessToken: kMockAccessToken,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('apple.com'));
        expect(captured.idToken, equals(kMockIdToken));
        expect(captured.rawNonce, equals(kMockRawNonce));
        expect(captured.accessToken, equals(kMockAccessToken));
      });

      test(
          'OAuthProvider signInWithCredential for Apple with rawNonce (empty accessToken)',
          () async {
        OAuthProvider oAuthProvider = OAuthProvider('apple.com');
        final AuthCredential credential = oAuthProvider.credential(
          idToken: kMockIdToken,
          rawNonce: kMockRawNonce,
        );
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('apple.com'));
        expect(captured.idToken, equals(kMockIdToken));
        expect(captured.rawNonce, equals(kMockRawNonce));
        expect(captured.accessToken, equals(null));
      });

      test('PhoneAuthProvider signInWithCredential', () async {
        final PhoneAuthCredential credential = PhoneAuthProvider.credential(
          verificationId: kMockVerificationId,
          smsCode: kMockSmsCode,
        );
        await auth.signInWithCredential(credential);
        final PhoneAuthCredential captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured.providerId, equals('phone'));
        expect(captured.verificationId, equals(kMockVerificationId));
        expect(captured.smsCode, equals(kMockSmsCode));
      });

      test('FacebookAuthProvider signInWithCredential', () async {
        final AuthCredential credential =
            FacebookAuthProvider.credential(kMockAccessToken);
        await auth.signInWithCredential(credential);
        final captured =
            verify(mockAuthPlatform.signInWithCredential(captureAny))
                .captured
                .single;
        expect(captured, isA<FacebookAuthCredential>());
        expect(captured.providerId, equals('facebook.com'));
        expect(captured.accessToken, equals(kMockAccessToken));
      });
    });

    group('signInWithCustomToken()', () {
      test('should call delegate method', () async {
        await auth.signInWithCustomToken(kMockCustomToken);
        verify(mockAuthPlatform.signInWithCustomToken(kMockCustomToken));
      });
    });

    group('signInWithEmailAndPassword()', () {
      test('should call delegate method', () async {
        await auth.signInWithEmailAndPassword(
            email: kMockEmail, password: kMockPassword);
        verify(mockAuthPlatform.signInWithEmailAndPassword(
            kMockEmail, kMockPassword));
      });
    });

    group('signInWithEmailLink()', () {
      test('should call delegate method', () async {
        await auth.signInWithEmailLink(email: kMockEmail, emailLink: kMockURL);
        verify(mockAuthPlatform.signInWithEmailLink(kMockEmail, kMockURL));
      });
    });

    group('signInWithPhoneNumber()', () {
      test('should call delegate method', () async {
        await auth.signInWithPhoneNumber(kMockPhoneNumber, mockVerifier);
        verify(mockAuthPlatform.signInWithPhoneNumber(kMockPhoneNumber, any));
      });
    });

    group('signInWithPopup()', () {
      test('should call delegate method', () async {
        await auth.signInWithPopup(testAuthProvider);
        verify(mockAuthPlatform.signInWithPopup(testAuthProvider));
      });
    });

    group('signInWithRedirect()', () {
      test('should call delegate method', () async {
        await auth.signInWithRedirect(testAuthProvider);
        verify(mockAuthPlatform.signInWithRedirect(testAuthProvider));
      });
    });

    group('signOut()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.signOut()).thenAnswer((i) async {});

        await auth.signOut();
        verify(mockAuthPlatform.signOut());
      });
    });

    group('verifyPasswordResetCode()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.verifyPasswordResetCode(any))
            .thenAnswer((i) async => '');

        await auth.verifyPasswordResetCode(kMockOobCode);
        verify(mockAuthPlatform.verifyPasswordResetCode(kMockOobCode));
      });
    });

    group('verifyPhoneNumber()', () {
      test('should call delegate method', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockAuthPlatform.verifyPhoneNumber(
          autoRetrievedSmsCodeForTesting:
              anyNamed('autoRetrievedSmsCodeForTesting'),
          codeAutoRetrievalTimeout: anyNamed('codeAutoRetrievalTimeout'),
          codeSent: anyNamed('codeSent'),
          forceResendingToken: anyNamed('forceResendingToken'),
          phoneNumber: anyNamed('phoneNumber'),
          timeout: anyNamed('timeout'),
          verificationCompleted: anyNamed('verificationCompleted'),
          verificationFailed: anyNamed('verificationFailed'),
        )).thenAnswer((i) async {});

        final PhoneVerificationCompleted verificationCompleted =
            (PhoneAuthCredential phoneAuthCredential) {};
        final PhoneVerificationFailed verificationFailed =
            (FirebaseAuthException authException) {};
        final PhoneCodeSent codeSent =
            (String verificationId, [int? forceResendingToken]) async {};
        final PhoneCodeAutoRetrievalTimeout autoRetrievalTimeout =
            (String verificationId) {};

        await auth.verifyPhoneNumber(
          phoneNumber: kMockPhoneNumber,
          verificationCompleted: verificationCompleted,
          verificationFailed: verificationFailed,
          codeSent: codeSent,
          codeAutoRetrievalTimeout: autoRetrievalTimeout,
        );

        verify(
          mockAuthPlatform.verifyPhoneNumber(
            phoneNumber: kMockPhoneNumber,
            verificationCompleted: verificationCompleted,
            verificationFailed: verificationFailed,
            codeSent: codeSent,
            codeAutoRetrievalTimeout: autoRetrievalTimeout,
          ),
        );
      });
    });

    group('passwordPolicy', () {
      test('passwordPolicy should be initialized with correct parameters',
          () async {
        PasswordPolicyImpl passwordPolicy =
            PasswordPolicyImpl(kMockPasswordPolicyObject);
        expect(passwordPolicy.policy, equals(kMockPasswordPolicyObject));
      });

      PasswordPolicyImpl passwordPolicy =
          PasswordPolicyImpl(kMockPasswordPolicyObject);

      test('should return true for valid password', () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockValidPassword);
        expect(status.isValid, isTrue);
      });

      test('should return false for invalid password that is too short',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword);
        expect(status.isValid, isFalse);
      });

      test(
          'should return false for invalid password with no capital characters',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword2);
        expect(status.isValid, isFalse);
      });

      test(
          'should return false for invalid password with no lowercase characters',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword3);
        expect(status.isValid, isFalse);
      });

      test('should return false for invalid password with no numbers',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword4);
        expect(status.isValid, isFalse);
      });

      test('should return false for invalid password with no symbols',
          () async {
        final PasswordValidationStatus status =
            passwordPolicy.isPasswordValid(kMockInvalidPassword5);
        expect(status.isValid, isFalse);
      });
    });

    test('toString()', () async {
      expect(
        auth.toString(),
        equals('FirebaseAuth(app: $testCount)'),
      );
    });
  });
}

class MockFirebaseAuth extends Mock
    with MockPlatformInterfaceMixin
    implements TestFirebaseAuthPlatform {
  @override
  Stream<UserPlatform?> userChanges() {
    return super.noSuchMethod(
      Invocation.method(#userChanges, []),
      returnValue: const Stream<UserPlatform?>.empty(),
      returnValueForMissingStub: const Stream<UserPlatform?>.empty(),
    );
  }

  @override
  Stream<UserPlatform?> idTokenChanges() {
    return super.noSuchMethod(
      Invocation.method(#idTokenChanges, []),
      returnValue: const Stream<UserPlatform?>.empty(),
      returnValueForMissingStub: const Stream<UserPlatform?>.empty(),
    );
  }

  @override
  Stream<UserPlatform?> authStateChanges() {
    return super.noSuchMethod(
      Invocation.method(#authStateChanges, []),
      returnValue: const Stream<UserPlatform?>.empty(),
      returnValueForMissingStub: const Stream<UserPlatform?>.empty(),
    );
  }

  @override
  FirebaseAuthPlatform delegateFor(
      {FirebaseApp? app, Persistence? persistence}) {
    return super.noSuchMethod(
      Invocation.method(#delegateFor, [], {#app: app}),
      returnValue: TestFirebaseAuthPlatform(),
      returnValueForMissingStub: TestFirebaseAuthPlatform(),
    );
  }

  @override
  Future<UserCredentialPlatform> createUserWithEmailAndPassword(
    String? email,
    String? password,
  ) {
    return super.noSuchMethod(
      Invocation.method(#createUserWithEmailAndPassword, [email, password]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<ConfirmationResultPlatform> signInWithPhoneNumber(
    String? phoneNumber,
    RecaptchaVerifierFactoryPlatform? applicationVerifier,
  ) {
    return super.noSuchMethod(
      Invocation.method(
        #signInWithPhoneNumber,
        [phoneNumber, applicationVerifier],
      ),
      returnValue: neverEndingFuture<ConfirmationResultPlatform>(),
      returnValueForMissingStub:
          neverEndingFuture<ConfirmationResultPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithCredential(
    AuthCredential? credential,
  ) {
    return super.noSuchMethod(
      Invocation.method(#signInWithCredential, [credential]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithCustomToken(String? token) {
    return super.noSuchMethod(
      Invocation.method(#signInWithCustomToken, [token]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithEmailAndPassword(
    String? email,
    String? password,
  ) {
    return super.noSuchMethod(
      Invocation.method(#signInWithEmailAndPassword, [email, password]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithPopup(AuthProvider? provider) {
    return super.noSuchMethod(
      Invocation.method(#signInWithPopup, [provider]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInWithEmailLink(
    String? email,
    String? emailLink,
  ) {
    return super.noSuchMethod(
      Invocation.method(#signInWithEmailLink, [email, emailLink]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<void> signInWithRedirect(AuthProvider? provider) {
    return super.noSuchMethod(
      Invocation.method(#signInWithRedirect, [provider]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<UserCredentialPlatform> signInAnonymously() {
    return super.noSuchMethod(
      Invocation.method(#signInAnonymously, []),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return super.noSuchMethod(
      Invocation.method(#signInAnonymously, [], {
        #currentUser: currentUser,
        #languageCode: languageCode,
      }),
      returnValue: TestFirebaseAuthPlatform(),
      returnValueForMissingStub: TestFirebaseAuthPlatform(),
    );
  }

  @override
  Future<UserCredentialPlatform> getRedirectResult() {
    return super.noSuchMethod(
      Invocation.method(#getRedirectResult, []),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<void> setLanguageCode(String? languageCode) {
    return super.noSuchMethod(
      Invocation.method(#setLanguageCode, [languageCode]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> useAuthEmulator(String host, int port) {
    return super.noSuchMethod(
      Invocation.method(#useEmulator, [host, port]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<ActionCodeInfo> checkActionCode(String? code) {
    return super.noSuchMethod(
      Invocation.method(#checkActionCode, [code]),
      returnValue: neverEndingFuture<ActionCodeInfo>(),
      returnValueForMissingStub: neverEndingFuture<ActionCodeInfo>(),
    );
  }

  @override
  Future<void> confirmPasswordReset(String? code, String? newPassword) {
    return super.noSuchMethod(
      Invocation.method(#confirmPasswordReset, [code, newPassword]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  bool isSignInWithEmailLink(String? emailLink) {
    return super.noSuchMethod(
      Invocation.method(#isSignInWithEmailLink, [emailLink]),
      returnValue: false,
      returnValueForMissingStub: false,
    );
  }

  @override
  Future<void> sendPasswordResetEmail(
    String? email, [
    ActionCodeSettings? actionCodeSettings,
  ]) {
    return super.noSuchMethod(
      Invocation.method(#sendPasswordResetEmail, [email, actionCodeSettings]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> sendSignInLinkToEmail(
    String? email,
    ActionCodeSettings? actionCodeSettings,
  ) {
    return super.noSuchMethod(
      Invocation.method(#sendSignInLinkToEmail, [email, actionCodeSettings]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> setSettings({
    bool? appVerificationDisabledForTesting,
    String? userAccessGroup,
    String? phoneNumber,
    String? smsCode,
    bool? forceRecaptchaFlow,
  }) {
    return super.noSuchMethod(
      Invocation.method(#setSettings, [
        appVerificationDisabledForTesting,
        userAccessGroup,
        phoneNumber,
        smsCode,
        forceRecaptchaFlow,
      ]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> setPersistence(Persistence? persistence) {
    return super.noSuchMethod(
      Invocation.method(#setPersistence, [persistence]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> signOut() {
    return super.noSuchMethod(
      Invocation.method(#signOut, [signOut]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<String> verifyPasswordResetCode(String? code) {
    return super.noSuchMethod(
      Invocation.method(#verifyPasswordResetCode, [code]),
      returnValue: neverEndingFuture<String>(),
      returnValueForMissingStub: neverEndingFuture<String>(),
    );
  }

  @override
  Future<void> verifyPhoneNumber({
    String? phoneNumber,
    PhoneMultiFactorInfo? multiFactorInfo,
    MultiFactorSession? multiFactorSession,
    Object? verificationCompleted,
    Object? verificationFailed,
    Object? codeSent,
    Object? codeAutoRetrievalTimeout,
    Duration? timeout = const Duration(seconds: 30),
    int? forceResendingToken,
    String? autoRetrievedSmsCodeForTesting,
  }) {
    return super.noSuchMethod(
      Invocation.method(#verifyPhoneNumber, [], {
        #phoneNumber: phoneNumber,
        #verificationCompleted: verificationCompleted,
        #verificationFailed: verificationFailed,
        #codeSent: codeSent,
        #codeAutoRetrievalTimeout: codeAutoRetrievalTimeout,
        #timeout: timeout,
        #forceResendingToken: forceResendingToken,
        #autoRetrievedSmsCodeForTesting: autoRetrievedSmsCodeForTesting,
      }),
      returnValue: neverEndingFuture<String>(),
      returnValueForMissingStub: neverEndingFuture<String>(),
    );
  }
}

class FakeFirebaseAuthPlatform extends Fake
    with MockPlatformInterfaceMixin
    implements FirebaseAuthPlatform {
  FakeFirebaseAuthPlatform({this.tenantId, this.customAuthDomain});

  @override
  String? tenantId;

  @override
  String? customAuthDomain;

  @override
  FirebaseAuthPlatform delegateFor(
      {required FirebaseApp app, Persistence? persistence}) {
    return this;
  }

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return this;
  }
}

class MockUserPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestUserPlatform {
  MockUserPlatform(FirebaseAuthPlatform auth, MultiFactorPlatform multiFactor,
      PigeonUserDetails _user) {
    TestUserPlatform(auth, multiFactor, _user);
  }
}

class MockUserCredentialPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestUserCredentialPlatform {
  MockUserCredentialPlatform(
    FirebaseAuthPlatform auth,
    AdditionalUserInfo additionalUserInfo,
    AuthCredential credential,
    UserPlatform userPlatform,
  ) {
    TestUserCredentialPlatform(
      auth,
      additionalUserInfo,
      credential,
      userPlatform,
    );
  }
}

class MockConfirmationResultPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestConfirmationResultPlatform {
  MockConfirmationResultPlatform() {
    TestConfirmationResultPlatform();
  }
}

class TestConfirmationResultPlatform extends ConfirmationResultPlatform {
  TestConfirmationResultPlatform() : super('TEST');
}

class TestFirebaseAuthPlatform extends FirebaseAuthPlatform {
  TestFirebaseAuthPlatform() : super();

  void instanceFor({
    FirebaseApp? app,
    Map<dynamic, dynamic>? pluginConstants,
  }) {}

  @override
  FirebaseAuthPlatform delegateFor(
      {FirebaseApp? app, Persistence? persistence}) {
    return this;
  }

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return this;
  }
}

class MockRecaptchaVerifier extends Mock
    with MockPlatformInterfaceMixin
    implements TestRecaptchaVerifier {
  MockRecaptchaVerifier() {
    TestRecaptchaVerifier();
  }

  RecaptchaVerifierFactoryPlatform get mockDelegate {
    return MockRecaptchaVerifierFactoryPlatform();
  }

  @override
  RecaptchaVerifierFactoryPlatform get delegate {
    return super.noSuchMethod(
      Invocation.getter(#delegate),
      returnValue: MockRecaptchaVerifierFactoryPlatform(),
      returnValueForMissingStub: MockRecaptchaVerifierFactoryPlatform(),
    );
  }
}

class MockRecaptchaVerifierFactoryPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestRecaptchaVerifierFactoryPlatform {
  MockRecaptchaVerifierFactoryPlatform() {
    TestRecaptchaVerifierFactoryPlatform();
  }
}

class TestRecaptchaVerifier implements RecaptchaVerifier {
  TestRecaptchaVerifier() : super();

  @override
  void clear() {}

  @override
  RecaptchaVerifierFactoryPlatform get delegate =>
      TestRecaptchaVerifierFactoryPlatform();

  @override
  Future<int> render() {
    throw UnimplementedError();
  }

  @override
  String get type => throw UnimplementedError();

  @override
  Future<String> verify() {
    throw UnimplementedError();
  }
}

class TestRecaptchaVerifierFactoryPlatform
    extends RecaptchaVerifierFactoryPlatform {}

class TestAuthProvider extends AuthProvider {
  TestAuthProvider() : super('TEST');
}

class TestUserPlatform extends UserPlatform {
  TestUserPlatform(FirebaseAuthPlatform auth, MultiFactorPlatform multiFactor,
      PigeonUserDetails data)
      : super(auth, multiFactor, data);
}

class TestMultiFactorPlatform extends MultiFactorPlatform {
  TestMultiFactorPlatform(FirebaseAuthPlatform auth) : super(auth);
}

class TestUserCredentialPlatform extends UserCredentialPlatform {
  TestUserCredentialPlatform(
    FirebaseAuthPlatform auth,
    AdditionalUserInfo additionalUserInfo,
    AuthCredential credential,
    UserPlatform userPlatform,
  ) : super(
          auth: auth,
          additionalUserInfo: additionalUserInfo,
          credential: credential,
          user: userPlatform,
        );
}

class EmptyUserCredentialPlatform extends UserCredentialPlatform {
  EmptyUserCredentialPlatform() : super(auth: FirebaseAuthPlatform.instance);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\test\mock.dart =====
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core_platform_interface/test.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

typedef Callback = void Function(MethodCall call);

void setupFirebaseAuthMocks([Callback? customHandlers]) {
  TestWidgetsFlutterBinding.ensureInitialized();

  setupFirebaseCoreMocks();
}

Future<T> neverEndingFuture<T>() async {
  // ignore: literal_only_boolean_expressions
  while (true) {
    await Future.delayed(const Duration(minutes: 5));
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\test\user_test.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_auth_platform_interface/firebase_auth_platform_interface.dart';
import 'package:firebase_auth_platform_interface/src/method_channel/method_channel_firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
// import 'package:mockito/annotations.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';

// import './user_test.mocks.dart';
import './mock.dart';
import 'firebase_auth_test.dart';

Map<String, dynamic> kMockUser1 = <String, dynamic>{
  'isAnonymous': true,
  'emailVerified': false,
  'displayName': 'displayName',
};

// @GenerateMocks([], customMocks: [
//   MockSpec<MockFirebaseAuthPlatformBase>(as: #MockFirebaseAuthPlatform),
//   MockSpec<MockUserPlatformBase>(as: #MockUserPlatform),
// ])
void main() {
  setupFirebaseAuthMocks();

  late FirebaseAuth auth;

  final kMockIdTokenResult = PigeonIdTokenResult(
    token: '12345',
    expirationTimestamp: 123456,
    authTimestamp: 1234567,
    issuedAtTimestamp: 12345678,
    signInProvider: 'password',
    claims: {
      'claim1': 'value1',
    },
  );

  final int kMockCreationTimestamp =
      DateTime.now().subtract(const Duration(days: 2)).millisecondsSinceEpoch;
  final int kMockLastSignInTimestamp =
      DateTime.now().subtract(const Duration(days: 1)).millisecondsSinceEpoch;

  final kMockUser = PigeonUserDetails(
    userInfo: PigeonUserInfo(
      uid: '12345',
      displayName: 'displayName',
      creationTimestamp: kMockCreationTimestamp,
      lastSignInTimestamp: kMockLastSignInTimestamp,
      isAnonymous: true,
      isEmailVerified: false,
    ),
    providerData: [
      {
        'providerId': 'firebase',
        'uid': '12345',
        'displayName': 'Flutter Test User',
        'photoUrl': null,
        'email': 'test@example.com',
        'isAnonymous': true,
        'isEmailVerified': false,
      }
    ],
  );
  late MockUserPlatform mockUserPlatform;
  late MockUserCredentialPlatform mockUserCredPlatform;

  AdditionalUserInfo mockAdditionalInfo = AdditionalUserInfo(
    isNewUser: false,
    username: 'flutterUser',
    providerId: 'testProvider',
    profile: <String, dynamic>{'foo': 'bar'},
  );

  EmailAuthCredential mockCredential =
      EmailAuthProvider.credential(email: 'test', password: 'test')
          as EmailAuthCredential;

  var mockAuthPlatform = MockFirebaseAuth();

  group('$User', () {
    late PigeonUserDetails user;

    // used to generate a unique application name for each test
    var testCount = 0;

    setUp(() async {
      FirebaseAuthPlatform.instance = mockAuthPlatform = MockFirebaseAuth();

      // Each test uses a unique FirebaseApp instance to avoid sharing state
      final app = await Firebase.initializeApp(
        name: '$testCount',
        options: const FirebaseOptions(
          apiKey: '',
          appId: '',
          messagingSenderId: '',
          projectId: '',
        ),
      );

      auth = FirebaseAuth.instanceFor(app: app);

      user = kMockUser;

      mockUserPlatform = MockUserPlatform(mockAuthPlatform, user);

      mockUserCredPlatform = MockUserCredentialPlatform(
        FirebaseAuthPlatform.instance,
        mockAdditionalInfo,
        mockCredential,
        mockUserPlatform,
      );

      when(mockAuthPlatform.signInAnonymously()).thenAnswer(
          (_) => Future<UserCredentialPlatform>.value(mockUserCredPlatform));

      when(mockAuthPlatform.currentUser).thenReturn(mockUserPlatform);

      when(mockAuthPlatform.delegateFor(
        app: anyNamed('app'),
      )).thenAnswer((_) => mockAuthPlatform);

      when(mockAuthPlatform.setInitialValues(
        currentUser: anyNamed('currentUser'),
        languageCode: anyNamed('languageCode'),
      )).thenAnswer((_) => mockAuthPlatform);

      TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger
          .setMockMethodCallHandler(MethodChannelFirebaseAuth.channel,
              (call) async {
        switch (call.method) {
          default:
            return <String, dynamic>{'user': user};
        }
      });
    });

    tearDown(() => testCount++);

    setUp(() async {
      user = kMockUser;
      await auth.signInAnonymously();
    });

    test('delete()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.delete()).thenAnswer((i) async {});

      await auth.currentUser!.delete();

      verify(mockUserPlatform.delete());
    });

    test('getIdToken()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.getIdToken(any)).thenAnswer((_) async => 'token');

      final token = await auth.currentUser!.getIdToken(true);

      verify(mockUserPlatform.getIdToken(true));
      expect(token, isA<String>());
    });

    test('getIdTokenResult()', () async {
      when(mockUserPlatform.getIdTokenResult(any))
          .thenAnswer((_) async => IdTokenResult(kMockIdTokenResult));

      final idTokenResult = await auth.currentUser!.getIdTokenResult(true);

      verify(mockUserPlatform.getIdTokenResult(true));
      expect(idTokenResult, isA<IdTokenResult>());
    });

    group('linkWithCredential()', () {
      setUp(() {
        when(mockUserPlatform.linkWithCredential(any))
            .thenAnswer((_) async => mockUserCredPlatform);
      });

      test('should call linkWithCredential()', () async {
        String newEmail = 'new@email.com';
        EmailAuthCredential credential =
            EmailAuthProvider.credential(email: newEmail, password: 'test')
                as EmailAuthCredential;

        await auth.currentUser!.linkWithCredential(credential);

        verify(mockUserPlatform.linkWithCredential(credential));
      });
    });

    group('reauthenticateWithCredential()', () {
      setUp(() {
        when(mockUserPlatform.reauthenticateWithCredential(any))
            .thenAnswer((_) => Future.value(mockUserCredPlatform));
      });
      test('should call reauthenticateWithCredential()', () async {
        String newEmail = 'new@email.com';
        EmailAuthCredential credential =
            EmailAuthProvider.credential(email: newEmail, password: 'test')
                as EmailAuthCredential;

        await auth.currentUser!.reauthenticateWithCredential(credential);

        verify(mockUserPlatform.reauthenticateWithCredential(credential));
      });
    });

    test('reload()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.reload()).thenAnswer((i) async {});

      await auth.currentUser!.reload();

      verify(mockUserPlatform.reload());
    });

    test('sendEmailVerification()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.sendEmailVerification(any))
          .thenAnswer((i) async {});

      final ActionCodeSettings actionCodeSettings =
          ActionCodeSettings(url: 'test');

      await auth.currentUser!.sendEmailVerification(actionCodeSettings);

      verify(mockUserPlatform.sendEmailVerification(actionCodeSettings));
    });

    group('unlink()', () {
      setUp(() {
        when(mockUserPlatform.unlink(any))
            .thenAnswer((_) => Future.value(mockUserPlatform));
      });
      test('should call unlink()', () async {
        const String providerId = 'providerId';

        await auth.currentUser!.unlink(providerId);

        verify(mockUserPlatform.unlink(providerId));
      });
    });

    group('updatePassword()', () {
      test('should call updatePassword()', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockUserPlatform.updatePassword(any)).thenAnswer((i) async {});

        const String newPassword = 'newPassword';

        await auth.currentUser!.updatePassword(newPassword);

        verify(mockUserPlatform.updatePassword(newPassword));
      });
    });
    group('updatePhoneNumber()', () {
      test('should call updatePhoneNumber()', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockUserPlatform.updatePhoneNumber(any)).thenAnswer((i) async {});

        PhoneAuthCredential phoneAuthCredential = PhoneAuthProvider.credential(
          verificationId: 'test',
          smsCode: 'test',
        );

        await auth.currentUser!.updatePhoneNumber(phoneAuthCredential);

        verify(mockUserPlatform.updatePhoneNumber(phoneAuthCredential));
      });
    });

    test('updateProfile()', () async {
      // Necessary as we otherwise get a "null is not a Future<void>" error
      when(mockUserPlatform.updateProfile(any)).thenAnswer((i) async {});

      const String displayName = 'updatedName';
      const String photoURL = 'testUrl';
      Map<String, String> data = <String, String>{
        'displayName': displayName,
        'photoURL': photoURL
      };

      await auth.currentUser!
          // ignore: deprecated_member_use_from_same_package
          .updateProfile(displayName: displayName, photoURL: photoURL);

      verify(mockUserPlatform.updateProfile(data));
    });

    group('verifyBeforeUpdateEmail()', () {
      test('should call verifyBeforeUpdateEmail()', () async {
        // Necessary as we otherwise get a "null is not a Future<void>" error
        when(mockUserPlatform.verifyBeforeUpdateEmail(any, any))
            .thenAnswer((i) async {});

        const newEmail = 'new@email.com';
        ActionCodeSettings actionCodeSettings = ActionCodeSettings(url: 'test');

        await auth.currentUser!
            .verifyBeforeUpdateEmail(newEmail, actionCodeSettings);

        verify(mockUserPlatform.verifyBeforeUpdateEmail(
            newEmail, actionCodeSettings));
      });
    });

    test('toString()', () async {
      when(mockAuthPlatform.currentUser).thenReturn(TestUserPlatform(
          mockAuthPlatform, TestMultiFactorPlatform(mockAuthPlatform), user));

      const userInfo = 'UserInfo('
          'displayName: Flutter Test User, '
          'email: test@example.com, '
          'phoneNumber: null, '
          'photoURL: null, '
          'providerId: firebase, '
          'uid: 12345)';

      final userMetadata = 'UserMetadata('
          'creationTime: ${DateTime.fromMillisecondsSinceEpoch(kMockCreationTimestamp, isUtc: true)}, '
          'lastSignInTime: ${DateTime.fromMillisecondsSinceEpoch(kMockLastSignInTimestamp, isUtc: true)})';

      expect(
        auth.currentUser.toString(),
        'User('
        'displayName: displayName, '
        'email: null, '
        'isEmailVerified: false, '
        'isAnonymous: true, '
        'metadata: $userMetadata, '
        'phoneNumber: null, '
        'photoURL: null, '
        'providerData, '
        '[$userInfo], '
        'refreshToken: null, '
        'tenantId: null, '
        'uid: 12345)',
      );
    });
  });
}

class MockFirebaseAuthPlatformBase = TestFirebaseAuthPlatform
    with MockPlatformInterfaceMixin;

class MockUserPlatformBase = TestUserPlatform with MockPlatformInterfaceMixin;

class MockFirebaseAuth extends Mock
    with MockPlatformInterfaceMixin
    implements TestFirebaseAuthPlatform {
  @override
  Future<UserCredentialPlatform> signInAnonymously() {
    return super.noSuchMethod(
      Invocation.method(#signInAnonymously, const []),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  FirebaseAuthPlatform delegateFor(
      {FirebaseApp? app, Persistence? persistence}) {
    return super.noSuchMethod(
      Invocation.method(#delegateFor, const [], {#app: app}),
      returnValue: TestFirebaseAuthPlatform(),
      returnValueForMissingStub: TestFirebaseAuthPlatform(),
    );
  }

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return super.noSuchMethod(
      Invocation.method(#setInitialValues, const [], {
        #currentUser: currentUser,
        #languageCode: languageCode,
      }),
      returnValue: TestFirebaseAuthPlatform(),
      returnValueForMissingStub: TestFirebaseAuthPlatform(),
    );
  }
}

class MockUserPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestUserPlatform {
  MockUserPlatform(FirebaseAuthPlatform auth, PigeonUserDetails _user) {
    TestUserPlatform(auth, TestMultiFactorPlatform(auth), _user);
  }

  @override
  Future<void> delete() {
    return super.noSuchMethod(
      Invocation.method(#delete, []),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> reload() {
    return super.noSuchMethod(
      Invocation.method(#reload, []),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<String> getIdToken(bool? forceRefresh) {
    return super.noSuchMethod(
      Invocation.method(#getIdToken, [forceRefresh]),
      returnValue: neverEndingFuture<String>(),
      returnValueForMissingStub: neverEndingFuture<String>(),
    );
  }

  @override
  Future<UserPlatform> unlink(String? providerId) {
    return super.noSuchMethod(
      Invocation.method(#unlink, [providerId]),
      returnValue: neverEndingFuture<UserPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserPlatform>(),
    );
  }

  @override
  Future<IdTokenResult> getIdTokenResult(bool? forceRefresh) {
    return super.noSuchMethod(
      Invocation.method(#getIdTokenResult, [forceRefresh]),
      returnValue: neverEndingFuture<IdTokenResult>(),
      returnValueForMissingStub: neverEndingFuture<IdTokenResult>(),
    );
  }

  @override
  Future<UserCredentialPlatform> reauthenticateWithCredential(
    AuthCredential? credential,
  ) {
    return super.noSuchMethod(
      Invocation.method(#reauthenticateWithCredential, [credential]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<UserCredentialPlatform> linkWithCredential(
    AuthCredential? credential,
  ) {
    return super.noSuchMethod(
      Invocation.method(#linkWithCredential, [credential]),
      returnValue: neverEndingFuture<UserCredentialPlatform>(),
      returnValueForMissingStub: neverEndingFuture<UserCredentialPlatform>(),
    );
  }

  @override
  Future<void> sendEmailVerification(ActionCodeSettings? actionCodeSettings) {
    return super.noSuchMethod(
      Invocation.method(#sendEmailVerification, [actionCodeSettings]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> updatePassword(String? newPassword) {
    return super.noSuchMethod(
      Invocation.method(#updatePassword, [newPassword]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> updatePhoneNumber(PhoneAuthCredential? phoneCredential) {
    return super.noSuchMethod(
      Invocation.method(#updatePhoneNumber, [phoneCredential]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> updateProfile(Map<String, String?>? profile) {
    return super.noSuchMethod(
      Invocation.method(#updateProfile, [profile]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }

  @override
  Future<void> verifyBeforeUpdateEmail(
    String? newEmail, [
    ActionCodeSettings? actionCodeSettings,
  ]) {
    return super.noSuchMethod(
      Invocation.method(#verifyBeforeUpdateEmail, [
        newEmail,
        actionCodeSettings,
      ]),
      returnValue: neverEndingFuture<void>(),
      returnValueForMissingStub: neverEndingFuture<void>(),
    );
  }
}

class MockUserCredentialPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements TestUserCredentialPlatform {
  MockUserCredentialPlatform(
    FirebaseAuthPlatform auth,
    AdditionalUserInfo additionalUserInfo,
    AuthCredential credential,
    UserPlatform userPlatform,
  ) {
    TestUserCredentialPlatform(
      auth,
      additionalUserInfo,
      credential,
      userPlatform,
    );
  }
}

class TestFirebaseAuthPlatform extends FirebaseAuthPlatform {
  TestFirebaseAuthPlatform() : super();

  @override
  FirebaseAuthPlatform delegateFor(
          {FirebaseApp? app, Persistence? persistence}) =>
      this;

  @override
  FirebaseAuthPlatform setInitialValues({
    PigeonUserDetails? currentUser,
    String? languageCode,
  }) {
    return this;
  }
}

class TestUserPlatform extends UserPlatform {
  TestUserPlatform(FirebaseAuthPlatform auth, MultiFactorPlatform multiFactor,
      PigeonUserDetails data)
      : super(auth, multiFactor, data);
}

class TestUserCredentialPlatform extends UserCredentialPlatform {
  TestUserCredentialPlatform(
    FirebaseAuthPlatform auth,
    AdditionalUserInfo additionalUserInfo,
    AuthCredential credential,
    UserPlatform userPlatform,
  ) : super(
            auth: auth,
            additionalUserInfo: additionalUserInfo,
            credential: credential,
            user: userPlatform);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_auth\pubspec.yaml =====
name: firebase_auth
description: Flutter plugin for Firebase Auth, enabling
  authentication using passwords, phone numbers and identity providers
  like Google, Facebook and Twitter.
homepage: https://firebase.google.com/docs/auth
repository: https://github.com/firebase/flutterfire/tree/main/packages/firebase_auth/firebase_auth
version: 6.1.1
topics:
  - firebase
  - authentication
  - identity
  - sign-in
  - sign-up

false_secrets:
  - example/**

environment:
  sdk: '>=3.2.0 <4.0.0'
  flutter: '>=3.16.0'

dependencies:
  firebase_auth_platform_interface: ^8.1.3
  firebase_auth_web: ^6.0.4
  firebase_core: ^4.2.0
  firebase_core_platform_interface: ^6.0.2
  flutter:
    sdk: flutter
  meta: ^1.8.0
dev_dependencies:
  async: ^2.5.0
  flutter_test:
    sdk: flutter
  mockito: ^5.0.0
  plugin_platform_interface: ^2.1.3

flutter:
  plugin:
    platforms:
      android:
        package: io.flutter.plugins.firebase.auth
        pluginClass: FlutterFirebaseAuthPlugin
      ios:
        pluginClass: FLTFirebaseAuthPlugin
      macos:
        pluginClass: FLTFirebaseAuthPlugin
      web:
        default_package: firebase_auth_web
      windows:
        pluginClass: FirebaseAuthPluginCApi

===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\android\src\main\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="io.flutter.plugins.firebase.core">

    <application>
        <service android:name="com.google.firebase.components.ComponentDiscoveryService">
            <meta-data
                android:name="com.google.firebase.components:io.flutter.plugins.firebase.core.FlutterFirebaseCoreRegistrar"
                android:value="com.google.firebase.components.ComponentRegistrar" />
        </service>
    </application>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\android\app\src\debug\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\android\app\src\main\res\drawable\launch_background.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\android\app\src\main\res\drawable-v21\launch_background.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\android\app\src\main\res\values\styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\android\app\src\main\res\values-night\styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\android\app\src\main\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="firebasecoreexample"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\android\app\src\profile\AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\android\app\google-services.json =====
{
  "project_info": {
    "project_number": "406099696497",
    "firebase_url": "https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app",
    "project_id": "flutterfire-e2e-tests",
    "storage_bucket": "flutterfire-e2e-tests.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:d86a91cc7b338b233574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.analytics.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:a241c4b471513a203574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.appcheck.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-7bvmqp0fffe24vm2arng0dtdeh2tvkgl.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.appcheck.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:21d5142deea38dda3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.auth.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-emmujnd7g2ammh5uu9ni6v04p4ateqac.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-in8bfp0nali85oul1o98huoar6eo1vv1.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.auth.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:3ef965ff044efc0b3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dataconnect.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:40da41183cb3d3ff3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.dynamiclinksexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:175ea7a64b2faf5e3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.firestore.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:7ca3394493cc601a3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.functions.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-17qn06u8a0dc717u8ul7s49ampk13lul.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.functions.example",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:6d1c1fbf4688f39c3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.installations.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:74ebb073d7727cd43574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.messaging.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:f54b85cfa36a39f73574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.remoteconfig.example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0d4ed619c031c0ac3574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase.tests"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ib9hj9281l3343cm3nfvvdotaojrthdc.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "5ad0d6d5cbe577ca185b8df246656bebc3957128"
          }
        },
        {
          "client_id": "406099696497-lc54d5l8sp90k39r0bb39ovsgo1s9bek.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase.tests",
            "certificate_hash": "909ca1482ef022bbae45a2db6b6d05d807a4c4aa"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:899c6485cfce26c13574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebase_ui_example"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-ltgvphphcckosvqhituel5km2k3aecg8.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "io.flutter.plugins.firebase_ui_example",
            "certificate_hash": "a4256c0612686b336af6d138a5479b7dc1ee1af6"
          }
        },
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:bc0b12b0605df8633574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecoreexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:0f3f7bfe78b8b7103574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasecrashlyticsexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:406099696497:android:2751af6868a69f073574d0",
        "android_client_info": {
          "package_name": "io.flutter.plugins.firebasestorageexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "406099696497-a12gakvts4epfk5pkio7dphc1anjiggc.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "406099696497-0mofiof3ofcgmpmirb6q0fllvb372sme.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "io.flutter.plugins.firebase.example"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\ios\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json =====
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\ios\Runner\Assets.xcassets\LaunchImage.imageset\Contents.json =====
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\lib\firebase_options.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      // TODO(Lyokone): Remove when FlutterFire CLI updated
      case TargetPlatform.windows:
        return android;
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:0d4ed619c031c0ac3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:acd9c8e17b5e620e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    iosClientId:
        '406099696497-taeapvle10rf355ljcvq5dt134mkghmp.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.tests',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:acd9c8e17b5e620e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com',
    iosClientId:
        '406099696497-taeapvle10rf355ljcvq5dt134mkghmp.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.tests',
  );
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\lib\main.dart =====
// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  String get name => 'foo';

  Future<void> initializeDefault() async {
    FirebaseApp app = await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('Initialized default app $app');
  }

  Future<void> initializeDefaultFromAndroidResource() async {
    if (defaultTargetPlatform != TargetPlatform.android || kIsWeb) {
      print('Not running on Android, skipping');
      return;
    }
    FirebaseApp app = await Firebase.initializeApp();
    print('Initialized default app $app from Android resource');
  }

  Future<void> initializeSecondary() async {
    FirebaseApp app = await Firebase.initializeApp(
      name: name,
      options: DefaultFirebaseOptions.currentPlatform,
    );

    print('Initialized $app');
  }

  void apps() {
    final List<FirebaseApp> apps = Firebase.apps;
    print('Currently initialized apps: $apps');
  }

  void options() {
    final FirebaseApp app = Firebase.app();
    final options = app.options;
    print('Current options for app ${app.name}: $options');
  }

  Future<void> delete() async {
    final FirebaseApp app = Firebase.app(name);
    await app.delete();
    print('App $name deleted');
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Firebase Core example app'),
        ),
        body: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              ElevatedButton(
                onPressed: initializeDefault,
                child: const Text('Initialize default app'),
              ),
              if (defaultTargetPlatform == TargetPlatform.android && !kIsWeb)
                ElevatedButton(
                  onPressed: initializeDefaultFromAndroidResource,
                  child: const Text(
                    'Initialize default app from Android resources',
                  ),
                ),
              ElevatedButton(
                onPressed: initializeSecondary,
                child: const Text('Initialize secondary app'),
              ),
              ElevatedButton(
                onPressed: apps,
                child: const Text('List apps'),
              ),
              ElevatedButton(
                onPressed: options,
                child: const Text('List default options'),
              ),
              ElevatedButton(
                onPressed: delete,
                child: const Text('Delete secondary app'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\macos\Runner\Assets.xcassets\AppIcon.appiconset\Contents.json =====
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\web\manifest.json =====
{
    "name": "flutterfire_core",
    "short_name": "flutterfire_core",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\analysis_options.yaml =====
# Copyright 2021 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# in the LICENSE file.

include: ../../../../analysis_options.yaml
linter:
  rules:
    avoid_print: false
    depend_on_referenced_packages: false
    library_private_types_in_public_api: false
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\pubspec.yaml =====
name: firebase_core_example
description: Demonstrates how to use the firebase_core plugin.

environment:
  sdk: '>=3.2.0 <4.0.0'

dependencies:
  firebase_core: ^4.2.0
  flutter:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\lib\src\firebase.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_core.dart';

/// The entry point for accessing Firebase.
class Firebase {
  // Ensures end-users cannot initialize the class.
  Firebase._();

  // Cached & lazily loaded instance of [FirebasePlatform].
  // Avoids a [MethodChannelFirebase] being initialized until the user
  // starts using Firebase.
  // The property is visible for testing to allow tests to set a mock
  // instance directly as a static property since the class is not initialized.
  @visibleForTesting
  // ignore: public_member_api_docs
  static FirebasePlatform? delegatePackingProperty;

  static FirebasePlatform get _delegate {
    return delegatePackingProperty ??= FirebasePlatform.instance;
  }

  /// Returns a list of all [FirebaseApp] instances that have been created.
  static List<FirebaseApp> get apps {
    return _delegate.apps.map(FirebaseApp._).toList(growable: false);
  }

  /// Initializes a new [FirebaseApp] instance by [name] and [options] and
  /// returns the created app. This method should be called before any usage of
  /// FlutterFire plugins.
  ///
  /// If a [demoProjectId] is provided, a new [FirebaseApp] instance will be
  /// initialized with a set of default options for demo projects, overriding
  /// the [options] argument. If no [name] is provided alongside a
  /// [demoProjectId], the [demoProjectId] will be used as the app name. By
  /// convention, the [demoProjectId] should begin with "demo-".
  ///
  /// The default app instance can be initialized here simply by passing no "name" as an argument
  /// in both Dart & manual initialization flows.
  /// If you have a `google-services.json` file in your android project or a `GoogleService-Info.plist` file in your iOS+ project,
  /// it will automatically create a default (named "[DEFAULT]") app instance on the native platform. However, you will still need to call this method
  /// before using any FlutterFire plugins.
  static Future<FirebaseApp> initializeApp({
    String? name,
    FirebaseOptions? options,
    String? demoProjectId,
  }) async {
    if (demoProjectId != null) {
      late final String platformString;
      if (defaultTargetPlatform == TargetPlatform.android) {
        platformString = 'android';
      } else if (defaultTargetPlatform == TargetPlatform.iOS ||
          defaultTargetPlatform == TargetPlatform.macOS) {
        platformString = 'ios';
      } else {
        // We use 'web' as the default platform for unknown platforms.
        platformString = 'web';
      }
      // A name must be set, otherwise [DEFAULT] will be used and the options
      // we've provided will be ignored if any platform specific configuration
      // files exist (i.e. GoogleService-Info.plist for iOS).
      name ??= demoProjectId;
      // The user should not set any options if they specify a demo project
      // id, but it was allowed when this API was first added, so we allow it
      // for backwards compatibility and simply override the user-provided
      // options.
      options = FirebaseOptions(
        apiKey: '12345',
        appId: '1:1:$platformString:1',
        messagingSenderId: '',
        projectId: demoProjectId,
      );
      // Now fall through to the normal initialization logic.
    }
    FirebaseAppPlatform app = await _delegate.initializeApp(
      name: name,
      options: options,
    );

    return FirebaseApp._(app);
  }

  /// Returns a [FirebaseApp] instance.
  ///
  /// If no name is provided, the default app instance is returned.
  /// Throws if the app does not exist.
  static FirebaseApp app([String name = defaultFirebaseAppName]) {
    FirebaseAppPlatform app = _delegate.app(name);

    return FirebaseApp._(app);
  }

  // TODO(rrousselGit): remove ==/hashCode
  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Firebase) return false;
    return other.hashCode == hashCode;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => toString().hashCode;

  @override
  String toString() => '$Firebase';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\lib\src\firebase_app.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_core.dart';

/// Represents a single Firebase app instance.
///
/// You can get an instance by calling [Firebase.app()].
class FirebaseApp {
  /// A [FirebaseApp] instance can only be accessed from a call to `app()` on
  /// [FirebaseCore].
  ///
  /// This constructor ensures that the delegate instance it is
  /// constructed with is one which extends [FirebaseAppPlatform].
  FirebaseApp._(this._delegate) {
    FirebaseAppPlatform.verify(_delegate);
  }

  final FirebaseAppPlatform _delegate;

  /// Deletes this app and frees up system resources.
  ///
  /// Once deleted, any plugin functionality using this app instance will throw
  /// an error.
  ///
  /// Deleting the default app is not possible and throws an exception.
  Future<void> delete() async {
    await _delegate.delete();
  }

  /// The name of this [FirebaseApp].
  String get name => _delegate.name;

  /// The [FirebaseOptions] this app was created with.
  FirebaseOptions get options => _delegate.options;

  /// Returns whether automatic data collection is enabled or disabled for this
  /// app.
  ///
  /// Automatic data collection can be enabled or disabled via `setAutomaticDataCollectionEnabled`.
  bool get isAutomaticDataCollectionEnabled =>
      _delegate.isAutomaticDataCollectionEnabled;

  /// Sets whether automatic data collection is enabled or disabled for this
  /// app.
  ///
  /// To check whether it is currently enabled or not, call [isAutomaticDataCollectionEnabled].
  Future<void> setAutomaticDataCollectionEnabled(bool enabled) {
    return _delegate.setAutomaticDataCollectionEnabled(enabled);
  }

  /// Sets whether automatic resource management is enabled or disabled for this
  /// app.
  Future<void> setAutomaticResourceManagementEnabled(bool enabled) {
    return _delegate.setAutomaticResourceManagementEnabled(enabled);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! FirebaseApp) return false;
    return other.name == name && other.options == options;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hash(name, options);

  @override
  String toString() => '$FirebaseApp($name)';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\lib\src\port_mapping.dart =====
// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../firebase_core.dart';

String getMappedHost(String originalHost) {
  String mappedHost = originalHost;

  if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
    if (mappedHost == 'localhost' || mappedHost == '127.0.0.1') {
      // ignore: avoid_print
      print('Mapping Auth Emulator host "$mappedHost" to "10.0.2.2".');
      mappedHost = '10.0.2.2';
    }
  }
  return mappedHost;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\lib\firebase_core.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    hide MethodChannelFirebaseApp, MethodChannelFirebase;
import 'package:flutter/foundation.dart';

export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseOptions, defaultFirebaseAppName, FirebaseException;

part 'src/firebase.dart';
part 'src/firebase_app.dart';
part 'src/port_mapping.dart';
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\test\firebase_core_test.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  group('$FirebaseApp', () {
    final mock = MockFirebaseCore();

    const FirebaseOptions testOptions = FirebaseOptions(
      apiKey: 'apiKey',
      appId: 'appId',
      messagingSenderId: 'messagingSenderId',
      projectId: 'projectId',
    );

    String testAppName = 'testApp';

    setUp(() async {
      clearInteractions(mock);
      Firebase.delegatePackingProperty = mock;

      final FirebaseAppPlatform platformApp =
          FirebaseAppPlatform(testAppName, testOptions);

      when(mock.apps).thenReturn([platformApp]);
      when(mock.app(testAppName)).thenReturn(platformApp);
      when(mock.initializeApp(name: testAppName, options: testOptions))
          .thenAnswer((_) {
        return Future.value(platformApp);
      });
    });

    test('.apps', () {
      List<FirebaseApp> apps = Firebase.apps;
      verify(mock.apps);
      expect(apps[0], Firebase.app(testAppName));
    });

    test('.app()', () {
      FirebaseApp app = Firebase.app(testAppName);
      verify(mock.app(testAppName));

      expect(app.name, testAppName);
      expect(app.options, testOptions);
    });

    test('.initializeApp()', () async {
      FirebaseApp initializedApp =
          await Firebase.initializeApp(name: testAppName, options: testOptions);
      FirebaseApp app = Firebase.app(testAppName);

      expect(initializedApp, app);
      verifyInOrder([
        mock.initializeApp(name: testAppName, options: testOptions),
        mock.app(testAppName),
      ]);
    });
  });

  test('.initializeApp() with demoProjectId', () async {
    const String demoProjectId = 'demo-project-id';
    const String expectedName = demoProjectId;
    const FirebaseOptions expectedOptions = FirebaseOptions(
      apiKey: '12345',
      // Flutter tests use android as the default platform.
      appId: '1:1:android:1',
      messagingSenderId: '',
      projectId: demoProjectId,
    );

    final mock = MockFirebaseCore();
    Firebase.delegatePackingProperty = mock;

    final FirebaseAppPlatform platformApp =
        FirebaseAppPlatform(expectedName, expectedOptions);

    when(mock.apps).thenReturn([platformApp]);
    when(mock.app(expectedName)).thenReturn(platformApp);
    when(mock.initializeApp(name: expectedName, options: expectedOptions))
        .thenAnswer((_) => Future.value(platformApp));

    // Initialize the app with only a demo project id. The implementation will
    // set the name and options accordingly.
    FirebaseApp initializedApp = await Firebase.initializeApp(
      demoProjectId: demoProjectId,
    );
    FirebaseApp app = Firebase.app(expectedName);

    expect(initializedApp, app);
    verifyInOrder([
      mock.initializeApp(
        name: expectedName,
        options: expectedOptions,
      ),
      mock.app(expectedName),
    ]);
  });
}

class MockFirebaseCore extends Mock
    with
        // ignore: prefer_mixin, plugin_platform_interface needs to migrate to use `mixin`
        MockPlatformInterfaceMixin
    implements
        FirebasePlatform {
  @override
  FirebaseAppPlatform app([String name = defaultFirebaseAppName]) {
    return super.noSuchMethod(
      Invocation.method(#app, [name]),
      returnValue: FakeFirebaseAppPlatform(),
      returnValueForMissingStub: FakeFirebaseAppPlatform(),
    );
  }

  @override
  Future<FirebaseAppPlatform> initializeApp({
    String? name,
    FirebaseOptions? options,
  }) {
    return super.noSuchMethod(
      Invocation.method(
        #initializeApp,
        const [],
        {
          #name: name,
          #options: options,
        },
      ),
      returnValue: Future.value(FakeFirebaseAppPlatform()),
      returnValueForMissingStub: Future.value(FakeFirebaseAppPlatform()),
    );
  }

  @override
  List<FirebaseAppPlatform> get apps {
    return super.noSuchMethod(
      Invocation.getter(#apps),
      returnValue: <FirebaseAppPlatform>[],
      returnValueForMissingStub: <FirebaseAppPlatform>[],
    );
  }
}

// ignore: avoid_implementing_value_types
class FakeFirebaseAppPlatform extends Fake implements FirebaseAppPlatform {}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\pubspec.yaml =====
name: firebase_core
description: Flutter plugin for Firebase Core, enabling connecting to multiple
  Firebase apps.
homepage: https://firebase.google.com/docs/flutter/setup
repository: https://github.com/firebase/flutterfire/tree/main/packages/firebase_core/firebase_core
version: 4.2.0
topics:
  - firebase
  - core

false_secrets:
  - example/**

environment:
  sdk: '>=3.2.0 <4.0.0'
  flutter: '>=3.3.0'

dependencies:
  firebase_core_platform_interface: ^6.0.2
  firebase_core_web: ^3.2.0
  flutter:
    sdk: flutter
  meta: ^1.8.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  mockito: ^5.0.0
  plugin_platform_interface: ^2.1.3

flutter:
  plugin:
    platforms:
      android:
        package: io.flutter.plugins.firebase.core
        pluginClass: FlutterFirebaseCorePlugin
      ios:
        pluginClass: FLTFirebaseCorePlugin
      macos:
        pluginClass: FLTFirebaseCorePlugin
      web:
        default_package: firebase_core_web
      windows:
        pluginClass: FirebaseCorePluginCApi

firebase:
  google_services_gradle_plugin_version: '4.3.15'
  crashlytics_gradle_plugin_version: '2.8.1'
  performance_gradle_plugin_version: '1.4.1'
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mime/mime.dart';
import 'package:video_player/video_player.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'Image Picker Demo',
      home: MyHomePage(title: 'Image Picker Example'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, this.title});

  final String? title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  List<XFile>? _mediaFileList;

  // This must be called from within a setState() callback
  void _setImageFileListFromFile(XFile? value) {
    _mediaFileList = value == null ? null : <XFile>[value];
  }

  dynamic _pickImageError;
  bool _isVideo = false;

  VideoPlayerController? _controller;
  VideoPlayerController? _toBeDisposed;
  String? _retrieveDataError;

  final ImagePickerPlatform _picker = ImagePickerPlatform.instance;
  final TextEditingController maxWidthController = TextEditingController();
  final TextEditingController maxHeightController = TextEditingController();
  final TextEditingController qualityController = TextEditingController();

  Future<void> _playVideo(XFile? file) async {
    if (file != null && mounted) {
      await _disposeVideoController();
      final VideoPlayerController controller =
          VideoPlayerController.file(File(file.path));
      _controller = controller;
      await controller.setVolume(1.0);
      await controller.initialize();
      await controller.setLooping(true);
      await controller.play();
      setState(() {});
    }
  }

  Future<void> _onImageButtonPressed(
    ImageSource source, {
    required BuildContext context,
    bool allowMultiple = false,
    bool isMedia = false,
  }) async {
    if (_controller != null) {
      await _controller!.setVolume(0.0);
    }
    if (context.mounted) {
      if (_isVideo) {
        final List<XFile> files;
        if (allowMultiple) {
          files = await _picker.getMultiVideoWithOptions();
        } else {
          final XFile? file = await _picker.getVideo(
              source: source, maxDuration: const Duration(seconds: 10));
          files = <XFile>[if (file != null) file];
        }
        if (files.isNotEmpty && context.mounted) {
          _showPickedSnackBar(context, files);
          // Just play the first file, to keep the example simple.
          await _playVideo(files.first);
        }
      } else if (allowMultiple) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final ImageOptions imageOptions = ImageOptions(
              maxWidth: maxWidth,
              maxHeight: maxHeight,
              imageQuality: quality,
            );
            final List<XFile> pickedFileList = isMedia
                ? await _picker.getMedia(
                    options: MediaOptions(
                      allowMultiple: allowMultiple,
                      imageOptions: imageOptions,
                    ),
                  )
                : await _picker.getMultiImageWithOptions(
                    options: MultiImagePickerOptions(
                      imageOptions: imageOptions,
                    ),
                  );
            if (pickedFileList.isNotEmpty && context.mounted) {
              _showPickedSnackBar(context, pickedFileList);
            }
            setState(() {
              _mediaFileList = pickedFileList;
            });
          } catch (e) {
            setState(() {
              _pickImageError = e;
            });
          }
        });
      } else if (isMedia) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final List<XFile> pickedFileList = <XFile>[];
            final XFile? media = _firstOrNull(await _picker.getMedia(
              options: MediaOptions(
                  allowMultiple: allowMultiple,
                  imageOptions: ImageOptions(
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    imageQuality: quality,
                  )),
            ));

            if (media != null) {
              pickedFileList.add(media);
              setState(() {
                _mediaFileList = pickedFileList;
              });
            }
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      } else {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final XFile? pickedFile = await _picker.getImageFromSource(
              source: source,
              options: ImagePickerOptions(
                maxWidth: maxWidth,
                maxHeight: maxHeight,
                imageQuality: quality,
              ),
            );
            if (pickedFile != null && context.mounted) {
              _showPickedSnackBar(context, <XFile>[pickedFile]);
            }
            setState(() => _setImageFileListFromFile(pickedFile));
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      }
    }
  }

  @override
  void deactivate() {
    if (_controller != null) {
      _controller!.setVolume(0.0);
      _controller!.pause();
    }
    super.deactivate();
  }

  @override
  void dispose() {
    _disposeVideoController();
    maxWidthController.dispose();
    maxHeightController.dispose();
    qualityController.dispose();
    super.dispose();
  }

  Future<void> _disposeVideoController() async {
    if (_toBeDisposed != null) {
      await _toBeDisposed!.dispose();
    }
    _toBeDisposed = _controller;
    _controller = null;
  }

  Widget _previewVideo() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_controller == null) {
      return const Text(
        'You have not yet picked a video',
        textAlign: TextAlign.center,
      );
    }
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: AspectRatioVideo(_controller),
    );
  }

  Widget _previewImages() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_mediaFileList != null) {
      return Semantics(
        label: 'image_picker_example_picked_images',
        child: ListView.builder(
          key: UniqueKey(),
          itemBuilder: (BuildContext context, int index) {
            final XFile image = _mediaFileList![index];
            final String? mime = lookupMimeType(_mediaFileList![index].path);
            return Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                Text(image.name,
                    key: const Key('image_picker_example_picked_image_name')),
                Semantics(
                  label: 'image_picker_example_picked_image',
                  child: mime == null || mime.startsWith('image/')
                      ? Image.file(
                          File(_mediaFileList![index].path),
                          errorBuilder: (BuildContext context, Object error,
                              StackTrace? stackTrace) {
                            return const Center(
                                child:
                                    Text('This image type is not supported'));
                          },
                        )
                      : _buildInlineVideoPlayer(index),
                ),
              ],
            );
          },
          itemCount: _mediaFileList!.length,
        ),
      );
    } else if (_pickImageError != null) {
      return Text(
        'Pick image error: $_pickImageError',
        textAlign: TextAlign.center,
      );
    } else {
      return const Text(
        'You have not yet picked an image.',
        textAlign: TextAlign.center,
      );
    }
  }

  Widget _buildInlineVideoPlayer(int index) {
    final VideoPlayerController controller =
        VideoPlayerController.file(File(_mediaFileList![index].path));
    controller.setVolume(1.0);
    controller.initialize();
    controller.setLooping(true);
    controller.play();
    return Center(child: AspectRatioVideo(controller));
  }

  Widget _handlePreview() {
    if (_isVideo) {
      return _previewVideo();
    } else {
      return _previewImages();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title!),
      ),
      body: Align(
        alignment: Alignment.topCenter,
        child: _handlePreview(),
      ),
      floatingActionButton: Column(
        mainAxisAlignment: MainAxisAlignment.end,
        children: <Widget>[
          Semantics(
            label: 'image_picker_example_from_gallery',
            child: FloatingActionButton.extended(
              key: const Key('image_picker_example_from_gallery'),
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'image0',
              tooltip: 'Pick image from gallery',
              label: const Text('Pick image from gallery'),
              icon: const Icon(Icons.photo),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  allowMultiple: true,
                );
              },
              heroTag: 'image1',
              tooltip: 'Pick multiple images',
              label: const Text('Pick multiple images'),
              icon: const Icon(Icons.photo_library),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMedia: true,
                );
              },
              heroTag: 'media',
              tooltip: 'Pick item from gallery',
              label: const Text('Pick item from gallery'),
              icon: const Icon(Icons.photo_outlined),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  allowMultiple: true,
                  isMedia: true,
                );
              },
              heroTag: 'multipleMedia',
              tooltip: 'Pick multiple items',
              label: const Text('Pick multiple items'),
              icon: const Icon(Icons.photo_library_outlined),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton.extended(
                onPressed: () {
                  _isVideo = false;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'image2',
                tooltip: 'Take a photo',
                label: const Text('Take a photo'),
                icon: const Icon(Icons.camera_alt),
              ),
            ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'video',
              tooltip: 'Pick video from gallery',
              label: const Text('Pick video from gallery'),
              icon: const Icon(Icons.video_file),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery,
                    context: context, allowMultiple: true);
              },
              heroTag: 'multiVideo',
              tooltip: 'Pick multiple videos',
              label: const Text('Pick multiple videos'),
              icon: const Icon(Icons.video_library),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton.extended(
                backgroundColor: Colors.red,
                onPressed: () {
                  _isVideo = true;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'takeVideo',
                tooltip: 'Take a video',
                label: const Text('Take a video'),
                icon: const Icon(Icons.videocam),
              ),
            ),
        ],
      ),
    );
  }

  Text? _getRetrieveErrorWidget() {
    if (_retrieveDataError != null) {
      final Text result = Text(_retrieveDataError!);
      _retrieveDataError = null;
      return result;
    }
    return null;
  }

  Future<void> _displayPickImageDialog(
      BuildContext context, OnPickImageCallback onPick) async {
    return showDialog(
        context: context,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('Add optional parameters'),
            content: Column(
              children: <Widget>[
                TextField(
                  controller: maxWidthController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxWidth if desired'),
                ),
                TextField(
                  controller: maxHeightController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxHeight if desired'),
                ),
                TextField(
                  controller: qualityController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                      hintText: 'Enter quality if desired'),
                ),
              ],
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('CANCEL'),
                onPressed: () {
                  Navigator.of(context).pop();
                },
              ),
              TextButton(
                  child: const Text('PICK'),
                  onPressed: () {
                    final double? width = maxWidthController.text.isNotEmpty
                        ? double.parse(maxWidthController.text)
                        : null;
                    final double? height = maxHeightController.text.isNotEmpty
                        ? double.parse(maxHeightController.text)
                        : null;
                    final int? quality = qualityController.text.isNotEmpty
                        ? int.parse(qualityController.text)
                        : null;
                    onPick(width, height, quality);
                    Navigator.of(context).pop();
                  }),
            ],
          );
        });
  }

  void _showPickedSnackBar(BuildContext context, List<XFile> files) {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text('Picked: ${files.map((XFile it) => it.name).join(',')}'),
      duration: const Duration(seconds: 2),
    ));
  }
}

typedef OnPickImageCallback = void Function(
    double? maxWidth, double? maxHeight, int? quality);

class AspectRatioVideo extends StatefulWidget {
  const AspectRatioVideo(this.controller, {super.key});

  final VideoPlayerController? controller;

  @override
  AspectRatioVideoState createState() => AspectRatioVideoState();
}

class AspectRatioVideoState extends State<AspectRatioVideo> {
  VideoPlayerController? get controller => widget.controller;
  bool initialized = false;

  void _onVideoControllerUpdate() {
    if (!mounted) {
      return;
    }
    if (initialized != controller!.value.isInitialized) {
      initialized = controller!.value.isInitialized;
      setState(() {});
    }
  }

  @override
  void initState() {
    super.initState();
    controller!.addListener(_onVideoControllerUpdate);
  }

  @override
  void dispose() {
    controller!.removeListener(_onVideoControllerUpdate);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (initialized) {
      return Center(
        child: AspectRatio(
          aspectRatio: controller!.value.aspectRatio,
          child: VideoPlayer(controller!),
        ),
      );
    } else {
      return Container();
    }
  }
}

T? _firstOrNull<T>(List<T> list) {
  return list.isEmpty ? null : list.first;
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\example\pubspec.yaml =====
name: example
description: Example for image_picker_windows implementation.
publish_to: 'none'
version: 1.0.0

environment:
  sdk: ^3.6.0
  flutter: ">=3.27.0"

dependencies:
  flutter:
    sdk: flutter
  image_picker_platform_interface: ^2.11.0
  image_picker_windows:
    # When depending on this package from a real application you should use:
    #   image_picker_windows: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ..
  mime: ^2.0.0
  video_player: ^2.1.4

dev_dependencies:
  flutter_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\lib\image_picker_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:flutter/foundation.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';

/// The Windows implementation of [ImagePickerPlatform].
///
/// This class implements the `package:image_picker` functionality for
/// Windows.
class ImagePickerWindows extends CameraDelegatingImagePickerPlatform {
  /// Constructs a ImagePickerWindows.
  ImagePickerWindows();

  /// List of image extensions used when picking images
  @visibleForTesting
  static const List<String> imageFormats = <String>[
    'jpg',
    'jpeg',
    'png',
    'bmp',
    'webp',
    'gif',
    'tif',
    'tiff',
    'apng'
  ];

  /// List of video extensions used when picking videos
  @visibleForTesting
  static const List<String> videoFormats = <String>[
    'mov',
    'wmv',
    'mkv',
    'mp4',
    'webm',
    'avi',
    'mpeg',
    'mpg'
  ];

  /// The file selector used to prompt the user to select images or videos.
  @visibleForTesting
  static FileSelectorPlatform fileSelector = FileSelectorWindows();

  /// Registers this class as the default instance of [ImagePickerPlatform].
  static void registerWith() {
    ImagePickerPlatform.instance = ImagePickerWindows();
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<PickedFile?> pickImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    final XFile? file = await getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getVideo.
  @override
  Future<PickedFile?> pickVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    final XFile? file = await getVideo(
        source: source,
        preferredCameraDevice: preferredCameraDevice,
        maxDuration: maxDuration);
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<XFile?> getImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    return getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
  }

  // [ImagePickerOptions] options are not currently supported. If any
  // of its fields are set, they will be silently ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getImageFromSource({
    required ImageSource source,
    ImagePickerOptions options = const ImagePickerOptions(),
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getImageFromSource(source: source);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Images', extensions: imageFormats);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `preferredCameraDevice` and `maxDuration` arguments are not currently
  // supported. If either of these arguments are supplied, they will be silently
  // ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getVideo(
            source: source,
            preferredCameraDevice: preferredCameraDevice,
            maxDuration: maxDuration);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Videos', extensions: videoFormats);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMultiImage({
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
  }) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Images', extensions: imageFormats);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  @override
  Future<List<XFile>> getMultiVideoWithOptions(
      {MultiVideoPickerOptions options =
          const MultiVideoPickerOptions()}) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Videos', extensions: videoFormats);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not
  // supported on Windows. If any of these arguments is supplied,
  // they will be silently ignored by the Windows version of the plugin.
  @override
  Future<List<XFile>> getMedia({required MediaOptions options}) async {
    const XTypeGroup typeGroup = XTypeGroup(
        label: 'images and videos',
        extensions: <String>[...imageFormats, ...videoFormats]);

    List<XFile> files;

    if (options.allowMultiple) {
      files = await fileSelector
          .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    } else {
      final XFile? file = await fileSelector
          .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
      files = <XFile>[
        if (file != null) file,
      ];
    }
    return files;
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\test\image_picker_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:image_picker_windows/image_picker_windows.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'image_picker_windows_test.mocks.dart';

@GenerateMocks(<Type>[FileSelectorPlatform])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  // Returns the captured type groups from a mock call result, assuming that
  // exactly one call was made and only the type groups were captured.
  List<XTypeGroup> capturedTypeGroups(VerificationResult result) {
    return result.captured.single as List<XTypeGroup>;
  }

  group('ImagePickerWindows', () {
    late ImagePickerWindows plugin;
    late MockFileSelectorPlatform mockFileSelectorPlatform;

    setUp(() {
      plugin = ImagePickerWindows();
      mockFileSelectorPlatform = MockFileSelectorPlatform();

      when(mockFileSelectorPlatform.openFile(
              acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
          .thenAnswer((_) async => null);

      when(mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
          .thenAnswer((_) async => List<XFile>.empty());

      ImagePickerWindows.fileSelector = mockFileSelectorPlatform;
    });

    test('registered instance', () {
      ImagePickerWindows.registerWith();
      expect(ImagePickerPlatform.instance, isA<ImagePickerWindows>());
    });

    group('images', () {
      test('pickImage passes the accepted type groups correctly', () async {
        await plugin.pickImage(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test('getImage passes the accepted type groups correctly', () async {
        await plugin.getImage(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test('getMultiImage passes the accepted type groups correctly', () async {
        await plugin.getMultiImage();

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test(
          'getImageFromSource throws StateError when source is camera with no delegate',
          () async {
        await expectLater(plugin.getImageFromSource(source: ImageSource.camera),
            throwsStateError);
      });

      test('getMultiImage passes the accepted type groups correctly', () async {
        await plugin.getMultiImage();

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });
    });

    group('videos', () {
      test('pickVideo passes the accepted type groups correctly', () async {
        await plugin.pickVideo(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.videoFormats);
      });

      test('getVideo passes the accepted type groups correctly', () async {
        await plugin.getVideo(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.videoFormats);
      });

      test('getVideo calls delegate when source is camera', () async {
        const String fakePath = '/tmp/foo';
        plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
        expect((await plugin.getVideo(source: ImageSource.camera))!.path,
            fakePath);
      });

      test('getVideo throws StateError when source is camera with no delegate',
          () async {
        await expectLater(
            plugin.getVideo(source: ImageSource.camera), throwsStateError);
      });

      test('getMultiVideoWithOptions passes the accepted type groups correctly',
          () async {
        await plugin.getMultiVideoWithOptions();

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.videoFormats);
      });
    });

    group('media', () {
      test('getMedia passes the accepted type groups correctly', () async {
        await plugin.getMedia(options: const MediaOptions(allowMultiple: true));

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions, <String>[
          ...ImagePickerWindows.imageFormats,
          ...ImagePickerWindows.videoFormats
        ]);
      });

      test('multiple media handles an empty path response gracefully',
          () async {
        expect(
            await plugin.getMedia(
              options: const MediaOptions(
                allowMultiple: true,
              ),
            ),
            <String>[]);
      });

      test('single media handles an empty path response gracefully', () async {
        expect(
            await plugin.getMedia(
              options: const MediaOptions(
                allowMultiple: false,
              ),
            ),
            <String>[]);
      });
    });
  });
}

class FakeCameraDelegate extends ImagePickerCameraDelegate {
  FakeCameraDelegate({this.result});

  XFile? result;

  @override
  Future<XFile?> takePhoto(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }

  @override
  Future<XFile?> takeVideo(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\test\image_picker_windows_test.mocks.dart =====
// Mocks generated by Mockito 5.4.4 from annotations
// in image_picker_windows/test/image_picker_windows_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

/// A class which mocks [FileSelectorPlatform].
///
/// See the documentation for Mockito's code generation for more information.
class MockFileSelectorPlatform extends _i1.Mock
    implements _i2.FileSelectorPlatform {
  MockFileSelectorPlatform() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i2.XFile?> openFile({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFile,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<_i2.XFile?>.value(),
      ) as _i3.Future<_i2.XFile?>);

  @override
  _i3.Future<List<_i2.XFile>> openFiles({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFiles,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<_i2.XFile>>.value(<_i2.XFile>[]),
      ) as _i3.Future<List<_i2.XFile>>);

  @override
  _i3.Future<String?> getSavePath({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSavePath,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #suggestedName: suggestedName,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);

  @override
  _i3.Future<_i2.FileSaveLocation?> getSaveLocation({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    _i2.SaveDialogOptions? options = const _i2.SaveDialogOptions(),
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSaveLocation,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #options: options,
          },
        ),
        returnValue: _i3.Future<_i2.FileSaveLocation?>.value(),
      ) as _i3.Future<_i2.FileSaveLocation?>);

  @override
  _i3.Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPath,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);

  @override
  _i3.Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPaths,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<String>>.value(<String>[]),
      ) as _i3.Future<List<String>>);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\pubspec.yaml =====
name: image_picker_windows
description: Windows platform implementation of image_picker
repository: https://github.com/flutter/packages/tree/main/packages/image_picker/image_picker_windows
issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+image_picker%22
version: 0.2.2

environment:
  sdk: ^3.6.0
  flutter: ">=3.27.0"

flutter:
  plugin:
    implements: image_picker
    platforms:
      windows:
        dartPluginClass: ImagePickerWindows

dependencies:
  file_selector_platform_interface: ^2.2.0
  file_selector_windows: ^0.9.0
  flutter:
    sdk: flutter
  image_picker_platform_interface: ^2.11.0

dev_dependencies:
  build_runner: ^2.1.5
  flutter_test:
    sdk: flutter
  mockito: ^5.4.4

topics:
  - image-picker
  - files
  - file-selection
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\integration_test\path_provider_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('getTemporaryDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getTemporaryPath();
    _verifySampleFile(result, 'temporaryDirectory');
  });

  testWidgets('getApplicationDocumentsDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationDocumentsPath();
    _verifySampleFile(result, 'applicationDocuments');
  });

  testWidgets('getApplicationSupportDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationSupportPath();
    _verifySampleFile(result, 'applicationSupport');
  });

  testWidgets('getApplicationCacheDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationCachePath();
    _verifySampleFile(result, 'applicationCache');
  });

  testWidgets('getDownloadsDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getDownloadsPath();
    _verifySampleFile(result, 'downloads');
  });
}

/// Verify a file called [name] in [directoryPath] by recreating it with test
/// contents when necessary.
void _verifySampleFile(String? directoryPath, String name) {
  expect(directoryPath, isNotNull);
  if (directoryPath == null) {
    return;
  }
  final Directory directory = Directory(directoryPath);
  final File file = File('${directory.path}${Platform.pathSeparator}$name');

  if (file.existsSync()) {
    file.deleteSync();
    expect(file.existsSync(), isFalse);
  }

  file.writeAsStringSync('Hello world!');
  expect(file.readAsStringSync(), 'Hello world!');
  expect(directory.listSync(), isNotEmpty);
  file.deleteSync();
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

void main() {
  runApp(const MyApp());
}

/// Sample app
class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _tempDirectory = 'Unknown';
  String? _downloadsDirectory = 'Unknown';
  String? _appSupportDirectory = 'Unknown';
  String? _documentsDirectory = 'Unknown';
  String? _cacheDirectory = 'Unknown';

  @override
  void initState() {
    super.initState();
    initDirectories();
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initDirectories() async {
    String? tempDirectory;
    String? downloadsDirectory;
    String? appSupportDirectory;
    String? documentsDirectory;
    String? cacheDirectory;
    final PathProviderWindows provider = PathProviderWindows();

    try {
      tempDirectory = await provider.getTemporaryPath();
    } catch (exception) {
      tempDirectory = 'Failed to get temp directory: $exception';
    }
    try {
      downloadsDirectory = await provider.getDownloadsPath();
    } catch (exception) {
      downloadsDirectory = 'Failed to get downloads directory: $exception';
    }

    try {
      documentsDirectory = await provider.getApplicationDocumentsPath();
    } catch (exception) {
      documentsDirectory = 'Failed to get documents directory: $exception';
    }

    try {
      appSupportDirectory = await provider.getApplicationSupportPath();
    } catch (exception) {
      appSupportDirectory = 'Failed to get app support directory: $exception';
    }

    try {
      cacheDirectory = await provider.getApplicationCachePath();
    } catch (exception) {
      cacheDirectory = 'Failed to get cache directory: $exception';
    }

    setState(() {
      _tempDirectory = tempDirectory;
      _downloadsDirectory = downloadsDirectory;
      _appSupportDirectory = appSupportDirectory;
      _documentsDirectory = documentsDirectory;
      _cacheDirectory = cacheDirectory;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Path Provider example app'),
        ),
        body: Center(
          child: Column(
            children: <Widget>[
              Text('Temp Directory: $_tempDirectory\n'),
              Text('Documents Directory: $_documentsDirectory\n'),
              Text('Downloads Directory: $_downloadsDirectory\n'),
              Text('Application Support Directory: $_appSupportDirectory\n'),
              Text('Cache Directory: $_cacheDirectory\n'),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\pubspec.yaml =====
name: path_provider_example
description: Demonstrates how to use the path_provider plugin.
publish_to: none

environment:
  sdk: ^3.2.0
  flutter: ">=3.16.0"

dependencies:
  flutter:
    sdk: flutter
  path_provider_windows:
    # When depending on this package from a real application you should use:
    #   path_provider_windows: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ../

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\folders.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: non_constant_identifier_names

// ignore: avoid_classes_with_only_static_members
/// A class containing the GUID references for each of the documented Windows
/// known folders. A property of this class may be passed to the `getPath`
/// method in the [PathProvidersWindows] class to retrieve a known folder from
/// Windows.
// These constants come from
// https://learn.microsoft.com/windows/win32/shell/knownfolderid
class WindowsKnownFolder {
  /// The file system directory that is used to store administrative tools for
  /// an individual user. The MMC will save customized consoles to this
  /// directory, and it will roam with the user.
  static String get AdminTools => '{724EF170-A42D-4FEF-9F26-B60E846FBA4F}';

  /// The file system directory that acts as a staging area for files waiting to
  /// be written to a CD. A typical path is C:\Documents and
  /// Settings\username\Local Settings\Application Data\Microsoft\CD Burning.
  static String get CDBurning => '{9E52AB10-F80D-49DF-ACB8-4330F5687855}';

  /// The file system directory that contains administrative tools for all users
  /// of the computer.
  static String get CommonAdminTools =>
      '{D0384E7D-BAC3-4797-8F14-CBA229B392B5}';

  /// The file system directory that contains the directories for the common
  /// program groups that appear on the Start menu for all users. A typical path
  /// is C:\Documents and Settings\All Users\Start Menu\Programs.
  static String get CommonPrograms => '{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}';

  /// The file system directory that contains the programs and folders that
  /// appear on the Start menu for all users. A typical path is C:\Documents and
  /// Settings\All Users\Start Menu.
  static String get CommonStartMenu => '{A4115719-D62E-491D-AA7C-E74B8BE3B067}';

  /// The file system directory that contains the programs that appear in the
  /// Startup folder for all users. A typical path is C:\Documents and
  /// Settings\All Users\Start Menu\Programs\Startup.
  static String get CommonStartup => '{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}';

  /// The file system directory that contains the templates that are available
  /// to all users. A typical path is C:\Documents and Settings\All
  /// Users\Templates.
  static String get CommonTemplates => '{B94237E7-57AC-4347-9151-B08C6C32D1F7}';

  /// The virtual folder that represents My Computer, containing everything on
  /// the local computer: storage devices, printers, and Control Panel. The
  /// folder can also contain mapped network drives.
  static String get ComputerFolder => '{0AC0837C-BBF8-452A-850D-79D08E667CA7}';

  /// The virtual folder that represents Network Connections, that contains
  /// network and dial-up connections.
  static String get ConnectionsFolder =>
      '{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}';

  /// The virtual folder that contains icons for the Control Panel applications.
  static String get ControlPanelFolder =>
      '{82A74AEB-AEB4-465C-A014-D097EE346D63}';

  /// The file system directory that serves as a common repository for Internet
  /// cookies. A typical path is C:\Documents and Settings\username\Cookies.
  static String get Cookies => '{2B0F765D-C0E9-4171-908E-08A611B84FF6}';

  /// The virtual folder that represents the Windows desktop, the root of the
  /// namespace.
  static String get Desktop => '{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}';

  /// The virtual folder that represents the My Documents desktop item.
  static String get Documents => '{FDD39AD0-238F-46AF-ADB4-6C85480369C7}';

  /// The file system directory that serves as a repository for Internet
  /// downloads.
  static String get Downloads => '{374DE290-123F-4565-9164-39C4925E467B}';

  /// The file system directory that serves as a common repository for the
  /// user's favorite items. A typical path is C:\Documents and
  /// Settings\username\Favorites.
  static String get Favorites => '{1777F761-68AD-4D8A-87BD-30B759FA33DD}';

  /// A virtual folder that contains fonts. A typical path is C:\Windows\Fonts.
  static String get Fonts => '{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}';

  /// The file system directory that serves as a common repository for Internet
  /// history items.
  static String get History => '{D9DC8A3B-B784-432E-A781-5A1130A75963}';

  /// The file system directory that serves as a common repository for temporary
  /// Internet files. A typical path is C:\Documents and Settings\username\Local
  /// Settings\Temporary Internet Files.
  static String get InternetCache => '{352481E8-33BE-4251-BA85-6007CAEDCF9D}';

  /// A virtual folder for Internet Explorer.
  static String get InternetFolder => '{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}';

  /// The file system directory that serves as a data repository for local
  /// (nonroaming) applications. A typical path is C:\Documents and
  /// Settings\username\Local Settings\Application Data.
  static String get LocalAppData => '{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}';

  /// The file system directory that serves as a common repository for music
  /// files. A typical path is C:\Documents and Settings\User\My Documents\My
  /// Music.
  static String get Music => '{4BD8D571-6D19-48D3-BE97-422220080E43}';

  /// A file system directory that contains the link objects that may exist in
  /// the My Network Places virtual folder. A typical path is C:\Documents and
  /// Settings\username\NetHood.
  static String get NetHood => '{C5ABBF53-E17F-4121-8900-86626FC2C973}';

  /// The folder that represents other computers in your workgroup.
  static String get NetworkFolder => '{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}';

  /// The file system directory that serves as a common repository for image
  /// files. A typical path is C:\Documents and Settings\username\My
  /// Documents\My Pictures.
  static String get Pictures => '{33E28130-4E1E-4676-835A-98395C3BC3BB}';

  /// The file system directory that contains the link objects that can exist in
  /// the Printers virtual folder. A typical path is C:\Documents and
  /// Settings\username\PrintHood.
  static String get PrintHood => '{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}';

  /// The virtual folder that contains installed printers.
  static String get PrintersFolder => '{76FC4E2D-D6AD-4519-A663-37BD56068185}';

  /// The user's profile folder. A typical path is C:\Users\username.
  /// Applications should not create files or folders at this level.
  static String get Profile => '{5E6C858F-0E22-4760-9AFE-EA3317B67173}';

  /// The file system directory that contains application data for all users. A
  /// typical path is C:\Documents and Settings\All Users\Application Data. This
  /// folder is used for application data that is not user specific. For
  /// example, an application can store a spell-check dictionary, a database of
  /// clip art, or a log file in the CSIDL_COMMON_APPDATA folder. This
  /// information will not roam and is available to anyone using the computer.
  static String get ProgramData => '{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}';

  /// The Program Files folder. A typical path is C:\Program Files.
  static String get ProgramFiles => '{905e63b6-c1bf-494e-b29c-65b732d3d21a}';

  /// The common Program Files folder. A typical path is C:\Program
  /// Files\Common.
  static String get ProgramFilesCommon =>
      '{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}';

  /// On 64-bit systems, a link to the common Program Files folder. A typical path is
  /// C:\Program Files\Common Files.
  static String get ProgramFilesCommonX64 =>
      '{6365D5A7-0F0D-45e5-87F6-0DA56B6A4F7D}';

  /// On 64-bit systems, a link to the 32-bit common Program Files folder. A
  /// typical path is C:\Program Files (x86)\Common Files. On 32-bit systems, a
  /// link to the Common Program Files folder.
  static String get ProgramFilesCommonX86 =>
      '{DE974D24-D9C6-4D3E-BF91-F4455120B917}';

  /// On 64-bit systems, a link to the Program Files folder. A typical path is
  /// C:\Program Files.
  static String get ProgramFilesX64 => '{6D809377-6AF0-444b-8957-A3773F02200E}';

  /// On 64-bit systems, a link to the 32-bit Program Files folder. A typical
  /// path is C:\Program Files (x86). On 32-bit systems, a link to the Common
  /// Program Files folder.
  static String get ProgramFilesX86 => '{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}';

  /// The file system directory that contains the user's program groups (which
  /// are themselves file system directories).
  static String get Programs => '{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}';

  /// The file system directory that contains files and folders that appear on
  /// the desktop for all users. A typical path is C:\Documents and Settings\All
  /// Users\Desktop.
  static String get PublicDesktop => '{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}';

  /// The file system directory that contains documents that are common to all
  /// users. A typical path is C:\Documents and Settings\All Users\Documents.
  static String get PublicDocuments => '{ED4824AF-DCE4-45A8-81E2-FC7965083634}';

  /// The file system directory that serves as a repository for music files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Music.
  static String get PublicMusic => '{3214FAB5-9757-4298-BB61-92A9DEAA44FF}';

  /// The file system directory that serves as a repository for image files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Pictures.
  static String get PublicPictures => '{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}';

  /// The file system directory that serves as a repository for video files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Videos.
  static String get PublicVideos => '{2400183A-6185-49FB-A2D8-4A392A602BA3}';

  /// The file system directory that contains shortcuts to the user's most
  /// recently used documents. A typical path is C:\Documents and
  /// Settings\username\My Recent Documents.
  static String get Recent => '{AE50C081-EBD2-438A-8655-8A092E34987A}';

  /// The virtual folder that contains the objects in the user's Recycle Bin.
  static String get RecycleBinFolder =>
      '{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}';

  /// The file system directory that contains resource data. A typical path is
  /// C:\Windows\Resources.
  static String get ResourceDir => '{8AD10C31-2ADB-4296-A8F7-E4701232C972}';

  /// The file system directory that serves as a common repository for
  /// application-specific data. A typical path is C:\Documents and
  /// Settings\username\Application Data.
  static String get RoamingAppData => '{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}';

  /// The file system directory that contains Send To menu items. A typical path
  /// is C:\Documents and Settings\username\SendTo.
  static String get SendTo => '{8983036C-27C0-404B-8F08-102D10DCFD74}';

  /// The file system directory that contains Start menu items. A typical path
  /// is C:\Documents and Settings\username\Start Menu.
  static String get StartMenu => '{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}';

  /// The file system directory that corresponds to the user's Startup program
  /// group. The system starts these programs whenever the associated user logs
  /// on. A typical path is C:\Documents and Settings\username\Start
  /// Menu\Programs\Startup.
  static String get Startup => '{B97D20BB-F46A-4C97-BA10-5E3608430854}';

  /// The Windows System folder. A typical path is C:\Windows\System32.
  static String get System => '{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}';

  /// The 32-bit Windows System folder. On 32-bit systems, this is typically
  /// C:\Windows\system32. On 64-bit systems, this is typically
  /// C:\Windows\syswow64.
  static String get SystemX86 => '{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}';

  /// The file system directory that serves as a common repository for document
  /// templates. A typical path is C:\Documents and Settings\username\Templates.
  static String get Templates => '{A63293E8-664E-48DB-A079-DF759E0509F7}';

  /// The file system directory that serves as a common repository for video
  /// files. A typical path is C:\Documents and Settings\username\My
  /// Documents\My Videos.
  static String get Videos => '{18989B1D-99B5-455B-841C-AB7C74E4DDFC}';

  /// The Windows directory or SYSROOT. This corresponds to the %windir% or
  /// %SYSTEMROOT% environment variables. A typical path is C:\Windows.
  static String get Windows => '{F38BF404-1D43-42F2-9305-67DE0B28FC23}';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\folders_stub.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Stub version of the actual class.
class WindowsKnownFolder {}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\guid.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:typed_data';

/// Representation of the Win32 GUID struct.
// For the layout of this struct, see
// https://learn.microsoft.com/windows/win32/api/guiddef/ns-guiddef-guid
@Packed(4)
base class GUID extends Struct {
  /// Native Data1 field.
  @Uint32()
  external int data1;

  /// Native Data2 field.
  @Uint16()
  external int data2;

  /// Native Data3 field.
  @Uint16()
  external int data3;

  /// Native Data4 field.
  // This should be an eight-element byte array, but there's no such annotation.
  @Uint64()
  external int data4;

  /// Parses a GUID string, with optional enclosing "{}"s and optional "-"s,
  /// into data.
  void parse(String guid) {
    final String hexOnly = guid.replaceAll(RegExp(r'[{}-]'), '');
    if (hexOnly.length != 32) {
      throw ArgumentError.value(guid, 'guid', 'Invalid GUID string');
    }
    final ByteData bytes = ByteData(16);
    for (int i = 0; i < 16; ++i) {
      bytes.setUint8(
          i, int.parse(hexOnly.substring(i * 2, i * 2 + 2), radix: 16));
    }
    data1 = bytes.getInt32(0);
    data2 = bytes.getInt16(4);
    data3 = bytes.getInt16(6);
    // [bytes] is big endian, but the host is little endian, so a default
    // big-endian read would reverse the bytes. Since data4 is supposed to be
    // a byte array, the order should be preserved, so do a little-endian read.
    // https://en.wikipedia.org/wiki/Universally_unique_identifier#Encoding
    data4 = bytes.getInt64(8, Endian.little);
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\path_provider_windows_real.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;
import 'package:flutter/services.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

import 'folders.dart';
import 'guid.dart';
import 'win32_wrappers.dart';

/// Constant for en-US language used in VersionInfo keys.
@visibleForTesting
const String languageEn = '0409';

/// Constant for CP1252 encoding used in VersionInfo keys
@visibleForTesting
const String encodingCP1252 = '04e4';

/// Constant for Unicode encoding used in VersionInfo keys
@visibleForTesting
const String encodingUnicode = '04b0';

/// Wraps the Win32 VerQueryValue API call.
///
/// This class exists to allow injecting alternate metadata in tests without
/// building multiple custom test binaries.
@visibleForTesting
class VersionInfoQuerier {
  /// Returns the value for [key] in [versionInfo]s in section with given
  /// language and encoding, or null if there is no such entry,
  /// or if versionInfo is null.
  ///
  /// See https://docs.microsoft.com/windows/win32/menurc/versioninfo-resource
  /// for list of possible language and encoding values.
  String? getStringValue(
    Pointer<Uint8>? versionInfo,
    String key, {
    required String language,
    required String encoding,
  }) {
    assert(language.isNotEmpty);
    assert(encoding.isNotEmpty);
    if (versionInfo == null) {
      return null;
    }
    final Pointer<Utf16> keyPath =
        '\\StringFileInfo\\$language$encoding\\$key'.toNativeUtf16();
    final Pointer<UINT> length = calloc<UINT>();
    final Pointer<Pointer<Utf16>> valueAddress = calloc<Pointer<Utf16>>();
    try {
      if (VerQueryValue(versionInfo, keyPath, valueAddress, length) == 0) {
        return null;
      }
      return valueAddress.value.toDartString();
    } finally {
      calloc.free(keyPath);
      calloc.free(length);
      calloc.free(valueAddress);
    }
  }
}

/// The Windows implementation of [PathProviderPlatform]
///
/// This class implements the `package:path_provider` functionality for Windows.
class PathProviderWindows extends PathProviderPlatform {
  /// Registers the Windows implementation.
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderWindows();
  }

  /// The object to use for performing VerQueryValue calls.
  @visibleForTesting
  VersionInfoQuerier versionInfoQuerier = VersionInfoQuerier();

  /// This is typically the same as the TMP environment variable.
  @override
  Future<String?> getTemporaryPath() async {
    final Pointer<Utf16> buffer = calloc<Uint16>(MAX_PATH + 1).cast<Utf16>();
    String path;

    try {
      final int length = GetTempPath(MAX_PATH, buffer);

      if (length == 0) {
        final int error = GetLastError();
        throw _createWin32Exception(error);
      } else {
        path = buffer.toDartString();

        // GetTempPath adds a trailing backslash, but SHGetKnownFolderPath does
        // not. Strip off trailing backslash for consistency with other methods
        // here.
        if (path.endsWith(r'\')) {
          path = path.substring(0, path.length - 1);
        }
      }

      // Ensure that the directory exists, since GetTempPath doesn't.
      final Directory directory = Directory(path);
      if (!directory.existsSync()) {
        await directory.create(recursive: true);
      }

      return path;
    } finally {
      calloc.free(buffer);
    }
  }

  @override
  Future<String?> getApplicationSupportPath() =>
      _createApplicationSubdirectory(WindowsKnownFolder.RoamingAppData);

  @override
  Future<String?> getApplicationDocumentsPath() =>
      getPath(WindowsKnownFolder.Documents);

  @override
  Future<String?> getApplicationCachePath() =>
      _createApplicationSubdirectory(WindowsKnownFolder.LocalAppData);

  @override
  Future<String?> getDownloadsPath() => getPath(WindowsKnownFolder.Downloads);

  /// Retrieve any known folder from Windows.
  ///
  /// folderID is a GUID that represents a specific known folder ID, drawn from
  /// [WindowsKnownFolder].
  Future<String?> getPath(String folderID) {
    final Pointer<Pointer<Utf16>> pathPtrPtr = calloc<Pointer<Utf16>>();
    final Pointer<GUID> knownFolderID = calloc<GUID>()..ref.parse(folderID);

    try {
      final int hr = SHGetKnownFolderPath(
        knownFolderID,
        KF_FLAG_DEFAULT,
        NULL,
        pathPtrPtr,
      );

      if (FAILED(hr)) {
        if (hr == E_INVALIDARG || hr == E_FAIL) {
          throw _createWin32Exception(hr);
        }
        return Future<String?>.value();
      }

      final String path = pathPtrPtr.value.toDartString();
      return Future<String>.value(path);
    } finally {
      calloc.free(pathPtrPtr);
      calloc.free(knownFolderID);
    }
  }

  String? _getStringValue(Pointer<Uint8>? infoBuffer, String key) =>
      versionInfoQuerier.getStringValue(infoBuffer, key,
          language: languageEn, encoding: encodingCP1252) ??
      versionInfoQuerier.getStringValue(infoBuffer, key,
          language: languageEn, encoding: encodingUnicode);

  /// Returns the relative path string to append to the root directory returned
  /// by Win32 APIs for application storage (such as RoamingAppDir) to get a
  /// directory that is unique to the application.
  ///
  /// The convention is to use company-name\product-name\. This will use that if
  /// possible, using the data in the VERSIONINFO resource, with the following
  /// fallbacks:
  /// - If the company name isn't there, that component will be dropped.
  /// - If the product name isn't there, it will use the exe's filename (without
  ///   extension).
  String _getApplicationSpecificSubdirectory() {
    String? companyName;
    String? productName;

    final Pointer<Utf16> moduleNameBuffer =
        calloc<WCHAR>(MAX_PATH + 1).cast<Utf16>();
    final Pointer<DWORD> unused = calloc<DWORD>();
    Pointer<BYTE>? infoBuffer;
    try {
      // Get the module name.
      final int moduleNameLength =
          GetModuleFileName(0, moduleNameBuffer, MAX_PATH);
      if (moduleNameLength == 0) {
        final int error = GetLastError();
        throw _createWin32Exception(error);
      }

      // From that, load the VERSIONINFO resource
      final int infoSize = GetFileVersionInfoSize(moduleNameBuffer, unused);
      if (infoSize != 0) {
        infoBuffer = calloc<BYTE>(infoSize);
        if (GetFileVersionInfo(moduleNameBuffer, 0, infoSize, infoBuffer) ==
            0) {
          calloc.free(infoBuffer);
          infoBuffer = null;
        }
      }
      companyName =
          _sanitizedDirectoryName(_getStringValue(infoBuffer, 'CompanyName'));
      productName =
          _sanitizedDirectoryName(_getStringValue(infoBuffer, 'ProductName'));

      // If there was no product name, use the executable name.
      productName ??=
          path.basenameWithoutExtension(moduleNameBuffer.toDartString());

      return companyName != null
          ? path.join(companyName, productName)
          : productName;
    } finally {
      calloc.free(moduleNameBuffer);
      calloc.free(unused);
      if (infoBuffer != null) {
        calloc.free(infoBuffer);
      }
    }
  }

  /// Makes [rawString] safe as a directory component. See
  /// https://docs.microsoft.com/windows/win32/fileio/naming-a-file#naming-conventions
  ///
  /// If after sanitizing the string is empty, returns null.
  String? _sanitizedDirectoryName(String? rawString) {
    if (rawString == null) {
      return null;
    }
    String sanitized = rawString
        // Replace banned characters.
        .replaceAll(RegExp(r'[<>:"/\\|?*]'), '_')
        // Remove trailing whitespace.
        .trimRight()
        // Ensure that it does not end with a '.'.
        .replaceAll(RegExp(r'[.]+$'), '');
    const int kMaxComponentLength = 255;
    if (sanitized.length > kMaxComponentLength) {
      sanitized = sanitized.substring(0, kMaxComponentLength);
    }
    return sanitized.isEmpty ? null : sanitized;
  }

  Future<String?> _createApplicationSubdirectory(String folderId) async {
    final String? baseDir = await getPath(folderId);
    if (baseDir == null) {
      return null;
    }
    final Directory directory =
        Directory(path.join(baseDir, _getApplicationSpecificSubdirectory()));
    // Ensure that the directory exists if possible, since it will on other
    // platforms. If the name is longer than MAXPATH, creating will fail, so
    // skip that step; it's up to the client to decide what to do with the path
    // in that case (e.g., using a short path).
    if (directory.path.length <= MAX_PATH) {
      if (!directory.existsSync()) {
        await directory.create(recursive: true);
      }
    }
    return directory.path;
  }
}

Exception _createWin32Exception(int errorCode) {
  return PlatformException(
      code: 'Win32 Error',
      // TODO(stuartmorgan): Consider getting the system error message via
      // FormatMessage if it turns out to be necessary for debugging issues.
      // Plugin-client-level usability isn't a major consideration since per
      // https://github.com/flutter/flutter/blob/master/docs/ecosystem/contributing/README.md#platform-exception-handling
      // any case that comes up in practice should be handled and returned
      // via a plugin-specific exception, not this fallback.
      message: 'Error code 0x${errorCode.toRadixString(16)}');
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\path_provider_windows_stub.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

/// A stub implementation to satisfy compilation of multi-platform packages that
/// depend on path_provider_windows. This should never actually be created.
///
/// Notably, because path_provider needs to manually register
/// path_provider_windows, anything with a transitive dependency on
/// path_provider will also depend on path_provider_windows, not just at the
/// pubspec level but the code level.
class PathProviderWindows extends PathProviderPlatform {
  /// Errors on attempted instantiation of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be created.
  PathProviderWindows() : assert(false);

  /// Registers the Windows implementation.
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderWindows();
  }

  /// Stub; see comment on VersionInfoQuerier.
  VersionInfoQuerier versionInfoQuerier = VersionInfoQuerier();

  /// Match PathProviderWindows so that the analyzer won't report invalid
  /// overrides if tests provide fake PathProviderWindows implementations.
  Future<String> getPath(String folderID) async => '';
}

/// Stub to satisfy the analyzer, which doesn't seem to handle conditional
/// exports correctly.
class VersionInfoQuerier {}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\win32_wrappers.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The types and functions here correspond directly to corresponding Windows
// types and functions, so the Windows docs are the definitive source of
// documentation.
// ignore_for_file: public_member_api_docs

import 'dart:ffi';

import 'package:ffi/ffi.dart';

import 'guid.dart';

typedef BOOL = Int32;
typedef BYTE = Uint8;
typedef DWORD = Uint32;
typedef UINT = Uint32;
typedef HANDLE = IntPtr;
typedef HMODULE = HANDLE;
typedef HRESULT = Int32;
typedef LPCVOID = Pointer<NativeType>;
typedef LPCWSTR = Pointer<Utf16>;
typedef LPDWORD = Pointer<DWORD>;
typedef LPWSTR = Pointer<Utf16>;
typedef LPVOID = Pointer<NativeType>;
typedef PUINT = Pointer<UINT>;
typedef PWSTR = Pointer<Pointer<Utf16>>;
typedef WCHAR = Uint16;

const int NULL = 0;

// https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry
const int MAX_PATH = 260;

// https://learn.microsoft.com/windows/win32/seccrypto/common-hresult-values
// ignore: non_constant_identifier_names
final int E_FAIL = 0x80004005.toSigned(32);
// ignore: non_constant_identifier_names
final int E_INVALIDARG = 0x80070057.toSigned(32);

// https://learn.microsoft.com/windows/win32/api/winerror/nf-winerror-failed#remarks
// ignore: non_constant_identifier_names
bool FAILED(int hr) => hr < 0;

// https://learn.microsoft.com/windows/win32/api/shlobj_core/ne-shlobj_core-known_folder_flag
const int KF_FLAG_DEFAULT = 0x00000000;

final DynamicLibrary _dllKernel32 = DynamicLibrary.open('kernel32.dll');
final DynamicLibrary _dllVersion = DynamicLibrary.open('version.dll');
final DynamicLibrary _dllShell32 = DynamicLibrary.open('shell32.dll');

// https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath
typedef _FFITypeSHGetKnownFolderPath = HRESULT Function(
    Pointer<GUID>, DWORD, HANDLE, PWSTR);
typedef FFITypeSHGetKnownFolderPathDart = int Function(
    Pointer<GUID>, int, int, Pointer<Pointer<Utf16>>);
// ignore: non_constant_identifier_names
final FFITypeSHGetKnownFolderPathDart SHGetKnownFolderPath =
    _dllShell32.lookupFunction<_FFITypeSHGetKnownFolderPath,
        FFITypeSHGetKnownFolderPathDart>('SHGetKnownFolderPath');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfow
typedef _FFITypeGetFileVersionInfoW = BOOL Function(
    LPCWSTR, DWORD, DWORD, LPVOID);
typedef FFITypeGetFileVersionInfoW = int Function(
    Pointer<Utf16>, int, int, Pointer<NativeType>);
// ignore: non_constant_identifier_names
final FFITypeGetFileVersionInfoW GetFileVersionInfo = _dllVersion
    .lookupFunction<_FFITypeGetFileVersionInfoW, FFITypeGetFileVersionInfoW>(
        'GetFileVersionInfoW');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizew
typedef _FFITypeGetFileVersionInfoSizeW = DWORD Function(LPCWSTR, LPDWORD);
typedef FFITypeGetFileVersionInfoSizeW = int Function(
    Pointer<Utf16>, Pointer<Uint32>);
// ignore: non_constant_identifier_names
final FFITypeGetFileVersionInfoSizeW GetFileVersionInfoSize =
    _dllVersion.lookupFunction<_FFITypeGetFileVersionInfoSizeW,
        FFITypeGetFileVersionInfoSizeW>('GetFileVersionInfoSizeW');

// https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
typedef _FFITypeGetLastError = DWORD Function();
typedef FFITypeGetLastError = int Function();
// ignore: non_constant_identifier_names
final FFITypeGetLastError GetLastError = _dllKernel32
    .lookupFunction<_FFITypeGetLastError, FFITypeGetLastError>('GetLastError');

// https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew
typedef _FFITypeGetModuleFileNameW = DWORD Function(HMODULE, LPWSTR, DWORD);
typedef FFITypeGetModuleFileNameW = int Function(int, Pointer<Utf16>, int);
// ignore: non_constant_identifier_names
final FFITypeGetModuleFileNameW GetModuleFileName = _dllKernel32.lookupFunction<
    _FFITypeGetModuleFileNameW,
    FFITypeGetModuleFileNameW>('GetModuleFileNameW');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verqueryvaluew
typedef _FFITypeVerQueryValueW = BOOL Function(LPCVOID, LPCWSTR, LPVOID, PUINT);
typedef FFITypeVerQueryValueW = int Function(
    Pointer<NativeType>, Pointer<Utf16>, Pointer<NativeType>, Pointer<Uint32>);
// ignore: non_constant_identifier_names
final FFITypeVerQueryValueW VerQueryValue =
    _dllVersion.lookupFunction<_FFITypeVerQueryValueW, FFITypeVerQueryValueW>(
        'VerQueryValueW');

// https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettemppathw
typedef _FFITypeGetTempPathW = DWORD Function(DWORD, LPWSTR);
typedef FFITypeGetTempPathW = int Function(int, Pointer<Utf16>);
// ignore: non_constant_identifier_names
final FFITypeGetTempPathW GetTempPath = _dllKernel32
    .lookupFunction<_FFITypeGetTempPathW, FFITypeGetTempPathW>('GetTempPathW');
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\path_provider_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// path_provider_windows is implemented using FFI; export a stub for platforms
// that don't support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'src/folders_stub.dart' if (dart.library.ffi) 'src/folders.dart';
export 'src/path_provider_windows_stub.dart'
    if (dart.library.ffi) 'src/path_provider_windows_real.dart';
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\test\guid_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_windows/src/guid.dart';

void main() {
  test('has correct byte representation', () async {
    final Pointer<GUID> guid = calloc<GUID>()
      ..ref.parse('{00112233-4455-6677-8899-aabbccddeeff}');
    final ByteData data = ByteData(16)
      ..setInt32(0, guid.ref.data1, Endian.little)
      ..setInt16(4, guid.ref.data2, Endian.little)
      ..setInt16(6, guid.ref.data3, Endian.little)
      ..setInt64(8, guid.ref.data4, Endian.little);
    expect(data.getUint8(0), 0x33);
    expect(data.getUint8(1), 0x22);
    expect(data.getUint8(2), 0x11);
    expect(data.getUint8(3), 0x00);
    expect(data.getUint8(4), 0x55);
    expect(data.getUint8(5), 0x44);
    expect(data.getUint8(6), 0x77);
    expect(data.getUint8(7), 0x66);
    expect(data.getUint8(8), 0x88);
    expect(data.getUint8(9), 0x99);
    expect(data.getUint8(10), 0xAA);
    expect(data.getUint8(11), 0xBB);
    expect(data.getUint8(12), 0xCC);
    expect(data.getUint8(13), 0xDD);
    expect(data.getUint8(14), 0xEE);
    expect(data.getUint8(15), 0xFF);

    calloc.free(guid);
  });

  test('handles alternate forms', () async {
    final Pointer<GUID> guid1 = calloc<GUID>()
      ..ref.parse('{00112233-4455-6677-8899-aabbccddeeff}');
    final Pointer<GUID> guid2 = calloc<GUID>()
      ..ref.parse('00112233445566778899AABBCCDDEEFF');

    expect(guid1.ref.data1, guid2.ref.data1);
    expect(guid1.ref.data2, guid2.ref.data2);
    expect(guid1.ref.data3, guid2.ref.data3);
    expect(guid1.ref.data4, guid2.ref.data4);

    calloc.free(guid1);
    calloc.free(guid2);
  });

  test('throws for bad data', () async {
    final Pointer<GUID> guid = calloc<GUID>();

    expect(() => guid.ref.parse('{00112233-4455-6677-88'), throwsArgumentError);

    calloc.free(guid);
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\test\path_provider_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:path_provider_windows/src/path_provider_windows_real.dart'
    show encodingCP1252, encodingUnicode, languageEn;

// A fake VersionInfoQuerier that just returns preset responses.
class FakeVersionInfoQuerier implements VersionInfoQuerier {
  FakeVersionInfoQuerier(
    this.responses, {
    this.language = languageEn,
    this.encoding = encodingUnicode,
  });

  final String language;
  final String encoding;
  final Map<String, String> responses;

  // ignore: unreachable_from_main
  String? getStringValue(
    Pointer<Uint8>? versionInfo,
    String key, {
    required String language,
    required String encoding,
  }) {
    if (language == this.language && encoding == this.encoding) {
      return responses[key];
    } else {
      return null;
    }
  }
}

void main() {
  test('registered instance', () {
    PathProviderWindows.registerWith();
    expect(PathProviderPlatform.instance, isA<PathProviderWindows>());
  });

  test('getTemporaryPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    expect(await pathProvider.getTemporaryPath(), contains(r'C:\'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with no version info', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier =
        FakeVersionInfoQuerier(<String, String>{});
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'AppData'));
    // The last path component should be the executable name.
    expect(path, endsWith(r'flutter_tester'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with full version info in CP1252', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, encoding: encodingCP1252);
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with full version info in Unicode', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test(
      'getApplicationSupportPath with full version info in Unsupported Encoding',
      () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, language: '0000', encoding: '0000');
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'AppData'));
    // The last path component should be the executable name.
    expect(path, endsWith(r'flutter_tester'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with missing company', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'ProductName': 'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with problematic values', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': r'A <Bad> Company: Name.',
      'ProductName': r'A"/Terrible\|App?*Name',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(
          path,
          endsWith(
              r'AppData\Roaming\A _Bad_ Company_ Name\A__Terrible__App__Name'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with a completely invalid company', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': r'..',
      'ProductName': r'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with very long app name', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String truncatedName = 'A' * 255;
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': truncatedName * 2,
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, endsWith('\\$truncatedName'));
    // The directory won't exist, since it's longer than MAXPATH, so don't check
    // that here.
  }, skip: !Platform.isWindows);

  test('getApplicationDocumentsPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String? path = await pathProvider.getApplicationDocumentsPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'Documents'));
  }, skip: !Platform.isWindows);

  test('getApplicationCachePath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, encoding: encodingCP1252);
    final String? path = await pathProvider.getApplicationCachePath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Local\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getDownloadsPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String? path = await pathProvider.getDownloadsPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'Downloads'));
  }, skip: !Platform.isWindows);
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\pubspec.yaml =====
name: path_provider_windows
description: Windows implementation of the path_provider plugin
repository: https://github.com/flutter/packages/tree/main/packages/path_provider/path_provider_windows
issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+path_provider%22
version: 2.3.0

environment:
  sdk: ^3.2.0
  flutter: ">=3.16.0"

flutter:
  plugin:
    implements: path_provider
    platforms:
      windows:
        dartPluginClass: PathProviderWindows

dependencies:
  ffi: ^2.0.0
  flutter:
    sdk: flutter
  path: ^1.8.0
  path_provider_platform_interface: ^2.1.0

dev_dependencies:
  flutter_test:
    sdk: flutter

topics:
  - files
  - path-provider
  - paths
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\integration_test\shared_preferences_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('SharedPreferencesWindows', () {
    late SharedPreferencesWindows preferences;

    const Map<String, Object> flutterTestValues = <String, Object>{
      'flutter.String': 'hello world',
      'flutter.Bool': true,
      'flutter.Int': 42,
      'flutter.Double': 3.14159,
      'flutter.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> prefixTestValues = <String, Object>{
      'prefix.String': 'hello world',
      'prefix.Bool': true,
      'prefix.Int': 42,
      'prefix.Double': 3.14159,
      'prefix.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> nonPrefixTestValues = <String, Object>{
      'String': 'hello world',
      'Bool': true,
      'Int': 42,
      'Double': 3.14159,
      'StringList': <String>['foo', 'bar'],
    };

    final Map<String, Object> allTestValues = <String, Object>{};

    allTestValues.addAll(flutterTestValues);
    allTestValues.addAll(prefixTestValues);
    allTestValues.addAll(nonPrefixTestValues);

    Future<void> addData() async {
      await preferences.setValue('String', 'String', allTestValues['String']!);
      await preferences.setValue('Bool', 'Bool', allTestValues['Bool']!);
      await preferences.setValue('Int', 'Int', allTestValues['Int']!);
      await preferences.setValue('Double', 'Double', allTestValues['Double']!);
      await preferences.setValue(
          'StringList', 'StringList', allTestValues['StringList']!);
      await preferences.setValue(
          'String', 'prefix.String', allTestValues['prefix.String']!);
      await preferences.setValue(
          'Bool', 'prefix.Bool', allTestValues['prefix.Bool']!);
      await preferences.setValue(
          'Int', 'prefix.Int', allTestValues['prefix.Int']!);
      await preferences.setValue(
          'Double', 'prefix.Double', allTestValues['prefix.Double']!);
      await preferences.setValue('StringList', 'prefix.StringList',
          allTestValues['prefix.StringList']!);
      await preferences.setValue(
          'String', 'flutter.String', allTestValues['flutter.String']!);
      await preferences.setValue(
          'Bool', 'flutter.Bool', allTestValues['flutter.Bool']!);
      await preferences.setValue(
          'Int', 'flutter.Int', allTestValues['flutter.Int']!);
      await preferences.setValue(
          'Double', 'flutter.Double', allTestValues['flutter.Double']!);
      await preferences.setValue('StringList', 'flutter.StringList',
          allTestValues['flutter.StringList']!);
    }

    setUp(() async {
      preferences = SharedPreferencesWindows();
      await addData();
    });

    tearDown(() async {
      await preferences.clearWithParameters(
        ClearParameters(
          filter: PreferencesFilter(prefix: ''),
        ),
      );
    });

    testWidgets('getAll', (WidgetTester _) async {
      final Map<String, Object> values = await preferences.getAll();
      expect(values['flutter.String'], allTestValues['flutter.String']);
      expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
      expect(values['flutter.Int'], allTestValues['flutter.Int']);
      expect(values['flutter.Double'], allTestValues['flutter.Double']);
      expect(values['flutter.StringList'], allTestValues['flutter.StringList']);
    });

    group('withPrefix', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('prefix.');
        Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithPrefix('flutter.');
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('');
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });

    group('withParameters', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('get all with allow list', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.String'},
            ),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters with allow list',
          (WidgetTester _) async {
        await addData();
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.StringList'},
            ),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });
  });

  group('shared_preferences_async', () {
    const SharedPreferencesWindowsOptions emptyOptions =
        SharedPreferencesWindowsOptions();

    const String stringKey = 'testString';
    const String boolKey = 'testBool';
    const String intKey = 'testInt';
    const String doubleKey = 'testDouble';
    const String listKey = 'testList';

    const String testString = 'hello world';
    const bool testBool = true;
    const int testInt = 42;
    const double testDouble = 3.14159;
    const List<String> testList = <String>['foo', 'bar'];

    Future<SharedPreferencesAsyncPlatform> getPreferences(
        {bool clear = true}) async {
      final SharedPreferencesAsyncPlatform preferences =
          SharedPreferencesAsyncPlatform.instance!;
      if (clear) {
        await preferences.clear(
            const ClearPreferencesParameters(filter: PreferencesFilters()),
            emptyOptions);
      }
      return preferences;
    }

    testWidgets('set and get String', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setString(stringKey, testString, emptyOptions);
      expect(await preferences.getString(stringKey, emptyOptions), testString);
    });

    testWidgets('set and get bool', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setBool(boolKey, testBool, emptyOptions);
      expect(await preferences.getBool(boolKey, emptyOptions), testBool);
    });

    testWidgets('set and get int', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setInt(intKey, testInt, emptyOptions);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
    });

    testWidgets('set and get double', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    });

    testWidgets('set and get StringList', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList does not throw cast error',
        (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      await (preferences as SharedPreferencesAsyncWindows).reload(emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList returns mutable list', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      final List<String>? list =
          await preferences.getStringList(listKey, emptyOptions);
      list?.add('value');
      expect(list?.length, testList.length + 1);
    });

    testWidgets('getPreferences', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(gotAll.length, 5);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
      expect(gotAll[intKey], testInt);
      expect(gotAll[doubleKey], testDouble);
      expect(gotAll[listKey], testList);
    });

    testWidgets('getPreferences with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(gotAll.length, 2);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
    });

    testWidgets('getKeys', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(keys.length, 5);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
      expect(keys, contains(intKey));
      expect(keys, contains(doubleKey));
      expect(keys, contains(listKey));
    });

    testWidgets('getKeys with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(keys.length, 2);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
    });

    testWidgets('clear', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), null);
      expect(await preferences.getDouble(doubleKey, emptyOptions), null);
      expect(await preferences.getStringList(listKey, emptyOptions), null);
    });

    testWidgets('clear with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);
      await preferences.clear(
        const ClearPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );
      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'SharedPreferences Demo',
      home: SharedPreferencesDemo(),
    );
  }
}

class SharedPreferencesDemo extends StatefulWidget {
  const SharedPreferencesDemo({super.key});

  @override
  SharedPreferencesDemoState createState() => SharedPreferencesDemoState();
}

class SharedPreferencesDemoState extends State<SharedPreferencesDemo> {
  final SharedPreferencesAsyncPlatform? _prefs =
      SharedPreferencesAsyncPlatform.instance;
  final SharedPreferencesWindowsOptions options =
      const SharedPreferencesWindowsOptions();
  static const String _counterKey = 'counter';
  late Future<int> _counter;

  Future<void> _incrementCounter() async {
    final int? value = await _prefs!.getInt(_counterKey, options);
    final int counter = (value ?? 0) + 1;

    setState(() {
      _counter = _prefs.setInt(_counterKey, counter, options).then((_) {
        return counter;
      });
    });
  }

  Future<void> _getAndSetCounter() async {
    setState(() {
      _counter = _prefs!.getInt(_counterKey, options).then((int? counter) {
        return counter ?? 0;
      });
    });
  }

  @override
  void initState() {
    super.initState();
    _getAndSetCounter();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SharedPreferences Demo'),
      ),
      body: Center(
          child: FutureBuilder<int>(
              future: _counter,
              builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
                switch (snapshot.connectionState) {
                  case ConnectionState.none:
                  case ConnectionState.waiting:
                    return const CircularProgressIndicator();
                  case ConnectionState.active:
                  case ConnectionState.done:
                    if (snapshot.hasError) {
                      return Text('Error: ${snapshot.error}');
                    } else {
                      return Text(
                        'Button tapped ${snapshot.data} time${snapshot.data == 1 ? '' : 's'}.\n\n'
                        'This should persist across restarts.',
                      );
                    }
                }
              })),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\pubspec.yaml =====
name: shared_preferences_windows_example
description: Demonstrates how to use the shared_preferences_windows plugin.
publish_to: none

environment:
  sdk: ^3.3.0
  flutter: ">=3.19.0"

dependencies:
  flutter:
    sdk: flutter
  shared_preferences_platform_interface: ^2.4.0
  shared_preferences_windows:
    # When depending on this package from a real application you should use:
    #   shared_preferences_windows: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ../

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter

flutter:
  uses-material-design: true
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\lib\shared_preferences_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:convert' show json;

import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:path/path.dart' as path;
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

const String _defaultFileName = 'shared_preferences';

const String _defaultPrefix = 'flutter.';

/// The Windows implementation of [SharedPreferencesStorePlatform].
///
/// This class implements the `package:shared_preferences` functionality for Windows.
class SharedPreferencesWindows extends SharedPreferencesStorePlatform {
  /// Deprecated instance of [SharedPreferencesWindows].
  /// Use [SharedPreferencesStorePlatform.instance] instead.
  @Deprecated('Use `SharedPreferencesStorePlatform.instance` instead.')
  static SharedPreferencesWindows instance = SharedPreferencesWindows();

  /// Registers the Windows implementation.
  static void registerWith() {
    SharedPreferencesStorePlatform.instance = SharedPreferencesWindows();
    // A temporary work-around for having two plugins contained in a single package.
    SharedPreferencesAsyncWindows.registerWith();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_windows instance used to find the support directory.
  @visibleForTesting
  PathProviderWindows pathProvider = PathProviderWindows();

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences() async {
    _cachedPreferences ??= await _readFromFile(
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }

  @override
  Future<bool> clear() async {
    return clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<bool> clearWithPrefix(String prefix) async {
    return clearWithParameters(
        ClearParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<bool> clearWithParameters(ClearParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;

    final Map<String, Object> preferences = await _readPreferences();
    preferences.removeWhere((String key, _) =>
        key.startsWith(filter.prefix) &&
        (filter.allowList == null || filter.allowList!.contains(key)));
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getAll() async {
    return getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<Map<String, Object>> getAllWithPrefix(String prefix) async {
    return getAllWithParameters(
        GetAllParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<Map<String, Object>> getAllWithParameters(
      GetAllParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;
    final Map<String, Object> withPrefix =
        Map<String, Object>.from(await _readPreferences());
    withPrefix.removeWhere((String key, _) => !(key.startsWith(filter.prefix) &&
        (filter.allowList?.contains(key) ?? true)));
    return withPrefix;
  }

  @override
  Future<bool> remove(String key) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences.remove(key);
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<bool> setValue(String valueType, String key, Object value) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences[key] = value;
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }
}

/// The Windows implementation of [SharedPreferencesAsyncPlatform].
///
/// This class implements the `package:shared_preferences` functionality for Windows.
base class SharedPreferencesAsyncWindows
    extends SharedPreferencesAsyncPlatform {
  /// Registers the Windows implementation.
  static void registerWith() {
    SharedPreferencesAsyncPlatform.instance = SharedPreferencesAsyncWindows();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_windows instance used to find the support directory.
  @visibleForTesting
  PathProviderWindows pathProvider = PathProviderWindows();

  @override
  Future<Set<String>> getKeys(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return (await getPreferences(parameters, options)).keys.toSet();
  }

  @override
  Future<void> setString(
    String key,
    String value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setBool(
    String key,
    bool value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setDouble(
    String key,
    double value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setInt(
    String key,
    int value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setStringList(
    String key,
    List<String> value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<String?> getString(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as String?;
  }

  @override
  Future<bool?> getBool(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as bool?;
  }

  @override
  Future<double?> getDouble(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as double?;
  }

  @override
  Future<int?> getInt(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as int?;
  }

  @override
  Future<List<String>?> getStringList(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return (data[key] as List<Object?>?)?.cast<String>().toList();
  }

  @override
  Future<void> clear(ClearPreferencesParameters parameters,
      SharedPreferencesOptions options) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final PreferencesFilters filter = parameters.filter;
    final Map<String, Object> preferences =
        await _readPreferences(windowsOptions.fileName);
    preferences.removeWhere((String key, _) =>
        filter.allowList == null || filter.allowList!.contains(key));
    await _writePreferences(
      preferences,
      windowsOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getPreferences(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return _readAll(parameters.filter.allowList, options);
  }

  /// Reloads preferences from file.
  @visibleForTesting
  Future<void> reload(
    SharedPreferencesWindowsOptions options,
  ) async {
    _cachedPreferences = await _readFromFile(options.fileName);
  }

  Future<Map<String, Object>> _readAll(
    Set<String>? allowList,
    SharedPreferencesOptions options,
  ) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> prefs = Map<String, Object>.from(
        await _readPreferences(windowsOptions.fileName));
    prefs.removeWhere((String key, _) => !(allowList?.contains(key) ?? true));
    return prefs;
  }

  Future<void> _setValue(
      String key, Object value, SharedPreferencesOptions options) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> preferences =
        await _readPreferences(windowsOptions.fileName);
    preferences[key] = value;
    await _writePreferences(
      preferences,
      windowsOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences(String fileName) async {
    _cachedPreferences ??= await _readFromFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }
}

/// Gets the file where the preferences are stored.
Future<File?> _getLocalDataFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  pathProvider = pathProvider ?? PathProviderWindows();
  final String? directory = await pathProvider.getApplicationSupportPath();
  if (directory == null) {
    return null;
  }
  final String fileLocation = path.join(directory, '$fileName.json');
  return fs.file(fileLocation);
}

/// Gets the preferences from the stored file.
Future<Map<String, Object>> _readFromFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  Map<String, Object> preferences = <String, Object>{};
  final File? localDataFile = await _getLocalDataFile(
    fileName,
    fs: fs,
    pathProvider: pathProvider,
  );
  if (localDataFile != null && localDataFile.existsSync()) {
    final String stringMap = localDataFile.readAsStringSync();
    if (stringMap.isNotEmpty) {
      final Object? data = json.decode(stringMap);
      if (data is Map) {
        preferences = data.cast<String, Object>();
      }
    }
  }
  return preferences;
}

/// Writes the cached preferences to disk. Returns [true] if the operation
/// succeeded.
Future<bool> _writePreferences(
  Map<String, Object> preferences,
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  try {
    final File? localDataFile = await _getLocalDataFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    if (localDataFile == null) {
      debugPrint('Unable to determine where to write preferences.');
      return false;
    }
    if (!localDataFile.existsSync()) {
      localDataFile.createSync(recursive: true);
    }
    final String stringMap = json.encode(preferences);
    localDataFile.writeAsStringSync(stringMap);
  } catch (e) {
    debugPrint('Error saving preferences to disk: $e');
    return false;
  }
  return true;
}

/// Windows specific SharedPreferences Options.
class SharedPreferencesWindowsOptions extends SharedPreferencesOptions {
  /// Constructor for SharedPreferencesWindowsOptions.
  const SharedPreferencesWindowsOptions({
    this.fileName = 'shared_preferences', // Same as current defaults.
  });

  /// The name of the file to store preferences in.
  final String fileName;

  /// Returns a new instance of [SharedPreferencesWindowsOptions] from an existing
  /// [SharedPreferencesOptions].
  static SharedPreferencesWindowsOptions fromSharedPreferencesOptions(
      SharedPreferencesOptions options) {
    if (options is SharedPreferencesWindowsOptions) {
      return options;
    }
    return const SharedPreferencesWindowsOptions();
  }
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\fake_path_provider_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

/// Fake implementation of PathProviderWindows that returns hard-coded paths,
/// allowing tests to run on any platform.
///
/// Note that this should only be used with an in-memory filesystem, as the
/// path it returns is a root path that does not actually exist on Windows.
class FakePathProviderWindows extends PathProviderPlatform
    implements PathProviderWindows {
  @override
  late VersionInfoQuerier versionInfoQuerier;

  @override
  Future<String?> getApplicationSupportPath() async => r'C:\appsupport';

  @override
  Future<String?> getTemporaryPath() async => null;

  @override
  Future<String?> getLibraryPath() async => null;

  @override
  Future<String?> getApplicationDocumentsPath() async => null;

  @override
  Future<String?> getDownloadsPath() async => null;

  @override
  Future<String> getPath(String folderID) async => '';
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\legacy_shared_preferences_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:convert';

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

import 'fake_path_provider_windows.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderWindows pathProvider;

  SharedPreferencesWindows.registerWith();

  const Map<String, Object> flutterTestValues = <String, Object>{
    'flutter.String': 'hello world',
    'flutter.Bool': true,
    'flutter.Int': 42,
    'flutter.Double': 3.14159,
    'flutter.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> prefixTestValues = <String, Object>{
    'prefix.String': 'hello world',
    'prefix.Bool': true,
    'prefix.Int': 42,
    'prefix.Double': 3.14159,
    'prefix.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> nonPrefixTestValues = <String, Object>{
    'String': 'hello world',
    'Bool': true,
    'Int': 42,
    'Double': 3.14159,
    'StringList': <String>['foo', 'bar'],
  };

  final Map<String, Object> allTestValues = <String, Object>{};

  allTestValues.addAll(flutterTestValues);
  allTestValues.addAll(prefixTestValues);
  allTestValues.addAll(nonPrefixTestValues);

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderWindows();
  });

  Future<String> getFilePath() async {
    final String? directory = await pathProvider.getApplicationSupportPath();
    return path.join(directory!, 'shared_preferences.json');
  }

  Future<void> writeTestFile(String value) async {
    fs.file(await getFilePath())
      ..createSync(recursive: true)
      ..writeAsStringSync(value);
  }

  Future<String> readTestFile() async {
    return fs.file(await getFilePath()).readAsStringSync();
  }

  SharedPreferencesWindows getPreferences() {
    final SharedPreferencesWindows prefs = SharedPreferencesWindows();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('registered instance', () async {
    SharedPreferencesWindows.registerWith();
    expect(SharedPreferencesStorePlatform.instance,
        isA<SharedPreferencesWindows>());
  });

  test('getAll', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('prefix.');
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with Prefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with Prefix with allow list', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String?, Object?> all = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.Bool'},
        ),
      ),
    );
    expect(all.length, 1);
    expect(all['prefix.Bool'], prefixTestValues['prefix.Bool']);
  });

  test('remove', () async {
    await writeTestFile('{"key1":"one","key2":2}');
    final SharedPreferencesWindows prefs = getPreferences();

    await prefs.remove('key2');

    expect(await readTestFile(), '{"key1":"one"}');
  });

  test('setValue', () async {
    await writeTestFile('{}');
    final SharedPreferencesWindows prefs = getPreferences();

    await prefs.setValue('', 'key1', 'one');
    await prefs.setValue('', 'key2', 2);

    expect(await readTestFile(), '{"key1":"one","key2":2}');
  });

  test('clear', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    expect(await readTestFile(), json.encode(flutterTestValues));
    await prefs.clear();
    expect(await readTestFile(), '{}');
  });

  test('clearWithPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithPrefix('prefix.');
    final Map<String, Object> noValues =
        await prefs.getAllWithPrefix('prefix.');
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('');
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithPrefix('');
    final Map<String, Object> noValues = await prefs.getAllWithPrefix('');
    expect(noValues, hasLength(0));
  });

  test('clearWithParameters with Prefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('clearWithParameters with allow list', () async {
    await writeTestFile(json.encode(prefixTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.StringList'},
        ),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(4));
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(noValues, hasLength(0));
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\shared_preferences_windows_async_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

import 'fake_path_provider_windows.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderWindows pathProvider;

  SharedPreferencesAsyncWindows.registerWith();

  const String stringKey = 'testString';
  const String boolKey = 'testBool';
  const String intKey = 'testInt';
  const String doubleKey = 'testDouble';
  const String listKey = 'testList';

  const String testString = 'hello world';
  const bool testBool = true;
  const int testInt = 42;
  const double testDouble = 3.14159;
  const List<String> testList = <String>['foo', 'bar'];

  const SharedPreferencesWindowsOptions emptyOptions =
      SharedPreferencesWindowsOptions();

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderWindows();
  });

  SharedPreferencesAsyncWindows getPreferences() {
    final SharedPreferencesAsyncWindows prefs = SharedPreferencesAsyncWindows();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('set and get String', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), testString);
  });

  test('set and get bool', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setBool(boolKey, testBool, emptyOptions);
    expect(await preferences.getBool(boolKey, emptyOptions), testBool);
  });

  test('set and get int', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setInt(intKey, testInt, emptyOptions);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
  });

  test('set and get double', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
  });

  test('set and get StringList', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setStringList(listKey, testList, emptyOptions);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });

  test('getPreferences', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);

    expect(gotAll.length, 5);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
    expect(gotAll[intKey], testInt);
    expect(gotAll[doubleKey], testDouble);
    expect(gotAll[listKey], testList);
  });

  test('getPreferences with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
            filter:
                PreferencesFilters(allowList: <String>{stringKey, boolKey})),
        emptyOptions);

    expect(gotAll.length, 2);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
  });

  test('getKeys', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(filter: PreferencesFilters()),
      emptyOptions,
    );

    expect(keys.length, 5);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
    expect(keys, contains(intKey));
    expect(keys, contains(doubleKey));
    expect(keys, contains(listKey));
  });

  test('getKeys with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );

    expect(keys.length, 2);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
  });

  test('clear', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), null);
    expect(await preferences.getDouble(doubleKey, emptyOptions), null);
    expect(await preferences.getStringList(listKey, emptyOptions), null);
  });

  test('clear with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
      const ClearPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });
}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\pubspec.yaml =====
name: shared_preferences_windows
description: Windows implementation of shared_preferences
repository: https://github.com/flutter/packages/tree/main/packages/shared_preferences/shared_preferences_windows
issue_tracker: https://github.com/flutter/flutter/issues?q=is%3Aissue+is%3Aopen+label%3A%22p%3A+shared_preferences%22
version: 2.4.1

environment:
  sdk: ^3.3.0
  flutter: ">=3.19.0"

flutter:
  plugin:
    implements: shared_preferences
    platforms:
      windows:
        dartPluginClass: SharedPreferencesWindows

dependencies:
  file: ">=6.0.0 <8.0.0"
  flutter:
    sdk: flutter
  path: ^1.8.0
  path_provider_platform_interface: ^2.0.0
  path_provider_windows: ^2.0.0
  shared_preferences_platform_interface: ^2.4.0

dev_dependencies:
  flutter_test:
    sdk: flutter

topics:
  - persistence
  - shared-preferences
  - storage
===== C:\Users\target\Depi\graduation_project\Team-dpi-\analysis_options.yaml =====
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
===== C:\Users\target\Depi\graduation_project\Team-dpi-\devtools_options.yaml =====
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
===== C:\Users\target\Depi\graduation_project\Team-dpi-\firebase.json =====
{"flutter":{"platforms":{"android":{"default":{"projectId":"depi-project-1dda8","appId":"1:536287924777:android:a9d0f015b00e9dbac0c238","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"depi-project-1dda8","configurations":{"android":"1:536287924777:android:a9d0f015b00e9dbac0c238","ios":"1:536287924777:ios:0742c9ef1fa072f8c0c238","macos":"1:536287924777:ios:0742c9ef1fa072f8c0c238","web":"1:536287924777:web:3ae2479728c41cf3c0c238","windows":"1:536287924777:web:64c510d4f7dfe2ffc0c238"}}}}}}
===== C:\Users\target\Depi\graduation_project\Team-dpi-\pubspec.yaml =====
name: depi_project
description: "A new Flutter project."
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: ^3.8.1

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  cupertino_icons: ^1.0.8
  lucide_icons: ^0.257.0
  animate_do: ^3.0.2
  firebase_core: ^4.2.0
  firebase_auth: ^6.1.1
  cloud_firestore: ^6.0.3
  dartz: ^0.10.1
  equatable: ^2.0.5
  shared_preferences: ^2.5.3
  awesome_snackbar_content: ^0.1.7
  bloc: ^9.0.1
  get_it: ^8.2.0
  flutter_bloc: ^9.1.1
  modal_progress_hud_nsn: ^0.5.1
  flutter_phone_direct_caller: ^2.2.1
  flutter_dotenv: ^6.0.0
  video_thumbnail: ^0.5.6
  uuid: ^4.5.1
  skeletonizer: ^2.1.0+1
  dio: ^5.9.0
  image_picker: ^1.2.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0

flutter:
  uses-material-design: true
  assets:
     - assets/images/
     - .env
  #   - images/a_dot_ham.jpeg
  fonts:
    - family: Cairo
      fonts:
        - asset: assets/fonts/Cairo-Regular.ttf
        - asset: assets/fonts/Cairo-Medium.ttf
          weight: 500
        - asset: assets/fonts/Cairo-SemiBold.ttf
          weight: 600
        - asset: assets/fonts/Cairo-Bold.ttf
          weight: 700
flutter_intl:
  enabled: true
